<object clone="/obj/properties" owner="kargh">
  <Core:PropertyContainer>
    <Ur:UrObject/>
    <Core:PCProperties>
      <Core:Property property="#id#">"TAS"</Core:Property>
      <Core:Property property="#list#">
         X[M] /*

-----------------------------------
 LIBRARY CONTENT (Merry/SAM)

 Object:        Lib:Assist:lib:assistlibs
 Maintainer:    Aziel
 Email:         kargh@eternalis.com
 Revision:      10.45
 Generated:     Sun Sep 25 01:48:56 2011 on Jonkichi
 Last revision: Wed Jun  1 10:22:01 2011 by zwoc (E)



(Do not modify #list# -- it is automatically constructed.)


------------------------------------------------------------------------------------------------------------------
 lib:create_tree            (M) Creates the tree
 lib:create_tree_output     (M) Create tree output
 lib:create_tree_output_rec (M) Create tree output recursive
 lib:create_tree_output_suf (M) Create suffix for queue name
 lib:create_tree_rec        (M) Tree creation recursive
 lib:doabort                (M) Sets abort.
 lib:doaddnote              (M) Adds a note to your personal calendar
 lib:doaddqueue             (M) Add a Queue if it does not exist
 lib:doassign               (M) Assigns an assist to a specific person and informs them on login.
 lib:doassociate            (M) Associate a queue with an account on a specific server
 lib:doattach               (M) Display the attachment popup to the user for a specific assist/task.
 lib:dobackup               (M) Script to backup the assist DBs.
 lib:docalendar             (M) Create and display calendar
 lib:docalendar_day         (M) Displays specific day info
 lib:docalendar_new         (M) New calendar code
 lib:docharobj              (M) Gets the character object
 lib:dochatfeed             (M) Does all the required chatfeeding
 lib:dochathide             (M) Sets chatline ignore list to hide output.
 lib:dochatshow             (M) Sets chatline show list to show output.
 lib:doclaim                (M) Claims assist
 lib:docleanup              (M) Cleanup Code for Various Uses
 lib:docreatesearchdb       (M) Creates the search db
 lib:docreatesearchdb_init  (M) Initializes the new search db, parsing through entire TAS db.
 lib:docreatestats          (M) Sets appropriate stats
 lib:docron                 (M) Runs the delay loop for the backup script.
 lib:docurrent              (M) Creates a long table of all assist info
 lib:dodiscard              (M) Discards an assist with a generic message
 lib:dodone                 (M) Moves an assist from the current queue to the finished queue.
 lib:dofileassist           (M) Creates a new filed assist
 lib:doflag                 (M) Adds a flag to an assist
 lib:doflaglist             (M) List available flags
 lib:dofocus                (M) Sets your queue focus for subqueues
 lib:doforget               (M) Removes a watched assist.
 lib:dogetassist            (M) Gets the assist from the appropriate object and returns an array.
 lib:dohelp                 (M) Lists help or specific help
 lib:doinfo                 (M) Lists all the info for an assist.
 lib:doinit                 (M) Initial the general DB
 lib:dolink                 (M) Links assists together
 lib:dolistbyplayer         (M) Lists all open assist for player
 lib:dolistwhat             (M) Decides what to do. List a queue or claim an assist
 lib:dolock                 (M) Locks a queue
 lib:dologin                (M) Displays defined queues.
 lib:dologon                (M) Alert line if player logs in and has an assist marked with the Alert flag. Also
                                alert staffer if they have an assist claimed.
 lib:donote                 (M) Add a note to the assist
 lib:doonline               (M) Checks connected players to see if they have any assists open.
 lib:doopage                (M) Sends an opage to the player who filed the task for the assist specified
 lib:doopen                 (M) Shows all open assists
 lib:dopopup                (M) For testing TAS popup code
 lib:doprefer               (M) Sets your preferred queue for the +/!tas command queue list
 lib:dopriority             (M) Change priority of a task
 lib:doprivate              (M) Set a queue as private
 lib:dopublic               (M) Set a queue as public
 lib:doqueue                (M) Lists the queues
 lib:doqueuedesc            (M) Give a queue a description
 lib:doqueueinfo            (M) Displays info for queue
 lib:doqueuesme             (M) Shows you the content of any queues you are monitoring.
 lib:dorecap                (M) Shows assists filed in last 24 hours.
 lib:dorecent               (M) Lists the top 25 most recent filed tasks
 lib:dorelay                (M) Relays a task to the relay server
 lib:doremovequeue          (M) Remove a Queue if it does not exist
 lib:dorename               (M) Renames a queue and all assists that were members of that queue.
 lib:doretrieve             (M) Retrieve an assist and dump it back into the new queue to be dealt with as
                                appropriate.
 lib:doreturn               (M) Return your assist back to the queue it came from
 lib:doschedule             (M) Sticks a task to the specified calendar date
 lib:dosearch               (M) Searches all assists for string.
 lib:dosendemail            (M) Sends an email for special queues as defined in mapping:queues:email
 lib:dosetassist            (M) Creates a new assist. Sets it in the appropriate DB. Creates a new DB if
                                necessary.
 lib:dosettype              (M) Switches a queue between long and short format
 lib:doshift                (M) Shifts alert status from character A to character B
 lib:doshortclosed          (M) Shows all closed assists for queue
 lib:doshowall              (M) Shows info for all assists in queue
 lib:doshowclosed           (M) Shows all closed assists for queue
 lib:doslide                (M) Moves a queue into a subqueue
 lib:dostatbyqueue          (M) Additional Script Testing Space
 lib:dostats                (M) Displays Assist Statistics
 lib:dotransfer             (M) Transfers open assists from one queue to another.
 lib:dotree                 (M) Tree listing of all queues
 lib:dotwiki                (M) TWikize the output for easy copy and paste into twiki
 lib:dounlock               (M) Unlocks a queue
 lib:dowatch                (M) Watches an assist for changes. Alerts you on login.
 lib:searchdb_decode        (M) Interpret (string) value in SearchDB bigmap.
 lib:searchdb_encode        (M) Create string value from array (of integers), for SearchDB bigmap.
------------------------------------------------------------------------------------------------------------------

*/
      </Core:Property>
      <Core:Property property="html:popup">
         X[S] \<pre\>\$[assist::dolistwhat(\$actor: Obj(\$actor), \$data: Obj(\$data), \$cmd: \$cmd, \$popup: "true", \$words: (\{ \$que \})); \$output]\</pre\>
      </Core:Property>
      <Core:Property property="html:popup:attach">
         X[S] \<html\>
  \<head\>\<title\>Attach data to #\$[\$num]\</title\>\</head\>
\<body\>
  \<zsession zid="\$(zid)" body="\$(body)" num="\$(num)" actor="\$(actor)"\>
    \<zform zid="\$(zid)"\>
      \<b\>Paste your attachment into this textarea.\</b\>\<sbr/\>
      \<textarea style="border: solid #000000 1pt;" rows="20" cols="80" name="attachment"/\>\<sbr/\>
      \<input style="border: solid #000000 1pt; background: #ffdddd; font-weight: bold;" type="submit"/\>
      \<action\>
         \<redirect propob="\$(this)" prop="html:popup:doattach" zid="\$(zid)" data="\$(data)" tas="\$(tas)" note="\$(attachment)" num="\$(num)"/\>
      \</action\>
    \</zform\>
  \</zsession\>
\</body\>
\</html\>
      </Core:Property>
      <Core:Property property="html:popup:doattach">
         X[S] \<html\>
  \<head\>\<title\>Attach data to #\$[\$num]\</title\>\</head\>
\<body\>
  \<zsession zid="\$(zid)" body="\$(body)" actor="\$(actor)"\>
    \$[\$actor = Obj(\$actor);
      \$data = Obj(\$data);
      if( \$note[strlen(\$note)-1..] != "\\n" ) \$note = \$note + "\\n";
      \$note = (\{ "\\n------\\n" + \$note + "------" \});
      EmitTo( \$actor, "Attaching..." );

      ::donote();]
    Note added successfully. Feel free to close this window.
  \</zsession\>
\</body\>
\</html\>
      </Core:Property>
      <Core:Property property="html:twikipopup">
         X[S] \$[replace_strings(Obj(\$what).twikioutput, "\<", "\&lt;", "\>", "\&gt;", "@\\n@", "\<br\>")]
\$[Obj(\$what).twikioutput = nil;]
      </Core:Property>
      <Core:Property property="log:creator">
         "Aziel:TAS"
      </Core:Property>
      <Core:Property property="merry:inherit:lib:log">
         \<Lib:chatlib\>
      </Core:Property>
      <Core:Property property="merry:lib:create_tree">
         X[M] /* D=Creates the tree */

    int     i, sz;
    string  *list;
    mapping tree, parents;

    list    = \$data."array:queues";
    parents = \$data."mapping:subqueues";

    sz   = sizeof(list);
    tree = ([ ]);

    for (i = 0; i \< sz; i++) \{
       if (!parents[list[i]]) \{
   tree[list[i]] = ::create_tree_rec(\$queue: list[i]);
       \}
    \}

    return tree;
      </Core:Property>
      <Core:Property property="merry:lib:create_tree_output">
         X[M] /* D=Create tree output */

int i;
string *list;

list = map_indices(\$tree);

for (i = 0; i \< sizeof(list); i++) \{
  if (map_sizeof(\$tree[list[i]]) \> 0) \{
    \$output += spaces(2) + "`-\> " + capitalize(list[i]) + " - " + ::create_tree_output_suf(\$name: list[i]) + "\\n";
    ::create_tree_output_rec(\$queue: \$tree[list[i]], \$spacing: 8);
  \} else \{
    \$output += spaces(2) + "`-\> " + capitalize(list[i]) + " - " + ::create_tree_output_suf(\$name: list[i]) + "\\n";
  \}
\}

\$output += "\\n[S: System, E: Email Alerted, P: Private, G: Contains SubQueues, L: Locked Queue][Open/Claimed]\\n";

return \$output;
      </Core:Property>
      <Core:Property property="merry:lib:create_tree_output_rec">
         X[M] /* D=Create tree output recursive */

int i, spaces;
string *list;

spaces = \$spacing;

list = map_indices(\$queue);

for (i = 0; i \< sizeof(list); i++) \{
  if (map_sizeof(\$queue[list[i]]) \> 0) \{
    \$output += spaces(spaces) + "`-\> " + capitalize(list[i]) + " - " + ::create_tree_output_suf(\$name: list[i]) + "\\n";
    ::create_tree_output_rec(\$queue: \$queue[list[i]], \$spacing: spaces + 6);
  \} else \{
    \$output += spaces(spaces) + "`-\> " + capitalize(list[i]) + " - " + ::create_tree_output_suf(\$name: list[i]) + "\\n";

  \}
\}

return \$output;
      </Core:Property>
      <Core:Property property="merry:lib:create_tree_output_suf">
         X[M] /* D=Create suffix for queue name

    This command requires the following arguments:
      \$name: The queue

[SEPGL][Op/CL]
[SEL][12/0]
*/


\{
  string name;

  name = lower_case(\$name);

  \$flags = "[";
  \$flags += (member(name, \$data."array:queues:system") ? "S" : "");
  \$flags += (member(name, map_indices(\$data."mapping:queues:email")) ? "E" : "");
  \$flags += (member(name, map_indices(\$data."mapping:queues:private")) ? "P" : "");
  \$flags += ((Get(\$data, "array:subqueues:" + name) \&\& sizeof(Get(\$data, "array:subqueues:" + name)) \> 0) ? "G" : "");
  \$flags += (member(name, \$data."array:queues:locked") ? "L" : "");
  \$flags += "][";
  \$flags += Str(sizeof(Get(\$data, "array:open:" + name))) + "/" + Str(sizeof(Get(\$data, "array:claimed:" + name))) + "]";
  return \$flags;
\}
      </Core:Property>
      <Core:Property property="merry:lib:create_tree_rec">
         X[M] /* D=Tree creation recursive */

    /*
     * \$queue contains the queue for which we want to create the subtree.
     */
    mapping subtree;
    string *list;

    subtree = ([ ]);
    list = Get(\$data, "array:subqueues:" + \$queue);
    if (list) \{
       int i, sz;

       sz = sizeof(list);
       for (i = 0; i \< sz; i++) \{
   subtree[list[i]] = ::create_tree_rec(\$queue: list[i]);
       \}
    \}
    return subtree;
      </Core:Property>
      <Core:Property property="merry:lib:doabort">
         X[M] /* D=Sets abort.

     This command does not require any arguments.

*/

\$actor."tas:abort" = 1;

EmitTo(\$actor, "Aborted!");

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doaddnote">
         X[M] /* D=Adds a note to your personal calendar

    The following arguments are required:
      \$month : The month to add it
      \$day : The day to add it
      \$evoke : The note to add

    The following arguments are optional:
      \$year : The year to add it
*/

\{

int year, month, day, timestamp, firstday;
mapping calendar, month_cal, day_event, months;
mixed *day_cal;

  calendar = \$actor."tas:calendar";

  if (!\$month \|\| !\$day) \{
    EmitTo(\$actor, "You must include a month and a day.");
    return FALSE;
  \}

  if (\$year \&\& (catch(Int(\$year)) ? 0 : 1) == 0) \{
    EmitTo(\$actor, "The year must be in four digit format. (IE: 2003)");
    return FALSE;
  \}

  year = (!\$year ? Int(ctime(time())[20..]) : Int(\$year));

  timestamp = common::reverse_ctime(\$year: year, \$day: \$day, \$month: \$month);

  if (timestamp \< 20) \{
    EmitTo(\$actor, "Either the month, day or year that you supplied is not valid.");
    return FALSE;
  \}

  months = ([ "january":1, "february":2, "march":3, "april":4, "may":5, "june":6, "july":7, "august":8, "september":9,
              "october":10, "november":11, "december":12 ]);

  /* Modified
       if ((catch(Int(\$month)) ? 0 : 1) == 1) \{
     to not throw errors. */
  if (([ T_INT : 1, T_FLOAT : 1 ])[typeof(ascii_to_mixed(\$month))]) \{
    month = Int(\$month);
  \} else \{
    month = map_values(prefixed_map(months, lower_case(\$month)))[0];
  \}

  day = Int(\$day);
  firstday = common::reverse_ctime(\$year: year, \$month: month, \$day: 1);

  if (!calendar) \{
    \$actor."tas:calendar" = ([ firstday:([ timestamp:(\{ \$(raw-evoke) \}) ]) ]);
    EmitTo(\$actor, "You have added a memo to " + humanized_date(timestamp) + ".");
    return FALSE;
  \}

  month_cal = (member(firstday, map_indices(calendar)) ? calendar[firstday] : nil);

  if (!month_cal) \{
    \$actor."tas:calendar" += ([ firstday:([ timestamp:(\{ \$(raw-evoke) \}) ]) ]);
    EmitTo(\$actor, "You have added a memo to " + humanized_date(timestamp) + ".");
    return FALSE;
  \}

  day_cal = (member(timestamp, map_indices(month_cal)) ? month_cal[timestamp] : nil);

  if (!day_cal) \{
    month_cal += ([ timestamp:(\{ \$(raw-evoke) \}) ]);
    calendar[firstday] = nil;
    calendar += ([ firstday:month_cal ]);
    \$actor."tas:calendar" = calendar;
    EmitTo(\$actor, "You have added a memo to " + humanized_date(timestamp) + ".");
    return FALSE;
  \}

  day_cal += (\{ \$(raw-evoke) \});
  month_cal[timestamp] = nil;
  month_cal += ([ timestamp:day_cal ]);
  calendar[firstday] = nil;
  calendar += ([ firstday:month_cal ]);
  \$actor."tas:calendar" = calendar;
  EmitTo(\$actor, "You have added a memo to " + humanized_date(timestamp) + ".");
  return FALSE;
\}
      </Core:Property>
      <Core:Property property="merry:lib:doaddqueue">
         X[M] /* D=Add a Queue if it does not exist

     The following arguments are required:
       \$data: The data object
       \$queue: Name of the queue

*/

string *queues, queue;

queues = \$data."array:queues";

/* (Kalle, Nov 17, 2004) I see no reason why a queue cannot be named e.g. "happy5" so I'm removing the
   %s%d condition from the if case beneath.
[\|\| sscanf(\$queue, "%s%d", \$dummy, \$number) == 2 ]
*/
if (sscanf(\$queue, "%d%s", \$number, \$dummy) == 2 \|\| sscanf(\$queue, "%s%d%s", \$dummya, \$number, \$dummyb) == 2) \{

  EmitTo(\$actor, "Queue names can not contain numbers.");
  return FALSE;
\}

queue = lower_case(\$queue);

if (member(queue, \$data."array:badnames")) \{
  EmitTo(\$actor, "That is a bad name for a queue.");
  return FALSE;
\}

if (member(queue, \$data."array:queues:system")) \{
  EmitTo(\$actor, "The CE and NEW queue are system queues and may not be added or removed.");
  return FALSE;
\}

if (member(queue, queues)) \{
  EmitTo(\$actor, "The queue (" + capitalize(queue) + ") already exists.");
  return FALSE;
\}

if (strlen(queue) \> 20) \{
  EmitTo(\$actor, "The queue name must be 20 characters or less.");
  return FALSE;
\}

\$data."array:queues" += (\{ queue \});

Set(\$data, "array:claimed:" + queue, (\{ \}));
Set(\$data, "array:open:" + queue, (\{ \}));

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) +
         " has added the queue " + capitalize(queue) + ".\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "misc", \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));
      </Core:Property>
      <Core:Property property="merry:lib:doassign">
         X[M] /* D=Assigns an assist to a specific person and informs them on login.

     The following arguments are required:
       \$data: The DB object
       \$num: The assist number
       \$name: Who you are assigning this to

*/

if (!\$num \&\& !\$name) \{
  if (\$actor."array:assists:assigned" \&\& sizeof(\$actor."array:assists:assigned") \> 0) \{
    \$line = smalltime(time()) + spaces(1) + \$tas + " \\"The following tasks are assigned to you: " +
            implode(map_indices(arr_to_set(\$actor."array:assists:assigned")), ", ") + ".\\"";
    EmitTo(\$actor, TAG(\$line, "assist-alert"));
    return FALSE;
  \} else \{
    \$line = smalltime(time()) + spaces(1) + \$tas + " \\"You do not have any tasks assigned to you.\\"";
    EmitTo(\$actor, TAG(\$line, "assist-alert"));
    return FALSE;
  \}
\}

\$name = lower_case(\$name);

if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if (!member(\$num, map_indices(\$data."mapping:assists:open"))) \{
  EmitTo(\$actor, "You may not assign or unassign tasks that are closed.");
  return FALSE;
\}

if (\$name == "noone") \{
  \$assist = assist::dogetassist(\$num: \$num);
  if (\$assist["Assigned"] == "") \{
    EmitTo(\$actor, "That task is not assigned to anyone.");
    return FALSE;
  \}
  \$assigned = \$assist["Assigned"];
  \$assigned."array:assists:assigned" -= (\{ \$num \});

  \$assist["Assigned"] = nil;
  \$assist += ([ "Assigned":"" ]);
  assist::dosetassist(\$num: \$num, \$assist: \$assist);

  \$alert = smalltime(time()) + spaces(1) + \$tas + " \\"\<#" + \$num + "/" + capitalize(\$assist["Queue"]) +
           "\> has been assigned to NOONE by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "misc", \$exclude: (\{ \$actor \}));

  EmitTo(\$actor, TAG(\$alert, "assist-alert"));
  return FALSE;
\}

if (!common::lookup(\$name: \$name)) \{
  EmitTo(\$actor, "You must supply a valid name to assign the task to.");
  return FALSE;
\}

\$assigned = common::lookup(\$name: \$name);

\$assist = assist::dogetassist(\$num: \$num);

if (Str(\$assist["Assigned"]) == Str(\$assigned)) \{
  EmitTo(\$actor, "That task is already assigned to " + Describe(\$assigned) + ".");
  return FALSE;
\}

if (\$assist["Assigned"] == "") \{
  \$assist["Assigned"] = nil;
  \$assist += ([ "Assigned":\$assigned ]);
  assist::dosetassist(\$num: \$num, \$assist: \$assist);
  if (!\$assigned."array:assists:assigned") \{
    \$assigned."array:assists:assigned" = (\{ \$num \});
  \} else \{
    \$assigned."array:assists:assigned" += (\{ \$num \});
  \}
  \$alert = smalltime(time()) + spaces(1) + \$tas + " \\"\<#" + \$num + "/" + capitalize(\$assist["Queue"]) +
           "\> has been assigned to " + common::get_name(\$src: \$assigned) + " by " +
           chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "misc", \$exclude: (\{ \$actor \}));
  EmitTo(\$actor, TAG(\$alert, "assist-alert"));
  return FALSE;
\}

\$assignee = \$assist["Assigned"];

if (\$assignee) \{
    \$assignee."array:assists:assigned" -= (\{ \$num \});
\}

\$assist["Assigned"] = nil;
\$assist += ([ "Assigned":\$assigned ]);
assist::dosetassist(\$num: \$num, \$assist: \$assist);

if (!\$assigned."array:assists:assigned") \{
  \$assigned."array:assists:assigned" = (\{ \$num \});
\} else \{
  \$assigned."array:assists:assigned" += (\{ \$num \});
\}

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"\<#" + \$num + "/" + capitalize(\$assist["Queue"]) +
         "\> has been assigned to " + common::get_name(\$src: \$assigned) + " by " +
         chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "misc", \$exclude: (\{ \$actor \}));
EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
/*
 * ChangeLog [
 *      Change(Jun 29 2006 12:03; Zwoc)=Fixed "assignee is nil" issue at line 92.
 * ]
 */
      </Core:Property>
      <Core:Property property="merry:lib:doassociate">
         X[M] /* D=Associate a queue with an account on a specific server

     The following arguments are required:
       \$data: The db object
       \$queue: The queue


Check to see if queue exists
If queue is NONE then it removes your association
*/

\$filter = \$actor."udat:name" + "@task" + (\$actor."theatre:id" ? "@" + lower_case(\$actor."theatre:id") : "@marrach");

if (lower_case(\$queue) == "none") \{
  if (\$data."mapping:queues:forward"[\$filter]) \{
    \$data."mapping:queues:forward"[\$filter] = nil;
    EmitTo(\$actor, "Association with queue removed.");
    return FALSE;
  \} else \{
    EmitTo(\$actor, "You do not have an association setup.");
    return FALSE;
  \}
\}

if (!member(lower_case(\$queue), \$data."array:queues")) \{
  EmitTo(\$actor, "I am unable to associate you with that queue. Queue does not exist.");
  return FALSE;
\}

if (member(lower_case(\$queue), \$data."array:queues:system")) \{
  EmitTo(\$actor, "You may not associate yourself with a system queue.");
  return FALSE;
\}

\$data."mapping:queues:forward"[\$filter] = nil;
\$data."mapping:queues:forward" += ([ \$filter:lower_case(\$queue) ]);

EmitTo(\$actor, "Association to " + capitalize(\$queue) + " queue setup successfully.");

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doattach">
         X[M] /*
  D=Display the attachment popup to the user for a specific assist/task.

  Required argument(s):
    \$num: Assist #.
*/

Popup(\$actor, this, "popup:attach", \$actor: \$actor, \$num: \$num, \$data: \$data, \$tas: \$tas);
      </Core:Property>
      <Core:Property property="merry:lib:dobackup">
         X[M] /* D=Script to backup the assist DBs.

     The following arguments are required:
       \$data: The db object

    Changelog at bottom of page.

*/

\{
  \$data = \$\{Data:DB:assist:AssistGeneralDB\};

  \$emit = "6\|DB Backup Execution started @ " + ctime(time());
  assist::log(\$chat_log: \$emit);

  \$dbs = \$data."assist:current" / 1000;
  \$time = time();

  if (!\$data."backup:current") \{
    \$data."backup:current" = \$time;
  \} else \{
    \$data."backup:previous" = copy(\$data."backup:current");
    \$data."backup:current" = \$time;
  \}


  /* If there are no inital DB backups, lets create them now */
  for (\$i = 0; \$i \<= \$dbs; \$i++) \{
    \$db = "Data:DB:assist:AssistDB" + \$i;
    \$bkup = "Data:DB:assist:Backups:AssistDB" + \$i + "-1";
    if (!Obj(\$bkup)) \{
      \$obj = Duplicate(Obj(\$db));
      \$obj."core:objectname" = \$bkup;
      \$obj."#timestamp#" = \$time;
      \$obj."#backupver#" = 1.3;
    \}
  \}

  /* If there are no second copies, lets do that. */
  for (\$i = 0; \$i \<= \$dbs; \$i++) \{
    \$db = "Data:DB:assist:AssistDB" + \$i;
    \$bkup1 = "Data:DB:assist:Backups:AssistDB" + \$i + "-1";
    \$bkup2 = "Data:DB:assist:Backups:AssistDB" + \$i + "-2";
    if (!Obj(\$bkup2)) \{
      Obj(\$bkup1)."core:objectname" = \$bkup2;
      \$obj = Duplicate(Obj(\$db));
      \$obj."core:objectname" = \$bkup1;
      \$obj."#timestamp#" = \$time;
      \$obj."#backupver#" = 1.3;
    \}
    if (Obj(\$bkup1)."#timestamp#" == \$data."backup:previous") \{
      \$delay(15.0, FALSE, "4753");
      Obj(\$bkup2)."*" = Obj(\$bkup1)."*";
      Obj(\$bkup1)."*" = Obj(\$db)."*";
      Obj(\$bkup1)."#timestamp#" = \$time;
      Obj(\$bkup1)."#backupver#" = 1.3;
    \} else \{
      \$delay(15.0, FALSE, "2b87");
      Obj(\$bkup1)."*" = Obj(\$db)."*";
      Obj(\$bkup1)."#timestamp#" = \$time;
      Obj(\$bkup1)."#backupver#" = 1.3;
    \}
  \}
\}

\$delay(1.0, FALSE, "d475");

/* Lets backup the general db while we are at it */

\$gdb = "Data:DB:assist:AssistGeneralDB";
\$gbkup1 = "Data:DB:assist:Backups:AssistGeneralDB-1";
\$gbkup2 = "Data:DB:assist:Backups:AssistGeneralDB-2";


/* If there is no backup, lets create a new one */

if (!Obj(\$gbkup1)) \{
  \$obj = Duplicate(Obj(\$gdb));
  \$obj."core:objectname" = \$gbkup1;
  \$obj."#timestamp#" = \$time;
\}

/* Ok. So we have atleast one backup. Lets do the rest of the work */

if (!Obj(\$gbkup2)) \{
  Obj(\$gbkup1)."core:objectname" = \$gbkup2;
  \$obj = Duplicate(Obj(\$gdb));
  \$obj."core:objectname" = \$gbkup1;
  \$obj."#timestamp#" = \$time;
\}

if (Obj(\$gbkup1)."#timestamp#" == \$data."backup:previous") \{
  Slay(Obj(\$gbkup2));
  \$delay(1.0, FALSE, "b1ba");
  Obj(\$gbkup1)."core:objectname" = \$gbkup2;
  \$obj = Duplicate(Obj(\$gdb));
  \$obj."core:objectname" = \$gbkup1;
  \$obj."#timestamp#" = \$time;
\} else \{
  Slay(Obj(\$gbkup1));
  \$delay(1.0, FALSE, "0af6");
  \$obj = Duplicate(Obj(\$gdb));
  \$obj."core:objectname" = \$gbkup1;
  \$obj."#timestamp#" = \$time;
\}

\$emit = "6\|DB Backup Execution ended @ " + ctime(time());
assist::log(\$chat_log: \$emit);

/*
 * Changelog [
 *    Change(Sep 19 19:26, 2005; Zwoc)=Put in assist before the two ::log() entries, since CronDaemon doesn't play well otherwise.
 * ]
 */
      </Core:Property>
      <Core:Property property="merry:lib:docalendar">
         X[M] /* D=Create and display calendar

    The following arguments are optional:
      \$month : The month to list
      \$year : The year to list

    If month is not supplied then the current month shall be used. If year is not supplied then the current year will be used.

*/

\{
  string str;
  int i, days, startsecs;
  object udat_obj;
  mapping dayspermonth, personalcal, map_months, map_month;

  dayspermonth = ([ 1:31, 2:28, 3:31, 4:30, 5:31, 6:30, 7:31, 8:31, 9:30, 10:31, 11:30, 12:31 ]);
  udat_obj = \$actor."udat:object";

  map_months = ([ "january":0, "february":0, "march":0, "april":0, "may":0, "june":0, "july":0, "august":0, "september":0,
               "october":0, "november":0, "december":0 ]);

  if (!\$year \&\& \$month \&\& strlen(\$month) == 4 \&\& (catch(Int(\$month)) ? 1 : 0) == 0) \{
    \$year = \$month;
    \$month = lower_case(ctime(time())[4..6]);
  \}

  if (!\$month) \$month = lower_case(ctime(time())[4..6]);
  if (!\$year) \$year = Int(ctime(time())[20..]);

  /* Is the provided month a string?
   * If it is, lets try to convert it to a valid month code
   */
  if (typeof(\$month) == 3 \&\& (catch(Int(\$month)) ? 1 : 0) == 1) \{
    map_month = prefixed_map(map_months, lower_case(\$month));
    if (map_sizeof(map_month) == 0 \|\| map_sizeof(map_month) \> 1) \{
      EmitTo(\$actor, "You did not provide a valid month!");
      return FALSE;
    \}
    switch (map_indices(map_month)[0]) \{
      case "january" :
        \$month = 1;
        break;
      case "february" :
        \$month = 2;
        break;
      case "march" :
        \$month = 3;
        break;
      case "april" :
        \$month = 4;
        break;
      case "may" :
        \$month = 5;
        break;
      case "june" :
        \$month = 6;
        break;
      case "july" :
        \$month = 7;
        break;
      case "august" :
        \$month = 8;
        break;
      case "september" :
        \$month = 9;
        break;
      case "october" :
        \$month = 10;
        break;
      case "november" :
        \$month = 11;
        break;
      case "december" :
        \$month = 12;
        break;
    \}
    if (typeof(\$month) != 1) return 18;
  \}

  \$year = Int(\$year);
  \$month = Int(\$month);

  if (\$month \> 12 \|\| \$month \< 1) return FALSE;
  if (\$year \&\& (\$year \< 1970 \|\| \$year \> 2037)) return FALSE;

  startsecs = common::reverse_ctime(\$year: \$year, \$month: \$month, \$day: 1);

  days = dayspermonth[\$month];

  if (\$month == 2 \&\& \$year % 4 == 0) days = 29;

  personalcal = (udat_obj."tas:calendar" ? (udat_obj."tas:calendar"[startsecs] ? udat_obj."tas:calendar"[startsecs] : ([ ])) : ([ ]));

  str = "--[ Calendar for " + explode(explode(humanized_date(startsecs), ", ")[1], " ")[0] + spaces(1) + Str(\$year) + " ]------\\n";
  str += (\$short \&\& !personalcal[startsecs] ? "" : ctime(startsecs)[..strlen(ctime(startsecs)) - 15] + ":\\n");

  for (i = 1; i \< days; i++) \{
    startsecs = startsecs + 86400;
    str += (\$short \&\& !personalcal[startsecs] ? "" : ctime(startsecs)[..strlen(ctime(startsecs)) - 15] + ": " +
           (personalcal[startsecs] ? implode(personalcal[startsecs], ", ") + "\\n" : "\\n"));
  \}

  EmitTo(\$actor, PRE(str));
\}
      </Core:Property>
      <Core:Property property="merry:lib:docalendar_day">
         X[M] /* D=Displays specific day info

    The following arguments are required:
      \$month : The month to check
      \$day : the day to check

    The following arguments are optional:
      \$year : The yaer to check
*/

\{

string output, *sublist, groupmemos, body;
int i, z, y, month, day, year, firstday, datestr, timestamp;
mapping p_calendar, g_calendar, months, subevents;
mixed s_holidays, d_holidays, holidays, memos;
object calobj;

  groupmemos = "";
  body = "";

  \$calobj = "Data:DB:assist:AssistCalendarDB";
  calobj = Obj(\$calobj);

  if (!\$month \|\| !\$day) \{
    EmitTo(\$actor, "You must include a month and a day.");
    return FALSE;
  \}

  if (\$year \&\& common::isnan(\$value: \$year) == 1) \{
    EmitTo(\$actor, "The year must be in four digit format. (IE: 2003)");
    return FALSE;
  \}

  months = ([ "january":1, "february":2, "march":3, "april":4, "may":5, "june":6, "july":7, "august":8, "september":9,
               "october":10, "november":11, "december":12 ]);

  if (!\$year \&\& \$month \&\& map_sizeof(prefixed_map(months, \$month)) == 1 \&\& common::isnan(\$value: \$day) == 0) \{
/*
    if (get_month(time()) \> map_values(prefixed_map(months, \$month))[0] \|\| (get_month(time()) ==
        map_values(prefixed_map(months, \$month))[0] \&\& get_day(time()) \> Int(\$day))) \{
*/

    if (get_month(time()) \> map_values(prefixed_map(months, \$month))[0]) \{
      \$year = get_year(time()) + 1;
    \} else \{
      \$year = get_year(time());
    \}
  \}

  year = (!\$year ? Int(ctime(time())[20..]) : Int(\$year));

  timestamp = common::reverse_ctime(\$year: year, \$day: \$day, \$month: \$month);

  if (timestamp \< 20) \{
    EmitTo(\$actor, "Either the month, day or year that you supplied is not valid.");
    return FALSE;
  \}

  if (common::isnan(\$value: \$month) == 0) \{
    month = Int(\$month);
  \} else \{
    month = map_values(prefixed_map(months, lower_case(\$month)))[0];
  \}

  day = Int(\$day);
  firstday = common::reverse_ctime(\$year: year, \$month: month, \$day: 1);

  datestr = Int(Str(month) + Str((day \< 10 ? "0" + Str(day) : day)));

  p_calendar = (\$actor."tas:calendar" ? (member(firstday, map_indices(\$actor."tas:calendar")) ?
                \$actor."tas:calendar"[firstday] : ([ ])) : ([ ]));

  g_calendar = (\$actor."udat:object"."tas:calendar" ? (member(firstday, map_indices(\$actor."udat:object"."tas:calendar")) ?
                \$actor."udat:object"."tas:calendar"[firstday] : ([ ])) : ([ ]));

  s_holidays = (calobj."mapping:holidays:static" ? (member(Int(Str(month) + Str((day \< 10 ? "0" + Str(day) : day))),
                map_indices(calobj."mapping:holidays:static")) ? calobj."mapping:holidays:static"[Int(Str(month) + Str((day \<
                10 ? "0" + Str(day) : day)))] : (\{ \})) : (\{ \}));

  d_holidays = (calobj."mapping:holidays:dynamic" ? (member(Int(Str(month) + Str((day \< 10 ? "0" + Str(day) : day))),
                map_indices(calobj."mapping:holidays:dynamic")) ? calobj."mapping:holidays:dynamic"[Int(Str(month) + Str((day
                \< 10 ? "0" + Str(day) : day)))] : (\{ \})) : (\{ \}));

  output = "-=[ " + explode(humanized_date(timestamp), "M, ")[1] + " ]=-----\\n";

/*
EmitTo(\$actor, dump_value(p_calendar));
EmitTo(\$actor, dump_value(g_calendar));
EmitTo(\$actor, dump_value(s_holidays));
EmitTo(\$actor, dump_value(d_holidays));
*/

/*
  if (!member(timestamp, map_indices(p_calendar)) \&\& !member(timestamp, map_indices(g_calendar)) \&\&
      sizeof(s_holidays) == 0 \&\& sizeof(d_holidays) == 0) \{
    output += "There appears to be nothing noted for this day.";
    EmitTo(\$actor, PRE(output));
    return FALSE;
  \}
*/

  if (sizeof(s_holidays) \> 0 \|\| sizeof(d_holidays) \> 0) \{
    body += "\\n" + spaces(2) + "Holidays/Important Events Today:\\n";
    if (sizeof(s_holidays) \> 0) \{
      for (i = 0; i \< sizeof(s_holidays); i++) \{
        body += spaces(4) + s_holidays[i] + "\\n";
      \}
    \}
    if (sizeof(d_holidays) \> 0) \{
      for (i = 0; i \< sizeof(d_holidays); i++) \{
        body += spaces(4) + d_holidays[i] + "\\n";
      \}
    \}
  \}

  if (member(timestamp, map_indices(p_calendar)) \|\| member(timestamp, map_indices(g_calendar))) \{
    if (member(timestamp, map_indices(p_calendar))) \{
      memos = p_calendar[timestamp];
      body += "\\n" + spaces(2) + "Memos [Personal]:\\n";
      for (i = 0; i \< sizeof(memos); i++) \{
        body += spaces(4) + memos[i] + "\\n";
      \}
    \}
    if (member(timestamp, map_indices(g_calendar))) \{
      memos = g_calendar[timestamp];
      body += "\\n" + spaces(2) + "Memos [Tasks]:\\n" + spaces(4) + implode(memos, ", ") + "\\n";
    \}
  \}

  if (\$actor."tas:calendar:sublist") \{
    sublist = \$actor."tas:calendar:sublist";
    for (z = 0; z \< sizeof(sublist); z++) \{
      subevents = Get(calobj, "mapping:calendar:" + sublist[z]);
      if (member(datestr, map_indices(subevents))) \{
          memos = subevents[datestr];
        for (y = 0; y \< sizeof(memos); y++) \{
          groupmemos += spaces(4) + memos[y] + "\\n";
        \}
      \}
    \}
  \}

  if (strlen(groupmemos) \> 0) \{
    body += "\\n" + spaces(2) + "Memos [Group]:\\n" + groupmemos;
  \}

  if (strlen(body) \< 1) \{
    output += "There appears to be nothing noted for this day.";
  \} else \{
    output += body;
  \}

  EmitTo(\$actor, PRE(output));
  return FALSE;

\}
      </Core:Property>
      <Core:Property property="merry:lib:docalendar_new">
         X[M] /* D=New calendar code


    The following arguments are required:
      \$month: The month
      \$year : The year
*/


\{

int i, x, z, h, s, hnum, hpos, year, dayone, startnum, smallnum, pos, smallpos, startspot, numofdays, rows, datesecs,
    datestr, memos;
string month, day, header, body, *sublist;
object caldb;
mapping months, startday, dayspermonth, calendar, pcalendar, s_holidays, d_holidays, subevents;

  caldb = Obj("Data:DB:assist:AssistCalendarDB");

  body = "";
  startnum = 1;
  smallnum = 1;
  hnum = 1;
  pos = 1;
  smallpos = 1;
  hpos = 1;
  memos = 0;

  months = ([ "january":1, "february":2, "march":3, "april":4, "may":5, "june":6, "july":7, "august":8, "september":9,
               "october":10, "november":11, "december":12 ]);

  if (!\$year \&\& \$month \&\& map_sizeof(prefixed_map(months, \$month)) == 1) \{
    if (get_month(time()) \> map_values(prefixed_map(months, \$month))[0]) \{
      \$year = get_year(time()) + 1;
    \} else \{
      \$year = get_year(time());
    \}
  \}

  year = (!\$year ? Int(ctime(time())[20..]) : Int(\$year));
  month = (!\$month ? lower_case(ctime(time())[4..6]) : lower_case(\$month));

  dayone = common::reverse_ctime(\$year: year, \$month: month, \$day: 1);
  s_holidays = (caldb."mapping:holidays:static" ? caldb."mapping:holidays:static" : ([ ]));
  d_holidays = (caldb."mapping:holidays:dynamic" ? caldb."mapping:holidays:dynamic" : ([ ]));

  if (dayone \< 20) \{
    EmitTo(\$actor, "You must include a valid year and month!");
    return FALSE;
  \}

  day = lower_case(ctime(dayone)[..2]);

  if (common::isnan(\$value: month) == 0) \{
    month = reverse_mapping(months)[Int(month)];
  \}

  header = ".=======================================================.\\n\| " +
             upper_case(map_indices(prefixed_map(months, lower_case(month)))[0]) +
             spaces(1) + Str(year) + spaces((9 - strlen(map_indices(prefixed_map(months, lower_case(month)))[0])) + 40) +
             "\|\\n\|=======================================================\|\\n\|" + spaces(2) + "Sun" + spaces(2) + "\|" +
             spaces(2) + "Mon" + spaces(2) + "\|" + spaces(2) + "Tue" + spaces(2) + "\|" + spaces(2) + "Wed" + spaces(2) + "\|"
             + spaces(2) + "Thu" + spaces(2) + "\|" + spaces(2) + "Fri" + spaces(2) + "\|" + spaces(2) + "Sat" + spaces(2) +
             "\|\\n" + "\|=======================================================\|\\n";

  startday = ([ "sun":1, "mon":2, "tue":3, "wed":4, "thu":5, "fri":6, "sat":7 ]);
  startspot = startday[lower_case(day)];

  dayspermonth = ([ "january":31, "february":28, "march":31, "april":30, "may":31, "june":30, "july":31, "august":31,
                     "september":30, "october":31, "november":30, "december":31 ]);

  numofdays = dayspermonth[map_indices(prefixed_map(dayspermonth, lower_case(month)))[0]];

  if (lower_case(month) == "feb" \&\& year % 4 == 0) \{
    numofdays = 29;
  \}

  rows = Int(ceil(Flt(numofdays + startspot) / Flt(7)));
  rows = ((numofdays + (startspot - 1)) % 7 == 0 ? rows : rows + 1);

  calendar = (\$actor."udat:object"."tas:calendar" ? (member(dayone,
               map_indices(\$actor."udat:object"."tas:calendar")) ?
               \$actor."udat:object"."tas:calendar"[dayone] : ([ ])) :
               ([ ]));

  pcalendar = (\$actor."tas:calendar" ? (member(dayone, map_indices(\$actor."tas:calendar")) ? \$actor."tas:calendar"[dayone] :
              ([ ])) : ([ ]));

  for (i = 1; i \< rows; i++) \{
    for(x = 1; x \< 8; x++) \{
      body += "\|" + spaces(3);
      if (pos \< startspot) \{
        body += spaces(1);
      \} else \{
        body += (startnum \> numofdays ? spaces(1) : Str(startnum));
      \}
      body += (strlen(Str(startnum)) == 1 \|\| startnum \> numofdays ? spaces(3) : spaces(2));
      pos++;
      startnum = (pos \> startspot ? startnum + 1 : startnum);
    \}
  body += "\|\\n";

    for(h = 1; h \< 8; h++) \{
      if (hpos \< startspot) \{
        body += "\|" + spaces(7);
      \} else if (member(Int(Str(months[map_indices(prefixed_map(months, month))[0]]) + (hnum \< 10 ? "0" + Str(hnum) :
                 Str(hnum))), map_indices(s_holidays)) \|\| member(Int(Str(months[map_indices(prefixed_map(months, month))[0]])
                 + (hnum \< 10 ? "0" + Str(hnum) : Str(hnum))), map_indices(d_holidays))) \{
        body += "\|" + "Holiday";
      \} else \{
        body += "\|" + spaces(7);
      \}
      hpos++;
      hnum = (hpos \> startspot ? hnum + 1 : hnum);
    \}
  body += "\|\\n";

/*
    body += "\|\\n\|" + spaces(7) + "\|" + spaces(7) + "\|" + spaces(7) + "\|" + spaces(7) + "\|" + spaces(7) + "\|" + spaces(7) +
              "\|" + spaces(7) + "\|\\n";
*/

    if (map_sizeof(calendar) \> 0 \|\| map_sizeof(pcalendar) \> 0 \|\| \$actor."tas:calendar:sublist") \{
      for (z = 1; z \< 8; z++) \{
        if (smallpos \>= startspot) \{
          datesecs = common::reverse_ctime(\$year: year, \$month: month, \$day: smallnum);
          if (member(datesecs, map_indices(calendar)) \|\| member(datesecs, map_indices(pcalendar))) \{
            memos = 1;
          \}
          if (\$actor."tas:calendar:sublist") \{
            datestr = Int(Str(months[map_indices(prefixed_map(months, month))[0]]) + (smallnum \< 10 ? "0" + Str(smallnum) :
                      Str(smallnum)));
            sublist = \$actor."tas:calendar:sublist";
            for (s = 0; s \< sizeof(sublist); s++) \{
              subevents = Get(caldb, "mapping:calendar:" + sublist[s]);
              if (subevents \&\& member(datestr, map_indices(subevents))) \{
                memos = 1;
              \}
            \}
          \}
          if (memos == 1) \{
            body += "\|" + spaces(3) + TAG("*", "assist-alert") + spaces(3);
          \} else \{
            body += "\|" + spaces(7);
          \}

          memos = 0;
/*
(member(datesecs, map_indices(calendar)) \|\| member(datesecs, map_indices(pcalendar)) ?
                   "*" : " ") + spaces(3);
*/

        \} else \{
           body += "\|" + spaces(7);
        \}
        smallpos++;
        smallnum = (smallpos \> startspot ? smallnum + 1 : smallnum);
      \}
      body += "\|\\n";

    \} else \{
      body += "\|" + spaces(7) + "\|" + spaces(7) + "\|" + spaces(7) + "\|" + spaces(7) + "\|" + spaces(7) + "\|" + spaces(7) +
               "\|" + spaces(7) + "\|\\n";
    \}

    if (i == rows - 1) \{
      body += "'======================================================='\\n";
    \} else \{
      body += "\|-------+-------+-------+-------+-------+-------+-------\|\\n";
    \}
  \}

  \$output = header + body;

  EmitTo(\$actor, PRE(\$output));
  return FALSE;
\}
      </Core:Property>
      <Core:Property property="merry:lib:docharobj">
         X[M] /* D=Gets the character object

     The following arguments are required:
       \$num: THe assist number

   This function returns the object or nil if an object cannot be determined.

*/


\$assist = assist::dogetassist(\$num: \$num);

\$charobj = \$assist["CharObj"];

if (\$charobj) \{
  return \$charobj;
\}

return nil;
      </Core:Property>
      <Core:Property property="merry:lib:dochatfeed">
         X[M] /* D=Does all the required chatfeeding

     The following arguments are required:
       \$alert: The text message you want to feed
       \$style: The style you want to use
       \$ignore: The system ID for the command
       \$exclude: Array of objs to exclude
*/

chat::feed(\$chat_datlib: \$\{Data:DB:chat:tas\}, \$chat_cname: "tas", \$chat_data: "\<lfc pri=\\"7\\" id=\\"" +
lower_case((\$ignore ? \$ignore : "tas")) + "\\"\>" +
\$alert, \$chat_style: (\$style ? \$style : "assist-alert"), \$chat_exclude: (\$exclude ? \$exclude : (\{ \})));

return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:dochathide">
         X[M] /* D=Sets chatline ignore list to hide output.

     The following arguments are required:
       \$chat: The chatline

*/

\$ignores = ([ ]);
\$ignores += (!Get(\$actor, \$cname + ":ignores") ? ([ ]) : Get(\$actor, \$cname + ":ignores"));

if (!\$chat) \{
  if (map_sizeof(\$ignores) \< 1) \{
    EmitTo(\$actor, TAG(smalltime(time()) + spaces(1) + \$tas + " \\"You do not have any queues hidden.", "assist-alert"));
    return FALSE;
  \}
  EmitTo(\$actor, TAG(smalltime(time()) + spaces(1) + \$tas + " \\"You have the following queues hidden: " +
                 implode(map_indices(\$ignores), ", ") + "\\"", "assist-alert"));
  return FALSE;
\}

if (member(lower_case(\$chat), map_indices(\$ignores))) \{
  EmitTo(\$actor, "You are already hiding " + upper_case(\$chat) + " output from the chatline.");
  return FALSE;
\}

if (map_sizeof(\$ignores) \> 0) \{
  Set(\$actor, \$cname + ":ignores", \$ignores + ([ lower_case(\$chat):1 ]));
\} else \{
  Set(\$actor, \$cname + ":ignores", ([ lower_case(\$chat):1 ]));
\}

EmitTo(\$actor, "You have added " + upper_case(\$chat) + " to your ignore list for the chatline.");
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dochatshow">
         X[M] /* D=Sets chatline show list to show output.

     The following arguments are required:
       \$chat: The chatline

*/

\$ignores = ([ ]);
\$ignores += Get(\$actor, \$cname + ":ignores");

if (!member(lower_case(\$chat), map_indices(\$ignores))) \{
  EmitTo(\$actor, "You are already show " + upper_case(\$chat) + " output from the chatline.");
  return FALSE;
\}

\$ignores[lower_case(\$chat)] = nil;
Set(\$actor, \$cname + ":ignores", \$ignores);

EmitTo(\$actor, "You have removed " + upper_case(\$chat) + " from your ignore list for the chatline.");
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doclaim">
         X[M] /* D=Claims assist

     The following arguments are required:
       \$num: The number of the assist
       \$data: The data object

     The following arguments are optional:
       \$silent: If true, does not send the chatline alert
*/

string queue;
mapping assistee, assist;

assistee = \$data."mapping:assistee";
queue = \$data."mapping:assists:open"[Str(\$num)];


/* Claim Pre Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["claim-pre"] \&\& sizeof(\$triggers["claim-pre"]) \> 1) \{
     \$trig_claim_pre = \$triggers["claim-pre"];
     Call(\$trig_claim_pre[0], \$trig_claim_pre[1]);
  \}
\}

/* ... */


if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if (member(\$actor."udat:name", map_indices(assistee))) \{
  EmitTo(\$actor, "You have task #" + assistee[\$actor."udat:name"] +
                 " open. Please close or return that task before claiming another one.");
  return FALSE;
\}

if (!queue) \{
  EmitTo(\$actor, "Task #" + \$num + " is not an open task. If you wish to open it, you must "  +
                 UnSAM(ParseXML("\<acmd tag='command' cmd='!tas retrieve " + \$num + "'\>retrieve\</acmd\>")) +
                 " it first or if someone else has it claimed, they must \\'return\\' it to the queue.");
  return FALSE;
\}

if (member(\$num, map_values(assistee))) \{
  EmitTo(\$actor, "Task #" + \$num + " is already claimed.");
  return FALSE;
\}

if (!\$actor."udat:name") \{
  EmitTo(\$actor, "You do not seem to have a valid account name. Without one, you are unable to claim a task. " +
                 "Most likely cause of this is that you are using the TAS popup and have switched or possessed " +
                 "a new body between the time of opening the popup and the time of trying to claim a task.");
  return FALSE;
\}

if (\$actor."udat:name" \&\& \$actor."skotos:creator" \&\& \$actor."udat:name" != \$actor."skotos:creator") \{
  EmitTo(\$actor, "You are trying to claim a task from a body that is not yours. Please possess a body on your account and try again.");
  return FALSE;
\}



/* All the checks are done. Now lets do the actual moving around of data */

assist = assist::dogetassist(\$num: \$num);

if (member(assist["Queue"], \$data."array:queues:locked") \&\& \$actor."udat:host" == 0) \{
  EmitTo(\$actor, "That task is in a locked queue. You may not claim it.");
  return FALSE;
\}

\$data."mapping:assistee" += ([ \$actor."udat:name":Str(\$num) ]);

Set(\$data, "array:open:" + queue, Get(\$data, "array:open:" + queue) - (\{ Int(\$num) \}) );

Set(\$data, "array:claimed:" + queue, Get(\$data, "array:claimed:" + queue) + (\{ Int(\$num) \}) );

assist["Assistee"] = nil;
assist += ([ "Assistee":Str(\$actor) ]);
assist["TimeClaimed"] = nil;
assist +=([ "TimeClaimed":Str(time()) ]);

assist::dosetassist(\$num: \$num, \$assist: assist);

assist::docreatestats(\$data: \$data, \$action: "claim");

/* Claim Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["claim"] \&\& sizeof(\$triggers["claim"]) \> 1) \{
     \$trig_claim = \$triggers["claim"];
     Call(\$trig_claim[0], \$trig_claim[1]);
  \}
\}

/* ... */



if (!\$silent) \{
  EmitTo(\$actor, TAG( smalltime(time()) + spaces(1) + \$tas + " \\"You have claimed task #" + \$num + " from the " +
                 capitalize(queue) + " queue.\\n\\n\<" + capitalize(assist["Account"]) + "/" +
                 common::get_name(\$src: assist["CharObj"]) + "\>: " + assist["AssistText"] +
                 (strlen((\$r2 = assist["Notes"])) \> 0 ? "\\n\\n\<Additional Notes\>: " + \$r2 +
                 "For specific information regarding this task, type: " + UnSAM(ParseXML("\<acmd tag='command' cmd='" + \$cmd +
                 " info " + \$num + "'\>" + \$cmd + " info " + \$num + "\</acmd\>")) : "\\n\\nFor specific information " +
                 "regarding this task, type: " + UnSAM(ParseXML("\<acmd tag='command' cmd='" + \$cmd + " info " + \$num + "'\>" +
                 \$cmd + " info " + \$num + "\</acmd\>"))) + "\\nTo return (unclaim) it, type: " +
                 UnSAM(ParseXML("\<acmd tag='command' cmd='" + \$cmd + " return'\>" + \$cmd +
                 " return\</acmd\>\\n")), "assist-alert"));

  \$alert = smalltime(time()) + spaces(1) + \$tas + " \\"\<#" + \$num + "/" + capitalize(queue) + "\> claimed by " +
           chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: queue, \$exclude: (\{ \$actor \}));

\}

/* Claim Post Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["claim-post"] \&\& sizeof(\$triggers["claim-post"]) \> 1) \{
     \$trig_claim_post = \$triggers["claim-post"];
     Call(\$trig_claim_post[0], \$trig_claim_post[1]);
  \}
\}

/* ... */

\$ok = "true";

return \$ok;
      </Core:Property>
      <Core:Property property="merry:lib:docleanup">
         X[M] /* D=Cleanup Code for Various Uses */

\$fixme = (\{ \});
\$added = ([ ]);
\$updated = ([ ]);
\$ok = (\{ \});
\$odd = (\{ \});
\$data = nil /* defunct */;

for (\$i = \$data."assist:current"; \$i \> 0; \$i--) \{
  \$assist = copy(assist::dogetassist(\$num: \$i));
  if (!\$assist["CharObj"]) \{
    if (Obj(\$assist["Character"])) \{
      \$assist += ([ "CharObj":Obj(\$assist["Character"]) ]);

      \$added += ([ \$i:Obj(\$assist["Character"]) ]);

      assist::dosetassist(\$num: \$i, \$assist: \$assist);

    \} else \{
      \$fixme += (\{ \$i \});
    \}
  \} else if (!Obj(\$assist["Character"])) \{
      \$assist["Character"] = nil;
      \$assist += ([ "Character":Str(\$assist["CharObj"]) ]);

      \$updated += ([ \$i:Str(\$assist["CharObj"]) ]);

      assist::dosetassist(\$num: \$i, \$assist: \$assist);

  \} else if (\$assist["CharObj"] == Obj(\$assist["Character"])) \{
      \$ok += (\{ \$i \});
  \} else \{
    \$odd += (\{ \$i \});
  \}
\}

EmitTo(\$actor, "The following assists had the CharObj mapping added: " + dump_value(\$added) +
               "\\n\\nThe following assists had the Character pair updated to match the CharObj: " +
               dump_value(\$updated) + "\\n\\nThe following assists need manual attention: " +
               dump_value(\$fixme) + "\\n\\nThe following assists are OK: " + dump_value(\$ok) +
               "\\n\\nThe following assists are broke for some other unknown reason: " + dump_value(\$odd));
      </Core:Property>
      <Core:Property property="merry:lib:docreatesearchdb">
         X[M] /* D=Creates the search db

    The following keys are used in the db:
      Account
      AssistText
      Character[19..]
      Notes

*/

string word, letter, *account, *assisttext, *character, *notes;
int i, sz_i, j, sz_j;
mixed *value;
object db;
mapping assist, keys, map_letter;

\{

  db         = Obj("Data:DB:assist:AssistSearchDB");
  assist     = assist::dogetassist(\$num: Int(\$num));
  account    = explode(assist["Account"], " ");;
  assisttext = explode(assist["AssistText"], " ");;
  character  = explode((contains(assist["Character"], "Marrach:players") ? assist["Character"][18..] :
               (contains(assist["Character"], "Marrach:NPCs") ? assist["Character"][13..] : "")), " ");
  notes      = explode(assist["Notes"], " ");
  keys       = ([ 0:account, 1:assisttext, 2:character, 3:notes ]);
  sz_i       = 4;

  for (i = 0; i \< sz_i; i++) \{
    value = keys[i];
    sz_j  = sizeof(value);

    if (sz_j == 0) continue;

    for (j = 0; j \< sz_j; j++) \{
      word = lower_case(value[j]);
      word = replace_strings(word, "1", "", "2", "", "3", "", "4", "", "5", "", "6", "", "7", "", "8", "", "9", "",
                                   "0", "", "`", "", "~", "", "!", "", "@", "", "#", "", "\$", "", "%", "", "^", "",
                                   "\&", "", "*", "", "(", "", ")", "", "-", "", "_", "", "=", "", "+", "", "[", "",
                                   "\{", "", "]", "", "\}", "", "\\\\", "", "\|", "", ";", "", ":", "", "\\'", "", "\\"", "",
                                   ",", "", "\<", "", ".", "", "\>", "", "/", "", "?", "", "\\n", "");

      if (strlen(word) \< 4) continue;

      letter     = word[0..0];
      map_letter = Get(db, "mapping:" + letter);
      map_letter = (map_letter ? map_letter : ([ ]));

      if (map_sizeof(map_letter) \> 30000) \{
        EmitTo(\$actor, "--[ALERT!]: mapping:" + letter + " has reached 30000 keys at task #" + Str(\$num) +
                        ". Halting at word: " + word);
        return FALSE;
      \}

      if (!get_by_str(map_letter, word)) \{
        set_by_str(map_letter, word, ([ Int(\$num):0 ]));
      \} else if (!get_by_str(map_letter, word)[Int(\$num)]) \{
          if (map_sizeof(get_by_str(map_letter, word)) \> 30000) \{
            EmitTo(\$actor, "***[ALERT!]*** mapping:" + letter + " has reached 30000 keys at task #" + Str(\$num) +
                            ". Halting at word: " + word);
            return FALSE;
          \}
        set_by_str(map_letter, word, get_by_str(map_letter, word) + ([ Int(\$num):0 ]));
      \} else \{
        continue;
      \}
      Set(db, "mapping:" + letter, map_letter);
    \}
  \}
  /*
   * Keeping track of how often the search db is updated, versus how often it is searched.
   */
  db."stats:updates" = Int(db."stats:updates") + 1;
\}
      </Core:Property>
      <Core:Property property="merry:lib:docreatesearchdb_init">
         X[M] /* D=Initializes the new search db, parsing through entire TAS db. */

\{
  \$num_i     = 1;
  \$count     = 0;
  \$total     = 0;
  \$loops     = 0;

  EmitTo(\$actor, smalltime(time()) + " [Search DB]: Started!");

  while (\$num_i \<= \$data."assist:current" \&\& !\$actor."search:stop") \{
    assist::docreatesearchdb(\$num: \$num_i);

    \$count++;
    \$num_i++;
    if (\$count == 10) \{
      \$total = \$total + \$count;
      \$delay(1.0, FALSE, "7ee3");
      \$count = 0;
      \$loops++;
    \}

    if (\$loops == 10) \{
      \$loops = 0;
      EmitTo(\$actor, smalltime(time()) + " [Search DB]: Done " + Str(\$total));
    \}
  \}

  EmitTo(\$actor, smalltime(time()) + " [Search DB]: Finished! " + Str(\$total));

\}
      </Core:Property>
      <Core:Property property="merry:lib:docreatestats">
         X[M] /* D=Sets appropriate stats

     The following arguments are required:
       \$data: The db object
       \$num: Number of the assist
       \$action: What action is calling the stat code

*/

mapping map, assist;
int total, time;

if (\$action == "claim") \{
  map = \$data."mapping:assistee:claimed";
  total = !map[\$actor."udat:name"] ? 0 : map[\$actor."udat:name"];
  total++;
  map[\$actor."udat:name"] = nil;
  map += ([ \$actor."udat:name":total ]);
  \$data."mapping:assistee:claimed" = map;
  return TRUE;
\}

if (\$action == "filed") \{
  map = \$data."mapping:general:statistics";
  total = !map["Filed"] ? 0 : map["Filed"];
  total++;
  map["Filed"] = nil;
  map += ([ "Filed":total ]);
  \$data."mapping:general:statistics" = map;
  return TRUE;
\}

if (\$action == "transfered") \{
  map = \$data."mapping:assistee:transfered";
  total = !map[\$actor."udat:name"] ? 0 : map[\$actor."udat:name"];
  total++;
  map[\$actor."udat:name"] = nil;
  map += ([ \$actor."udat:name":total ]);
  \$data."mapping:assistee:transfered" = map;
  return TRUE;
\}

if (\$action == "returned") \{
  map = \$data."mapping:assistee:returned";
  total = !map[\$actor."udat:name"] ? 0 : map[\$actor."udat:name"];
  total++;
  map[\$actor."udat:name"] = nil;
  map += ([ \$actor."udat:name":total ]);
  \$data."mapping:assistee:returned" = map;
  return TRUE;
\}

if (\$action == "closed") \{
  map = \$data."mapping:assistee:closed";
  total = !map[\$actor."udat:name"] ? 0 : map[\$actor."udat:name"];
  total++;
  map[\$actor."udat:name"] = nil;
  map += ([ \$actor."udat:name":total ]);
  \$data."mapping:assistee:closed" = map;

  map = \$data."mapping:assistee:time";
  total = !map[\$actor."udat:name"] ? 0 : map[\$actor."udat:name"];
  assist = assist::dogetassist(\$num: \$num);
  total = total + (Int(assist["TimeClosed"]) - Int(assist["TimeClaimed"]));
  map[\$actor."udat:name"] = nil;
  map += ([ \$actor."udat:name":total ]);
  \$data."mapping:assistee:time" = map;

  map = \$data."mapping:general:statistics";
  total = !map["Total"] ? 0 : map["Total"];
  assist = assist::dogetassist(\$num: \$num);
  total = total + (Int(assist["TimeClosed"]) - Int(assist["TimeClaimed"]));
  map["Total"] = nil;
  map += ([ "Total":total ]);
  \$data."mapping:general:statistics" = map;

  map = \$data."mapping:general:statistics";
  total = !map["Closed"] ? 0 : map["Closed"];
  total++;
  map["Closed"] = nil;
  map += ([ "Closed":total ]);
  \$data."mapping:general:statistics" = map;

  map = \$data."mapping:time:closed";
  assist = assist::dogetassist(\$num: \$num);
  total = Int(assist["TimeClosed"]) - Int(assist["TimeClaimed"]);
  if (total \>= 0 \&\& total \<= 1800) \{
    time = 1800;
  \}
  if (total \> 1800 \&\& total \<= 3600) \{
    time = 3600;
  \}
  if (total \> 3600 \&\& total \<= 5400) \{
    time = 5400;
  \}
  if (total \> 5400 \&\& total \<= 7200) \{
    time = 7200;
  \}
  if (total \> 7200 \&\& total \<= 10800) \{
    time = 10800;
  \}
  if (total \> 10800 \&\& total \<= 21600) \{
    time = 21600;
  \}
  if (total \> 21600 \&\& total \<= 43200) \{
    time = 43200;
  \}
  if (total \> 43200 \&\& total \<= 86400) \{
    time = 86400;
  \}
  if (total \> 86400 \&\& total \<= 172800) \{
    time = 172800;
  \}
  if (total \> 172800 \&\& total \<= 345600) \{
    time = 345600;
  \}
  if (total \> 345600 \&\& total \<= 604800) \{
    time = 604800;
  \}
  if (total \> 604800) \{
    time = 1000000;
  \}
  total = total + map[time];
  map[time] = nil;
  map += ([ time:total ]);
  \$data."mapping:time:closed" = map;
  map = \$data."mapping:time:closed:total";
  total = 1 + map[time];
  map[time] = nil;
  map += ([ time:total ]);
  \$data."mapping:time:closed:total" = map;
  return TRUE;
\}
      </Core:Property>
      <Core:Property property="merry:lib:docron">
         X[M] /* D=Runs the delay loop for the backup script. */

\$data = "Data:DB:assist:AssistGeneralDB";
\$data = Obj(\$data);

if (lower_case(\$trip) == "start") \{
  if (\$data."backup:status" == "running") \{
    EmitTo(\$actor, "Backup is already running. Cannot start twice.");
    return FALSE;
  \}
  \$msg = "6\|Backup Started by " + common::get_name(\$src: \$actor);
  ::log(\$log: \$msg);
  assist::dobackup();
  \$data."backup:status" = "running";
  \$bkupcnt = 0;
  while (\$data."backup:status" == "running") \{
    \$delay(3600, FALSE, "d1df");
    \$bkupcnt = \$bkupcnt + 3600;
    if (\$bkupcnt \>= 86400) \{
      \$bkupcnt = 0;
      assist::dobackup();
    \}
  \}
  return FALSE;
\}

if (lower_case(\$trip) == "stop") \{
  if(\$data."backup:status" == "halted") \{
    EmitTo(\$actor, "Backup is already halted. Cannot halt a second time.");
    return FALSE;
  \}
  \$emit = "6\|Backup Stopped by " + common::get_name(\$src: \$actor);
  ::log(\$log: \$emit);
  \$data."backup:status" = "halted";
  return FALSE;
\}

EmitTo(\$actor, "That is not a valid argument for backup.");
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:docurrent">
         X[M] /* D=Creates a long table of all assist info

     The following arguments are required:
       \$data: The DB object

     The following arguments are optional:
       \$key: The specific function making the call
       \$list: An array of assist numbers.
*/

int i, j;
string *queues;
mixed *content, *assists;

if (\$key == "recap") \{
  queues = (\{ "recap" \});
\} else \{
  queues = \$data."array:queues";
\}

content = (\{ (\{ "#", "Pr", "F", "N", "Time", "Account", "Character", "Queue", "Assistee", "Claimed", "Assist" \}) \});

\$total = 0;

for (i = 0; i \< sizeof(queues); i++) \{
  if (Get(\$data, "array:claimed:" + queues[i])) \{
    assists = map_indices(arr_to_set(Get(\$data, "array:claimed:" + queues[i])));
  \} else \{
    assists = \$list;
  \}

  if (assists) \{
    for (j = 0; j \< sizeof(assists); j++) \{

      \$assist = assist::dogetassist(\$num: Str(assists[j]));

      \$char = \$assist["CharObj"];

      \$line = (\{ Str(assists[j]),
                 Str(\$assist["Priority"]),
                 capitalize(\$assist["Flag"]),
                 (strlen(\$assist["Notes"]) \> 1 ? "Y" : ""),
                 short_time(Int(\$assist["TimeFiled"])) \});

    if (\$assist["Account"]) \{
      \$line += (\{ (lower_case(\$assist["Account"]) + spaces(9))[..8] \});
    \} else \{

     if (\$char \&\& \$char."skotos:creator") \{
        \$line += (\{ (\$char."skotos:creator" + spaces(9))[..8] \});
      \} else \{
        \$line += (\{ "" \});
      \}

    \}

    \$line += \$char ? (\{ common::get_name(\$src: \$char) \}) : (\{ "Unknown" \});

      \$line += (\{ capitalize(\$assist["Queue"]) \});
      /*
       * Modified line below to use common::get_name() since it totally mangled the output on objects
       * with colorizing in their names.
       * (Kalle, Feb 27, -05.)
       */
      \$line += Obj(\$assist["Assistee"]) ? (\{ common::get_name(\$src: Obj(\$assist["Assistee"])) \}) : (\{ "" \});
      \$line += \$assist["TimeClaimed"] != "" ? (\{ short_time(Int(\$assist["TimeClaimed"])),
                  (\$assist["AssistText"] + spaces(30))[..30] \}) : (\{ "", (\$assist["AssistText"] + spaces(30))[..30] \});

      content += (\{ \$line \});

      \$total++;
    \}
  \}
\}

if (\$popup) \{
  \$output = content;
  return \$output;
\}

if (\$search) \{
  \$out = ascii::table(\$content: content, \$ignoreseparator: "top bottom left right");
  return \$out;
\}

EmitTo(\$actor, PRE(ascii::table(\$content: content, \$ignoreseparator: "top bottom left right") + "\\nTotal: " + \$total));
      </Core:Property>
      <Core:Property property="merry:lib:dodiscard">
         X[M] /* D=Discards an assist with a generic message

     The following arguments are required:
       \$data: The DB object
       \$num: The assist number
*/

/* Discard Pre Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["discard-pre"] \&\& sizeof(\$triggers["discard-pre"]) \> 1) \{
     \$trig_discard_pre = \$triggers["discard-pre"];
     Call(\$trig_discard_pre[0], \$trig_discard_pre[1]);
  \}
\}

/* ... */

assist::doclaim(\$data: \$data, \$num: \$num, \$cmd: \$cmd, \$silent: "true");

if (\$ok) \{
\$delay(2.0, FALSE, "c329");

/* Discard Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["discard"] \&\& sizeof(\$triggers["discard"]) \> 1) \{
     \$trig_discard = \$triggers["discard"];
     Call(\$trig_discard[0], \$trig_discard[1]);
  \}
\}

/* ... */

assist::dodone(\$data: \$data, \$msg: "Discarded");
\}

/* Discard Post Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["discard-post"] \&\& sizeof(\$triggers["discard-post"]) \> 1) \{
     \$trig_discard_post = \$triggers["discard-post"];
     Call(\$trig_discard_post[0], \$trig_discard_post[1]);
  \}
\}

/* ... */

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dodone">
         X[M] /* D=Moves an assist from the current queue to the finished queue.

     The following arguments are required:
       \$data: The db object
       \$msg: The done message

     The following arguments are optional:
       \$silent: If true, do not send the chatline message

   Changelog at bottom of page.
*/

int q;
string num;
mapping assistees, assist;

/* Done Pre Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["done-pre"] \&\& sizeof(\$triggers["done-pre"]) \> 1) \{
     \$trig_done_pre = \$triggers["done-pre"];
     Call(\$trig_done_pre[0], \$trig_done_pre[1]);
  \}
\}

/* ... */


assistees = \$data."mapping:assistee";

if (!member(\$actor."udat:name", map_indices(assistees))) \{
  EmitTo(\$actor, "You do not have a task claimed. Perhaps you are looking for \\"" + \$cmd +
                 " discard (task number) [('optional message)]\\"?");
  return FALSE;
\}

num = assistees[\$actor."udat:name"];
assist = assist::dogetassist(\$num: Str(num));

assist["TimeClosed"] = nil;
assist += ([ "TimeClosed":Str(time()) ]);

\$note_msg = "\<*\> " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + spaces(1) + "(" + short_time(time()) + "): " + \$msg;

\$notes_msg = \$note_msg + "\\n\\n";

\$notes = assist["Notes"] + \$notes_msg;

assist["Notes"] = nil;
assist += ([ "Notes":\$notes ]);

\$body = assist::docharobj(\$num: num);

assist::dosetassist(\$num: Str(num), \$assist: assist);

\$data."mapping:assistee"[\$actor."udat:name"] = nil;

\$queue = \$data."mapping:assists:open"[Str(num)];

\$data."mapping:assists:open"[Str(num)] = nil;

Set(\$data, "array:claimed:" + \$queue, Get(\$data, "array:claimed:" + \$queue) - (\{ Int(num) \}) );

if (assist["Assigned"] \&\& assist["Assigned"] != "") \{
  \$assigned = assist["Assigned"];
  \$assigned."array:assists:assigned" -= (\{ Str(num) \});
\}

if (assist["AlertShift"]) \{
  \$udat_obj = Call(\$\{UserAPI:UDatD\}, "query_udat", \$name: assist["AlertShift"]);
\} else \{
  \$udat_obj = Call(\$\{UserAPI:UDatD\}, "query_udat", \$name: assist["Account"]);
\}

if (\$body \&\& \$body."array:assists") \{
  if (\$body."array:assists") \{
    \$allassists = \$body."array:assists";
    for (q = 0; q \< sizeof(\$allassists); q++) \{
      \$whichassist = \$allassists[q];
      if (!member(Str(\$whichassist), map_indices(\$data."mapping:assists:open"))) \{
        \$body."array:assists" -= (\{ Int(\$whichassist) \});
      \}
    \}
  \}
\} else \{
  if (\$udat_obj \&\& \$udat_obj."array:assists") \{
    \$allassists = \$udat_obj."array:assists";
    for (q = 0; q \< sizeof(\$allassists); q++) \{
      \$whichassist = \$allassists[q];
      if (!member(Str(\$whichassist), map_indices(\$data."mapping:assists:open"))) \{
        \$udat_obj."array:assists" -= (\{ Int(\$whichassist) \});
      \}
    \}
  \}
\}


\$data."task:lastclosed" = num;

assist::docreatestats(\$data: \$data, \$num: num, \$action: "closed");

/* Done Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["done"] \&\& sizeof(\$triggers["done"]) \> 1) \{
     \$trig_done = \$triggers["done"];
     Call(\$trig_done[0], \$trig_done[1]);
  \}
\}

/* ... */

if (!\$silent) \{
  \$alert = smalltime(time()) + spaces(1) + \$tas + " \\"\<#" + num + "/" + capitalize(assist["Queue"]) +
           "\> closed by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ": " + \$msg + "\\"";

  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: assist["Queue"], \$exclude: (\{ \$actor \}));

  EmitTo(\$actor, TAG(\$alert, "assist-alert"));
\}


\$r5 = lower_case(assist["Queue"]);
if ((\$r5 == "new" \|\| \$r5 == "guides" \|\| (\$data."mapping:subqueues"[\$r5] ?
    lower_case(\$data."mapping:subqueues"[\$r5]) : "") == "guides") \&\&
    member((\$command ? lower_case(\$command) : ""), (\{ "done", "finish", "finished" \}))) \{
  if (\$body \&\& \$body."skotos:creator") \{
    Call(\$\{SkotOS:Assistd\}, "add_note", \$user: \$body."skotos:creator", \$from: \$actor."udat:name", \$message: "\<" +
         capitalize(assist["Queue"]) + "/#" + Str(num) + "\>");
  \}
\}

/* Done Post Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["done-post"] \&\& sizeof(\$triggers["done-post"]) \> 1) \{
     \$trig_done_post = \$triggers["done-post"];
     Call(\$trig_done_post[0], \$trig_done_post[1]);
  \}
\}

/*
 * CHANGELOG:
 * Aug 19, 2005 \<Zwoc\>: Put in "\$udat_obj \&\&" in check on \$udat_obj."array:assists". The code would crash if the account had been purged.
 */
      </Core:Property>
      <Core:Property property="merry:lib:dofileassist">
         X[M] /* D=Creates a new filed assist

     The following arguments must be passed:
       \$char: This is a string of the woename
       \$queue: What queue does this go into
       \$assisttext: The text of the assist
       \$flag: If none is supplied, default to None
       \$log: What log is this? Assist, Bug, Typo, etc?

  [See bottom for changelog.]
*/

string num, flag;
mapping assist;

/*
if (\$actor."skotos:creator" != "kargh") \{
EmitTo(\$actor, "TAS is currently offline for brief maintainence. Please refile shortly.");
return FALSE;
\}
*/

/* File Pre Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["file-pre"] \&\& sizeof(\$triggers["file-pre"]) \> 1) \{
     \$trig_file_pre = \$triggers["file-pre"];
     Call(\$trig_file_pre[0], \$trig_file_pre[1]);
  \}
\}

/* ... */

flag = !\$flag ? "" : \$flag;

if (member((\$filter = lower_case(\$actor."udat:name" + "@" + \$queue + "@" + ((\$r1 = \$actor."theatre:id") ?
           lower_case(\$r1) : "marrach"))), map_indices(\$data."mapping:queues:forward"))) \{
  \$queue = \$data."mapping:queues:forward"[\$filter];
\} else if (member((\$filter = lower_case(\$queue + "@" + ((\$r1 = \$actor."theatre:id") ?
           lower_case(\$r1) : "marrach"))), map_indices(\$data."mapping:queues:forward"))) \{
    \$queue = \$data."mapping:queues:forward"[\$filter];
\}

if (member((\$filter = lower_case(\$queue + "@" + ((\$r1 = \$actor."theatre:id") ? lower_case(\$r1) : "marrach"))),
    map_indices(\$data."mapping:queues:forward"))) \{
  \$queue = \$data."mapping:queues:forward"[\$filter];
\}

if (!member(\$queue, \$data."array:queues")) \{

  EmitTo(\$actor, "There was a problem with the queue forwarding setup. Please consult a coder and " +
                 "report the issue. Your assist shall be sent to the default queue with an attached " +
                 "note and an alert shall be broadcast.");

  \$note = "!TAS! (" + short_time(time()) + "): There is an issue the mapping:queues:forward setup. No such queue: " +
                  upper_case(\$queue) + ". Please fix this ASAP!\\n\\n";

  \$alert = smalltime(time()) + spaces(1) + \$log + " \\"!TAS ERROR! The mapping:queues:forward is setup incorrectly. " +
           "Unable to locate the queue " + upper_case(\$queue) + ". Please fix immediately!\\"";

  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "taserror");

  \$queue = "new";
\}

assist = ([ "TimeFiled":Str(time()),
            "Character":\$char,
            "CharObj":\$actor,
            "Account":Obj(\$char)."udat:name" ? Obj(\$char)."udat:name" : Obj(\$char)."skotos:creator",
            "Queue":\$queue,
            "Assistee":"",
            "TimeClaimed":"",
            "TimeClosed":"",
            "AssistText":\$assisttext,
            "Notes":(!\$note ? "" : \$note),
            "Theatre":((\$r1 = \$actor."theatre:id") ? \$r1 : "marrach"),
            "Server":((\$r1 = \$\{Data:info\}.id) ? \$r1 : "unknown"),
            "Flag":flag,
            "Assigned":"",
            "Priority":10,
            "Environment":name(\$actor."base:environment"),
            "Links":(\{ \}) ]);



num = Str(\$data."Assist:Next");
\$num = num;

assist::dosetassist(\$num: num, \$assist: assist);

\$data."Assist:Next"++;
\$data."Assist:Current"++;

Set(\$data, "array:open:" + \$queue, Get(\$data, "array:open:" + \$queue) + (\{ \$data."Assist:Current" \}));

\$data."mapping:assists:open" += ([ Str(\$data."Assist:Current"):\$queue ]);

\$udat_obj = \$actor."udat:object";

if (!\$udat_obj."array:assists") \{
  \$udat_obj."array:assists" = (\{ \$data."assist:current" \});
\} else \{
  \$udat_obj."array:assists" += (\{ \$data."assist:current" \});
\}

assist::docreatestats(\$data: \$data, \$action: "filed");


if (member(\$queue, map_indices(\$data."mapping:queues:email")) \&\&
    !member(\$queue, map_indices(\$data."mapping:queues:servertransfer"))) \{
  assist::dosendemail(\$data: \$data, \$num: \$data."Assist:Current", \$queue: \$queue);
\}

if (member(\$queue, map_indices(\$data."mapping:queues:servertransfer"))) \{
  \$server = \$data."mapping:queues:servertransfer"[\$queue];
  \$id     = assist["Theatre"] + "@" + assist["Server"] + "-" + Str(num) + "!" + \$server;
  \$notes  = assist["Notes"];
  assist["Notes"] = nil;
  \$note   = "!TAS! (" + short_time(time()) + "): This task has been transferred to server '" +
            capitalize(\$server) + "' with ID '" + \$id + "'.\\n\\n";
  \$note  += "!TAS! (" + short_time(time()) + "): Original Filer: " + Describe(\$actor) + " " +
             dump_value(\$actor) + "\\n\\n";
  if (strlen(\$notes) \< 1) \{
    assist += ([ "Notes":\$note ]);
  \} else \{
    \$note = \$notes + \$note;
    assist += ([ "Notes":\$note ]);
  \}
  assist::dosetassist(\$num: num, \$assist: assist);
  Call(\$\{SkotOS:Assistd\}, "transfer_data", \$server: \$server, \$id: \$id, \$transfer_data: assist);
  \$trans = "[Transferred to server '" + capitalize(\$server) + "']";

  assist::doclaim(\$data: \$data, \$num: num, \$cmd: \$cmd, \$silent: "true");
  if (\$ok) \{
    assist::dodone(\$data: \$data, \$msg: "Transfer Close", \$silent: "true");
  \}
\}


/* File Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["file"] \&\& sizeof(\$triggers["file"]) \> 1) \{
     \$trig_file = \$triggers["file"];
     Call(\$trig_file[0], \$trig_file[1]);
  \}
\}

/* ... */



\$actor_alert = smalltime(time()) + spaces(1) + \$log + " \\"\<#" + \$data."Assist:Current" + "/" +
               capitalize(\$queue) + "\> filed by "  + common::get_name(\$src: \$actor) + "[" +
               \$actor."udat:name" + "]: " + \$assisttext + (\$success == 1 ? " [Email alert sent]" : "") +
               (\$trans ? " " + \$trans + "\\"" : "\\"");

\$alert = smalltime(time()) + spaces(1) + \$log + " \\"\<" + UnSAM(ParseXML("\<acmd tag='command' cmd='!tas info " +
         \$data."Assist:Current" + "'\>#" + \$data."Assist:Current" + "\</acmd\>")) + "/" + capitalize(\$queue) + "\> filed by "  +
         common::get_name(\$src: \$actor) + "[" + \$actor."udat:name" + "]: " + \$assisttext +
         (\$success == 1 ? " [Email alert sent]" : "") + (\$trans ? " " + \$trans + "\\"" : "\\"");

if (!\$syslvl) \$syslvl = "1";

if ((\$imperative != "task" \|\| \$loud == 1) \&\& !member(\$queue, \$data."array:queues:locked")) \{
  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: \$queue, \$exclude: (\{ \$actor \}));
\}

if (\$actor."udat:host" \|\| \$actor."udat:guide")
    EmitTo(\$actor, TAG(\$alert + "\\n\\n", "assist-alert"));
else
    EmitTo(\$actor, TAG(\$actor_alert + "\\n\\n", "assist-alert"));

if (!\$silence \|\| !member(\$imperative, (\{ "task", "social", "@social", "+suspend", "@rumor", "bug", "@bug", "typo",
                                         "@typo", "idea", "@idea" \}))) \{

  EmitTo(\$actor, "Your message has been sent. If your issue requires the assistance of staff, you will be " +
                 "contacted shortly by a StoryHost or StoryGuide with a \\'@page\\'. Please use the \\'@page\\' " +
                 "command to respond to whomever contacts you. A proper example of the usage of page " +
                 "is \\'@page (name) \\"message\\'.\\n\\n");
\}

/* File Post Trigger */

if (\$data."mapping:queues:trigger"[\$queue]) \{
  \$triggers = \$data."mapping:queues:trigger"[\$queue];
  if (\$triggers["file-post"] \&\& sizeof(\$triggers["file-post"]) \> 1) \{
     \$trig_file_post = \$triggers["file-post"];
     Call(\$trig_file_post[0], \$trig_file_post[1]);
  \}
\}

/* ... */


return FALSE;

/*
 * CHANGELOG:

 Tue Dec 14, 2004 (Kalle): Fixed typoed 'transferred' in a few places.
 Sun Jul 10, 2005 (Kalle): Updated to include \<acmd/\> tags.

 */
      </Core:Property>
      <Core:Property property="merry:lib:doflag">
         X[M] /* D=Adds a flag to an assist

     The following arguments are required:
       \$data: The DB object
       \$num: Number of the assist
       \$flag: The flag
*/

string flag, letter;
mapping flags, assist;


flag = lower_case(\$flag);
flags = \$data."mapping:flags";


if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if (!member(flag, map_indices(flags))) \{
  EmitTo(\$actor, "That is an invalid (" + flag + ") flag.");
  return FALSE;
\}

assist = assist::dogetassist(\$num: \$num);

assist["Flag"] = nil;

letter = flags[flag] == "n" ? "" : flags[flag];

assist += ([ "Flag":letter ]);

assist::dosetassist(\$num: \$num, \$assist: assist);

\$alert = smalltime(time()) + spaces(1) + \$tas + spaces(1) + " \\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) +
         " has set the flag for task #" + \$num + " to " + capitalize(flag) + ".\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "misc", \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doflaglist">
         X[M] /* D=List available flags

     The following arguments are required:
       \$data: The db object

*/

string *str, *long, *short;
mapping flags;



flags = \$data."mapping:flags";
str = (\{ (\{ "Flag", "Letter" \}) \});

long = map_indices(flags);

for (\$i = 0; \$i \< sizeof(long); \$i++) \{
    str += (\{ (\{ capitalize(long[\$i]), capitalize(flags[long[\$i]]) \}) \});
\}

EmitTo(\$actor, PRE(ascii::table(\$content: str, \$ignoreseparator: "top bottom left right")));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dofocus">
         X[M] /* D=Sets your queue focus for subqueues

    The following arguments are required:
      \$focus - The queue to change focus to

Check to see if focus is general
Check to see if focus is a queue that has sub queues
Set

*/

\$focus = lower_case(\$focus);

if (\$focus == "general") \{
  \$actor."tas:focus" = "general";
  EmitTo(\$actor, "TAS focus switched to general.");
  return FALSE;
\}

if (!Get(\$data, "array:subqueues:" + \$focus) \|\| sizeof(Get(\$data, "array:subqueues:" + \$focus)) == 0) \{
  EmitTo(\$actor, "That is an invalid queue to switch focus to! It either does not exist or it does not have any subqueues.");
  return FALSE;
\}

\$actor."tas:focus" = \$focus;

EmitTo(\$actor, "TAS focus switched to " + capitalize(\$focus) + " parent queue.");

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doforget">
         X[M] /* D=Removes a watched assist.

     The following arguments are required:
       \$data: The DB object
       \$num: The assist number

*/

if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if (!\$actor."mapping:assists:watch") \{
  EmitTo(\$actor, "You are not watching any tasks at present. Cannot remove.");
  return FALSE;
\}

if (!member(\$num, map_indices(\$actor."mapping:assists:watch"))) \{
  EmitTo(\$actor, "You are not watching that task.");
  return FALSE;
\}

\$actor."mapping:assists:watch"[\$num] = nil;
EmitTo(\$actor, "Task #" + \$num + " removed from your watch list.");
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dogetassist">
         X[M] /* D=Gets the assist from the appropriate object and returns an array.

     This function requires the following arguments to be passed:
        \$num: The number of the assist

*/


int db;
mixed obj;
mapping assist;

\$num = Str(\$num);

if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  return nil;
\}

db = Int(\$num) / 1000;
obj = "Data:DB:assist:AssistDB" + Str(db);

obj = Obj(obj);

if (!obj) return nil;

assist = Get(obj, "assist:" + \$num);

return assist;
      </Core:Property>
      <Core:Property property="merry:lib:dohelp">
         X[M] /* D=Lists help or specific help

     The following arguments are required:.
       \$command: The command calling, +assist or !assist
       \$help: The specific help being called
*/


string str, cmd;

cmd = \$command;

\$actor = Obj(\$actor);

str = "";

if (member(\$help, (\{ "help", "all" \}))) \{
str += "Help Help\\n---------\\n\\n";
str += cmd + " help help\\n" + spaces(5) + "Lists this help\\n";
str += cmd + " help basic\\n" + spaces(5) + "Lists help on basic TAS commands\\n";
str += cmd + " help task\\n" + spaces(5) + "Lists help on task manipulation commands\\n";
str += cmd + " help list\\n" + spaces(5) + "Lists help on list manipulation commands\\n";
str += cmd + " help queue\\n" + spaces(5) + "Lists help on queue manipulation commands\\n";
str += cmd + " help login\\n" + spaces(5) + "Lists help on login commands\\n";
str += cmd + " help misc\\n" + spaces(5) + "Lists help on misc commands\\n";
str += cmd + " help chat\\n" + spaces(5) + "Lists help on chat commands\\n";
str += cmd + " help personal\\n" + spaces(5) + "Lists help on personal queues\\n";
str += cmd + " help commands\\n" + spaces(5) + "Lists all commands available to TAS\\n";
str += cmd + " help subqueues\\n" + spaces(5) + "Lists help for setting up and using subqueues\\n";
str += cmd + " help all\\n" + spaces(5) + "Lists all help for all help topics\\n\\n";
\}

if (member(\$help, (\{ "basic", "basics", "quick", "brief", "short", "all" \}))) \{
str += "Basic Help\\n----------\\n\\n";
str += cmd + "\\n" + spaces(5) + "Lists the open tasks in the New queue\\n";
str += cmd + " (task number)\\n" + spaces(5) + "Claims task\\n";
str += cmd + " (queue name) [(count)]\\n" + spaces(5) + "Lists open tasks in specified queue name\\n";
str += cmd + " reverse (queue name) [(count)]\\n" + spaces(5) + "Lists open tasks in specified queue but in reverse order\\n";
str += cmd + " (finish\|done) \\'(message)\\n" + spaces(5) + "Closes your claimed task with (message)\\n";
str += cmd + " (que\|queue\|queues)\\n" + spaces(5) + "Lists all public queues\\n";
str += cmd + " transfer (queue)\\n" + spaces(5) + "Moves your claimed task to specified queue\\n";
str += cmd + " transfer (task number/s) (queue)\\n" + spaces(5) + "Moves specified task number to specified queue\\n";
str += cmd + " info (task number)\\n" + spaces(5) + "Displays long information for specified task number\\n";
str += cmd + " current\\n" + spaces(5) + "Displays information on your claimed tasks\\n";
str += cmd + " claimed\\n" + spaces(5) + "Lists all claimed tasks\\n";
str += cmd + " showall (queue name)\\n" + spaces(5) + "Shows all information for all open tasks in specified queue\\n";
str += cmd + " ugly (queue)\\n" + spaces(5) + "Similar to 'queue' command but shows entire task message\\n";
str += cmd + " open\\n" + spaces(5) + "Lists all open tasks in all queues\\n";
str += cmd + " online [(queue\|all)]\\n" + spaces(5) + "Lists players online with open tasks. Defaults 'New' queue if no queue name specified\\n";
str += cmd + " recap\\n" + spaces(5) + "Lists all tasks from the previous 24 hours\\n";
str += cmd + " return\\n" + spaces(5) + "Returns current claimed task to its queue\\n";
str += cmd + " note \\'(note)\\n" + spaces(5) + "Adds specified note to your current claimed assist\\n";
str += cmd + " note (task number) \\'(note)\\n" + spaces(5) + "Adds specifed note to specifed task number\\n";
str += cmd + " shift (task number) (character)\\n" + spaces(5) + "Shifts login alert status to character specified\\n\\n";
\}

if (member(\$help, (\{ "task", "tasks", "assist", "assists", "all" \}))) \{
str += "Task Manipulation Help\\n----------------------\\n\\n";
str += cmd + " (task number)\\n" + spaces(5) + "Claims task\\n";
str += cmd + " (finish\|done) \\'(message)\\n" + spaces(5) + "Closes your claimed task with (message)\\n";
str += cmd + " discard #[(...#)]\\n" + spaces(5) + "Generic closure of tasks, can close multiple at one time\\n";
str += cmd + " transfer (queue)\\n" + spaces(5) + "Moves your claimed task to specified queue\\n";
str += cmd + " transfer (task number/s) (queue)\\n" + spaces(5) + "Moves specified task number to specified queue\\n";
str += cmd + " retrieve (task number)\\n" + spaces(5) + "Returns specified closed task number to the default queue\\n";
str += cmd + " return\\n" + spaces(5) + "Returns current claimed task to its queue\\n";
str += cmd + " link (task number one) (task number two)\\n" + spaces(5) + "Links specified task numbers to each other\\n";
str += cmd + " flags\\n" + spaces(5) + "Lists current defined flags\\n";
str += cmd + " flag (task number) (flag)\\n" + spaces(5) + "Flags specified task with specifed flag\\n";
str += cmd + " note \\'(note)\\n" + spaces(5) + "Adds specified note to your current claimed assist\\n";
str += cmd + " note (task number) \\'(note)\\n" + spaces(5) + "Adds specifed note to specifed task number\\n";
str += cmd + " attach (task number)\\n" + spaces(5) + "Opens popup so you can attach multi-line note\\n";
str += cmd + " priority (task number) (priority number)\\n" + spaces(5) + "Sets specifed tasks priority to specified priority\\n";
str += cmd + " assign\\n" + spaces(5) + "Lists any tasks that have been assigned to you\\n";
str += cmd + " assign (task number) (player)\\n" + spaces(5) + "Assigns specified task number to specified player\\n";
str += cmd + " shift (task number) (character)\\n" + spaces(5) + "Shifts login alert status to character specified\\n\\n";
\}

if (member(\$help, (\{ "list", "lists", "all" \}))) \{
str += "List Manipulation Help\\n----------------------\\n\\n";
str += cmd + " (que\|queue\|queues)\\n" + spaces(5) + "Lists all public queues\\n";
str += cmd + " all\\n" + spaces(5) + "Lists all queues, public and private\\n";
str += cmd + " (queue name) [(count)]\\n" + spaces(5) + "Lists open tasks in specified queue name\\n";
str += cmd + " reverse (queue name) [(count)]\\n" + spaces(5) + "Lists opent asks in specified queue, but in reverse order\\n";
str += cmd + " unassigned (queue name) [(count)]\\n" + spaces(5) + "Lists all unassigned tasks in specified queue name\\n";
str += cmd + " me\\n" + spaces(5) + "Lists open tasks for all queues that you are monitoring at login\\n";
str += cmd + " current\\n" + spaces(5) + "Displays information on your claimed tasks\\n";
str += cmd + " claimed\\n" + spaces(5) + "Lists all claimed tasks\\n";
str += cmd + " open\\n" + spaces(5) + "Lists all open tasks in all queues\\n";
str += cmd + " online [(queue\|all)]\\n" + spaces(5) + "Lists players online with open tasks. Defaults 'New' queue if no queue name specified\\n";
str += cmd + " showall (queue name)\\n" + spaces(5) + "Shows all information for all open tasks in specified queue\\n";
str += cmd + " showclosed (queue/character) [(count)]\\n" + spaces(5) + "Shows all closed tasks for specified queue\\n";
str += cmd + " shortclosed (queue/character) [(count)]\\n" + spaces(5) + "Shows all closed tasks for specified queue or character in short format\\n";
str += cmd + " ugly (queue)\\n" + spaces(5) + "Similar to 'queue' command but shows entire task message\\n";
str += cmd + " search (term)\\n" + spaces(5) + "Searches all tasks for specified term\\n";
str += cmd + " abort\\n" + spaces(5) + "Aborts current search\\n";
str += cmd + " list (player)\\n" + spaces(5) + "Lists all open tasks for specified player\\n";
str += cmd + " recap\\n" + spaces(5) + "Lists all tasks from the previous 24 hours\\n";
str += cmd + " info (task number)\\n" + spaces(5) + "Displays long information for specified task number\\n";
str += cmd + " prefer (queue name\|none)\\n" + spaces(5) + "Sets your preferred queue for listing with " + cmd + ". Set to none to remove.\\n\\n";
\}

if (member(\$help, (\{ "queue", "queues", "que", "all" \}))) \{
str += "Queue Manipulation Help\\n-----------------------\\n\\n";
str += cmd + " add (queue name)\\n" + spaces(5) + "Adds a new queue with specified name\\n";
str += cmd + " remove (queue name)\\n" + spaces(5) + "Removes specified queue name\\n";
str += cmd + " rename (queue name) (new queue name)\\n" + spaces(5) + "Renames current queue name with new queue name\\n";
str += cmd + " public (queue name)\\n" + spaces(5) + "Sets specified queue as public\\n";
str += cmd + " private (queue name)\\n" + spaces(5) + "Sets specified queue as private\\n";
str += cmd + " desc (queue name) \\'(queue description)\\n" + spaces(5) + "Adds provided description to specified queue\\n";
str += cmd + " associate (queue name)\\n" + spaces(5) + "Associates you with specified queue for task command. Use NONE to remove\\n";
str += cmd + " lock (queue name)\\n" + spaces(5) + "Locks a queue so that only SHs may access and manipulate it\\n";
str += cmd + " unlock (queue name)\\n" + spaces(5) + "Unlocks a queue so that anyone may access and manipulate it\\n\\n";
\}

if (member(\$help, (\{ "login", "logon", "all" \}))) \{
str += "Login Help\\n-----------\\n\\n";
str += cmd + " login\\n" + spaces(5) + "Lists queues you are monitoring at login\\n";
str += cmd + " login (queue name)\\n" + spaces(5) + "Adds or removes specified queue from your monitor list\\n";
str += cmd + " watch\\n" + spaces(5) + "Lists what tasks you are watching at login\\n";
str += cmd + " watch (task number)\\n" + spaces(5) + "Adds specified task number to your watch list\\n";
str += cmd + " forget (task number)\\n" + spaces(5) + "Removes specifed task number from your watch list\\n\\n";
\}

if (member(\$help, (\{ "misc", "all" \}))) \{
str += "Misc Help\\n---------\\n\\n";

str += cmd + " page (task number) \\'(page message)\\n" + spaces(5) + "Sends and offline page to the player that filed the task you supplied.\\n";
str += cmd + " prefer (queue name\|none)\\n" + spaces(5) + "Sets your preferred queue for listing with " + cmd + ". Set to none to remove.\\n";
str += cmd + " stats\\n" + spaces(5) + "Displays TAS statistics\\n";
str += cmd + " queuestats [(queue name)]\\n" + spaces(5) + "Displays statistics all queues or specified queue\\n";
str += cmd + " twiki (queue name)\\n" + spaces(5) + "Popup with twiki formatted code for easy copy and paste into twiki\\n";
str += cmd + " backup [(stop\|start)]\\n" + spaces(5) + "Stops, starts or forces a backup of the task databases.\\n";
str += cmd + " initialize\\n" + spaces(5) + "Initializes a new task database system. Destroys current databases. Disabled by default\\n\\n";
\}

if (member(\$help, (\{ "chat", "chats", "chatline", "all" \}))) \{
str += "Chatline Help\\n-------------\\n\\n";
str += cmd + " \\"on\\n" + spaces(5) + "Start receiving and listening to the TAS chatline\\n";
str += cmd + " \\"off\\n" + spaces(5) + "Stop receiving and listening to the TAS chatline\\n";
str += cmd + " \\"(text)\\n" + spaces(5) + "Send specified message to the TAS chatline\\n";
str += cmd + " \\":(emote)\\n" + spaces(5) + "Send specified emote to the TAS chatline\\n";
str += cmd + " who\\n" + spaces(5) + "Lists who is listening to the TAS chatline\\n";
str += cmd + " recall\\n" + spaces(5) + "Lists the last few chat messages and tasks from the TAS chatline\\n";
str += cmd + " secure\\n" + spaces(5) + "Sets preferred chatname from the body you are in for the TAS chatline\\n";
str += cmd + " hide (queue name\|misc)\\n" + spaces(5) + "Hides TAS chatline output of specified type\\n";
str += cmd + " hide\\n" + spaces(5) + "Shows you what queues you are hiding.\\n";
str += cmd + " show (queue name\|misc)\\n" + spaces(5) + "Shows TAS chatline output of specified type. All types are shown by default.\\n\\n";
\}

if (member(\$help, (\{ "person", "personal", "all" \}))) \{
str += "Personal Task Queue\\n-------------------\\n\\n";
str += "Personal task queues are there for your ease of use in the TAS system.\\n";
str += "They can be setup so that any \\'task\\' that you file goes directly into your\\n";
str += "queue. They are also a convenient place for other staff to transfer tasks\\n";
str += "that pertain to you or your area of interest.\\n\\n";
str += "Personal task queues function in the same manner as other queues, only\\n";
str += "they are typically set as private queues and not displayed on the standard\\n";
str += "list of queues. To setup a personal task queue, follow these simple\\n";
str += "instructions:\\n\\n";
str += cmd + " add (queue name)\\n" + spaces(5) + "Creates your queue\\n";
str += cmd + " desc (queue) \\'(description of queue)\\n" + spaces(5) + "Adds a description to your queue\\n";
str += cmd + " private (queue name)\\n" + spaces(5) + "Sets your task queue as a private queue\\n";
str += cmd + " associate (queue name)\\n" + spaces(5) + "Associates you with your queue\\n\\n";
str += "To note, that while filing tasks into your personal queue via the \\'task\\' command\\n";
str += "is silent, manipulation of those tasks is not. Closing, transfering, noting, etc.\\n";
str += "will be announced to everyone who is listening. This is done purposely to help\\n";
str += "with the flow of communication.\\n\\n";
\}

if (member(\$help, (\{ "cmd", "commands", "command", "all" \}))) \{
\$pref = (cmd[0..0] == "+" ? "+" : "!");
str += "Additional TAS Commands\\n-----------------------\\n\\n";
str += \$pref + "tas\\n" + spaces(5) + "The basic command for using the TAS system\\n";
str += \$pref + "assist\\n" + spaces(5) + "For backwards compatiblity. Another basic command for using the TAS system\\n";
str += \$pref + "bugs\\n" + spaces(5) + "Shortcut: Lists the tasks in the \\'Bugs\\' queue\\n";
str += \$pref + "ideas\\n" + spaces(5) + "Shortcut: Lists the tasks in the \\'Ideas\\' queue\\n";
str += \$pref + "typos\\n" + spaces(5) + "Shortcut: Lists the tasks in the \\'Typos\\' queue\\n";
str += "task \\'(task)\\n" + spaces(5) + "Files a task directly into your task queue\\n";
str += spaces(5) + "Otherwise into the generic \\'Task\\' queue\\n";
str += "task (queue) \\'(task)\\n" + spaces(5) + "Files task into specified queue\\n\\n";
\}

if (member(\$help, (\{ "subqueue", "subqueues", "sub", "all" \}))) \{
str += "TAS SubQueues\\n-------------\\n\\n";
str += "SubQueues are a way of organizing the evergrowing list of personal\\n";
str += "task queues and other queues that that are closely related to the\\n";
str += "parent queue.\\n\\n";
str += "SubQueues are not listed in the complete list of queues as they are\\n";
str += "members of other queues but they are still listed in the main list\\n";
str += "of queues if they are not identified as a private queue.\\n\\n";
str += "To use SubQueues, follow the simple steps below:\\n\\n";
str += cmd + " focus (queue)\\n" + spaces(5) + "Sets your focus group\\n";
str += cmd + " focus general\\n" + spaces(5) + "Sets your focus back to the general queue list\\n";
str += cmd + " slide (queue) (parent queue)\\n" + spaces(5) + "Moves (queue) into (parent queue) as a subqueue\\n";
str += cmd + " slide (queue) general\\n" + spaces(5) + "Moves (queue) back into the General subqueue\\n\\n";
str += "When you set your focus group and you list the queues, you will list\\n";
str += "the subqueues of that group. Queues that have subqueues are listed\\n";
str += "on the queue list with a * in the G column.\\n\\n";
\}

if (strlen(str) \< 1) \{
  str = "I am unable to find " + cmd + " help for \\"" + \$help + "\\".";
  EmitTo(\$actor, PRE(str));
  return FALSE;
\}

if (\$popup) \{
  \$output = str;
  return \$output;
\}

str += "Also See: " + cmd + " help (help\|basic\|task\|list\|queue\|login\|misc\|chat\|personal\|commands\|subqueues\|all)\\n";

EmitTo(\$actor, PRE(str));
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doinfo">
         X[M] /* D=Lists all the info for an assist.

     The following arguments are required:
       \$num:    Number of the assist in question
       \$nocont: If set (TRUE), the cont feature is not used.

   Changelog at bottom of this page.
*/

string str, line;
mapping assist;
int i, z;

\$num = Str(\$num);

if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if (Int(\$num) \> \$data."assist:current" \|\| Int(\$num) == 0) \{
  EmitTo(\$actor, "I am unable to find task #" + \$num + " in the task database.");
  return FALSE;
\}

assist = assist::dogetassist(\$num: \$num);

if (member(assist["Queue"], \$data."array:queues:locked") \&\& \$actor."udat:host" == 0) \{
  EmitTo(\$actor, "That task is in a locked queue. You may not see the information.");
  return FALSE;
\}

line = "---------------------------------------------------------------------------";

str = pad_right("Task #" + \$num, 19) + pad_right("Server: " + capitalize(assist["Server"]), 19) +
      pad_right("Theatre: " + capitalize(assist["Theatre"]), 19) + pad_left("Priority: " +
      Str(assist["Priority"]), 18) + "\\n" + line + "\\n";

\$char = assist::docharobj(\$num: \$num);

if (assist["Account"]) \{
  str += pad_left("Account: ", 13) + (lower_case(assist["Account"]) + spaces(35))[..30];
\} else \{
  if (\$char \&\& \$char."skotos:creator") \{
    str+= pad_left("Account: ", 13) + (lower_case(\$char."skotos:creator") + spaces(35))[..30];
  \} else \{
    str += pad_left("Account: ", 13) + ("Unknown" + spaces(35))[..30];
  \}
\}

str += "Flags: " + capitalize(assist["Flag"]) + "\\n";

str += \$char ? pad_left("Character: ", 13) + (Describe(\$char) + spaces(35))[..30] : pad_left("Character: ", 13) +
       ("Body Slain: (" + assist["Character"] + ")" + spaces(35))[..30];

str += "Queue: " + capitalize(assist["Queue"]) + "\\n";

str += pad_left("Date Filed: ", 13) + (ctime(Int(assist["TimeFiled"])) + spaces(30))[..27];

str += "Revision: " + Str(assist["Rev"]) + "\\n";

str += pad_left("Last Rev: ", 13) + ctime(Int(assist["RevTime"])) + "\\n";

str += (assist["Environment"] ? pad_left("Environment: ", 13) + dump_value(assist["Environment"]) + (\$actor \&\& \$actor."udat:host" ? " " + LINK("[Goto]", "+goto " + Str(assist["Environment"]), "command") + " - " + LINK("[Inv]", "+inv " + Str(assist["Environment"]), "command") : "") + "\\n\\n" : "\\n");

if (assist["AlertShift"] \&\& assist["AlertShift"] != "") \{
  str += pad_left("Alert Shift: ", 13) + assist["AlertShift"] + "\\n\\n";
\}

\$task_is_claimed = !Obj(assist["Assistee"]) \&\& !strlen(assist["TimeClaimed"]);
if (\$task_is_claimed) \{
  /* The task was not claimed so we can add a "Claim this task!" link. */
  str += "Assisted By: **OPEN**                 " + UnSAM(ParseXML("\<acmd tag='command' cmd='!tas " +
         \$num + "'\>You can claim this task\</acmd\>")) + "\\n";
\} else \{
  str += Obj(assist["Assistee"]) ? pad_left("Assisted By: ", 13) + (Describe(Obj(assist["Assistee"])) +
         spaces(30))[..23] : pad_left("Assisted By: ", 13) + ("**OPEN**" + spaces(40))[..23];

  str += strlen(assist["TimeClaimed"]) \> 1 ? "Date Claimed: " + ctime(Int(assist["TimeClaimed"])) +
         "\\n" : "Date Claimed: **OPEN**\\n";
\}

str += Obj(assist["Assigned"]) ? pad_left("Assigned To: ", 13) + (Describe(Obj(assist["Assigned"])) +
       spaces(30))[..24] : pad_left("Assigned To: ", 13) + (" " + spaces(40))[..24];

str += strlen(assist["TimeClosed"]) \> 1 ? "Date Closed: " + ctime(Int(assist["TimeClosed"])) +
       "\\n" : (!\$task_is_claimed ? "Date Closed: **OPEN**\\n" : UnSAM(ParseXML("\<acmd tag='command' cmd='!tas discard " +
       \$num + "'\>You can discard this task\</acmd\>")) + "\\n");

if (sizeof(assist["Links"]) \> 0) \{
  \$list = "";
  for (z = 0; z \< sizeof(assist["Links"]); z++) \{
    \$list += Str(assist["Links"][z]) + spaces(1);
  \}
  \$list = implode(map_indices(arr_to_set(explode(\$list, " "))), " ");
  str += pad_left("Also See: ", 13) + common::wrap(\$string: \$list, \$maxlength: 60) + "\\n";
\}

str += "------------------------------[X] MESSAGE [X]------------------------------\\n\\n";

str += common::wrap(\$string: assist["AssistText"], \$maxlength: 75) + "\\n\\n";

str += "-------------------------------[X] NOTES [X]-------------------------------\\n\\n";

str += common::wrap(\$string: assist["Notes"], \$maxlength: 75);
/*
EmitTo(\$actor, PRE(str));
*/

if (\$nocont)
    EmitTo(\$actor, PRE(str));
else
    common::more(\$text: str, \$pre: TRUE, \$append: FALSE);

/*
 * CHANGELOG:
 * Aug 19, 2005 \<Zwoc\>: Added \$nocont feature, used when a person displays multiple assists.
 */
      </Core:Property>
      <Core:Property property="merry:lib:doinit">
         X[M] /* D=Initial the general DB */


string *props;

props = property::listprop(\$object: \$data);

for (\$i = 0; \$i \< sizeof(props); \$i++) \{
  Set(\$data, props[\$i], nil);
\}

\$data."array:badnames" = (\{ "w", "who", "recall", "secure", "verbose", "help", "list", "initialize", "queues", "queue", "que",
                            "info", "showall", "flags", "flaglist", "transfer", "return", "claimed", "recap", "online", "current",
                            "note", "retrieve", "search", "stats", "add", "open", "showclosed", "remove", "link", "finish", "finished",
                            "done", "ugly", "twiki", "rename", "watch", "forget", "queuestats", "login", "assign", "backup", "discard",
                            "all", "me", "private", "public", "associate", "show", "hide", "priority", "pri", "abort", "desc", "prefer",
                            "page", "unassigned", "popup", "focus", "lock", "unlock", "tree", "slide", "format", "queueinfo", "cal",
                            "calendar", "sched", "schedule", "addnote", "attach", "showclosed", "reverse", "shift", "recent", "relay",
                            "closelink" \});

\$data."#systemname#" = "[TAS]";
\$data."backup:status" = "halted";

\$data."array:claimed:new" = (\{ \});
\$data."array:open:new" = (\{ \});

\$data."array:claimed:ce" = (\{ \});
\$data."array:open:ce" = (\{ \});

\$data."array:open:tas" = (\{ \});
\$data."array:claimed:tas" = (\{ \});

\$data."array:open:eng-pending" = (\{ \});
\$data."array:claimed:eng-pending" = (\{ \});

\$data."array:open:client" = (\{ \});
\$data."array:claimed:client" = (\{ \});

\$data."array:open:bugs" = (\{ \});
\$data."array:claimed:bugs" = (\{ \});

\$data."array:open:ideas" = (\{ \});
\$data."array:claimed:ideas" = (\{ \});

\$data."array:open:typos" = (\{ \});
\$data."array:claimed:typos" = (\{ \});

\$data."array:open:xcode" = (\{ \});
\$data."array:claimed:xcode" = (\{ \});

\$data."array:open:task" = (\{ \});
\$data."array:claimed:task" = (\{ \});

\$data."array:open:socials" = (\{ \});
\$data."array:claimed:socials" = (\{ \});

\$data."array:open:suspended" = (\{ \});
\$data."array:claimed:suspended" = (\{ \});

\$data."array:open:changelog" = (\{ \});
\$data."array:claimed:changelog" = (\{ \});

\$data."array:open:aztasks" = (\{ \});
\$data."array:claimed:aztasks" = (\{ \});

\$data."array:open:eng-wishlist" = (\{ \});
\$data."array:claimed:eng-wishlist" = (\{ \});

\$data."array:queues" = (\{ "new", "ce", "tas", "client", "task", "eng-pending", "bugs", "typos", "ideas", "xcode", "socials",
                          "suspended", "eng-wishlist", "aztasks", "changelog" \});

\$data."array:queues:system" = (\{ "socials", "suspended", "new", "ce", "tas", "task", "client", "eng-pending", "bugs",
                                 "typos", "ideas", "xcode", "eng-wishlist", "aztasks", "changelog" \});


\$data."array:queues:locked" = (\{ \});
\$data."array:queues:news" = (\{ \});
\$data."array:queues:open:ignore" = (\{ \});
\$data."mapping:assistee" = ([ ]);
\$data."mapping:assistee:claimed" = ([ ]);
\$data."mapping:assistee:closed" = ([ ]);
\$data."mapping:assistee:returned" = ([ ]);
\$data."mapping:assistee:time" = ([ ]);
\$data."mapping:assistee:transfered" = ([ ]);
\$data."mapping:assists:open" = ([ ]);
\$data."mapping:general:statistics" = ([ ]);
\$data."mapping:queues:forwarding" = ([ ]);
\$data."mapping:queues:forward" = ([ ]);
\$data."mapping:queues:owner" = ([ ]);
\$data."mapping:queues:private" = ([ ]);
\$data."mapping:queues:relay" = ([ ]);
\$data."mapping:queues:servertransfer" = ([ ]);
\$data."mapping:queues:timestamp" = ([ ]);
\$data."mapping:subqueues" = ([ ]);
\$data."assist:current" = 0;
\$data."assist:next" = 1;



\$data."mapping:flags" = ([ "none":"n", "urgent":"u", "alert":"a", "silent":"s" ]);

\$data."mapping:time:closed" = ([ 1800:0, 3600:0, 5400:0, 7200:0, 10800:0, 21600:0, 43200:0, 86400:0, 172800:0, 345600:0,
                                 604800:0, 1000000:0 ]);

\$data."mapping:time:closed:total" = ([ 1800:0, 3600:0, 5400:0, 7200:0, 10800:0, 21600:0, 43200:0, 86400:0, 172800:0,
                                       345600:0, 604800:0, 1000000:0 ]);

\$data."mapping:queues:email" = ([ "tas":"AssistSys", "ce":"CE", "client":"Eng-Client", "eng-pending":"Eng-Fire" ]);

\$data."mapping:queues:description" = ([ "tas":"All TAS requests, comments and bugs",
                                        "client":"All game client (alice/zealous/java) issues",
                                        "task":"Generic task queue. Used if you do not have a personal task queue setup",
                                        "xcode":"All cross-game code (xcode) requests, comments and bugs" ]);

EmitTo(\$actor, "General Assist Database Initialized!");
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dolink">
         X[M] /* D=Links assists together

     The following arguments are required:
       \$data: The db object
       \$num1: The first assist
       \$num2: The second assist

*/


mapping assist;


if ((sscanf(\$num1, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num1, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num1 + ") task number.");
  return FALSE;
\}

if ((sscanf(\$num2, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num2, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num2 + ") task number.");
  return FALSE;
\}

if (!assist::dogetassist(\$num: \$num1) \|\| !assist::dogetassist(\$num: \$num2)) \{
  EmitTo(\$actor, "I am unable to find both of those tasks in the assist databaase.");
  return FALSE;
\}

\$num1 = Int(\$num1);
\$num2 = Int(\$num2);

assist = assist::dogetassist(\$num: \$num1);

\$links = (\{ \$num1, \$num2 \});

if (assist["Links"]) \$links \|= assist["Links"];

assist = assist::dogetassist(\$num: \$num2);

if (assist["Links"]) \$links \|= assist["Links"];

/* Now we have a complete list of links. Parse it */

for (\$i = 0; \$i \< sizeof(\$links); \$i++) \{
  assist = assist::dogetassist(\$num: \$links[\$i]);
  assist["Links"] = nil;
  \$mylinks = \$links - (\{ \$links[\$i] \});
  \$mylinks = map_indices(arr_to_set(\$mylinks));
  assist += ([ "Links":\$mylinks ]);
  assist::dosetassist(\$num: \$links[\$i], \$assist: assist);
\}

\$links = assist::dogetassist(\$num: \$num1)["Links"];
\$linklist = "";

for (\$i = 0; \$i \< sizeof(\$links); \$i++) \{
  if (sizeof(\$links) == 1) \{
    \$linklist += \$links[\$i];
    continue;
  \}
  if (\$i == sizeof(\$links)-1) \{
    \$linklist += "and " + \$links[\$i];
  \} else if (\$i == sizeof(\$links)-2) \{
    \$linklist += \$links[\$i] + spaces(1);
  \} else \{
    \$linklist += \$links[\$i] + ", " ;
  \}
\}

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) +
         " has linked task #" + \$num1 + " to " + \$linklist + "!\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "misc", \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dolistbyplayer">
         X[M] /* D=Lists all open assist for player

     The following arguments are required:
       \$data: The DB object
       \$who: The player, passed as string
*/


\$player = common::lookup(\$name: \$who);

if (!\$player) \{
  EmitTo(\$actor, "Unable to find a character named \\"" + capitalize(\$who) + "\\".");
  return FALSE;
\}

/*
\$list = (\{ \});
\$assists = map_indices(\$data."mapping:assists:open");

for (\$i = 0; \$i \< sizeof(\$assists); \$i++) \{
  \$assist = assist::dogetassist(\$num: \$assists[\$i]);
  \$char = Str(assist::docharobj(\$num: \$assists[\$i]));
  if (\$char == Str(\$player)) \{
    \$list += (\{ \$assists[\$i] \});
  \}
\}
*/

\$udat_obj = Call(\$\{UserAPI:UDatD\}, "query_udat", \$name: \$player."skotos:creator");
\$list = Arr(\$udat_obj."array:assists");

if (sizeof(\$list) \< 1) \{
  EmitTo(\$actor, common::get_name(\$src: \$player) + " has no open tasks.");
  return FALSE;
\}

assist::docurrent(\$data: \$data, \$key: "recap", \$list: \$list);
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dolistwhat">
         X[M] /* D=Decides what to do. List a queue or claim an assist

     The following arguments are required:
       \$data: THe db object
       \$words: Contents of the role
       \$cmd: What command is triggering this
       \$key: What key is this? Recap, ugly, etc.
       \$list: An array of assist ints

     The following arguments are optiona:
       \$count: How many to list.
 Starting with the oldest.

*/

string *queues, queue, line;
mixed *content, *assists;
int i, news;

/*
 * Deprecated by Kalle. We don't need this kind of stuff anymore.
if (common::denied()) \{
  EmitTo(\$actor, "The command you entered was not understood by the system. Try again with different phrasing.");
  return FALSE;
\}
 */

queues = \$data."array:queues";
queue = !\$words ? "" : lower_case(\$words[0]);

if (!\$cmd) \{
  if (\$actor."udat:host" == 1) \{
    \$cmd = "+tas";
  \} else \{
    \$cmd = "!tas";
  \}
\}

if (\$key == "ugly" \&\& !member(queue, queues)) \{
  EmitTo(\$actor, "You supplied an invalid (" + queue + ") queue.");
  return FALSE;
\}

if (\$count) \{
  if ((sscanf(\$count, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$count, "%d%s", \$number, \$dummy) == 0) \{
    EmitTo(\$actor, "You supplied an invalid count number.");
    return FALSE;
  \}
  \$count = Int(\$count);
\}

if (member(queue, \$data."array:queues:locked") \&\& \$actor."udat:host" == 0) \{
  EmitTo(\$actor, "The " + capitalize(queue) + " queue is locked. You may not view its contents.");
  return FALSE;
\}


if (\$key == "recap" \|\| \$key == "open" \|\| member(queue, queues)) \{
  news = (member(queue, \$data."array:queues:news") \|\| (\$actor."tas:queues:news" \&\&
          member(queue, \$actor."tas:queues:news")) ? 1 : 0);
  assists = !\$list ? (\$key == "reverse" ? reverse(map_indices(arr_to_set(Get(\$data, "array:open:" + queue)))) :
            map_indices(arr_to_set(Get(\$data, "array:open:" + queue)))) : \$list;
  content = (news == 1 ? (\{ (\{ "#", "Time", "Character", "Task" \}) \}) : (\{ (\{ "#", "Pr", "F", "N", "Time", "Account",
             "Character", "Task" \}) \}));
  \$rockline = "";

  if (sizeof(assists) \< 1) \{
    \$rockline = spaces(9) + "No tasks in the queue. You rock!" + (!\$nofooter ? "\\n\\nAlso See: " + \$cmd +
                " help (help\|basic\|task\|list\|queue\|login\|misc\|chat\|personal\|commands\|subqueues\|all)\\n" : "");
  \} else \{
    \$rockline = (!\$nofooter ? "\\nAlso See: " + \$cmd +
                " help (help\|basic\|task\|list\|queue\|login\|misc\|chat\|personal\|commands\|subqueues\|all)\\n" : "");
  \}

  if (!\$count) \$count = sizeof(assists);

  \$ttl = 0;

  for (i = 0; i \< sizeof(assists) \&\& \$ttl \< \$count; i++) \{
    \$assist = assist::dogetassist(\$num: Str(assists[i]));
    if ((\$key == "unassigned" \&\& \$assist["Assigned"] == "") \|\| \$key != "unassigned") \{
      \$char = \$assist["CharObj"];
      if (news == 0) \{
        \$line = (\{ Str(assists[i]),
                   Str(\$assist["Priority"]),
                   capitalize(\$assist["Flag"]),
                   (strlen(\$assist["Notes"]) \> 1 ? "Y" : ""),
                   short_time(Int(\$assist["TimeFiled"])) \});


        if (\$assist["Account"]) \{
          \$line += (\{ (lower_case(\$assist["Account"]) + spaces(15))[..15] \});
        \} else \{
          if (\$char."skotos:creator") \{
            \$line += (\{ (\$char."skotos:creator" + spaces(15))[..15] \});
          \} else \{
            \$line += (\{ "" \});
          \}

        \}

        \$line += \$char ? (\{ common::get_name(\$src: \$char) \}) : (\{ "Unknown" \});

        \$line += \$key != "ugly" ? (\{ (\$assist["AssistText"] + spaces(30))[..30] \}) : (\{ \$assist["AssistText"] \});
      \} else \{
        \$line = (\{ Str(assists[i]),
                   short_time(Int(\$assist["TimeFiled"]))[..5] \});

        \$line += \$char ? (\{ common::get_name(\$src: \$char) \}) : (\{ "Unknown" \});

        \$line += \$key != "ugly" ? (\{ (\$assist["AssistText"] + spaces(60))[..60] \}) : (\{ \$assist["AssistText"] \});
      \}

      content += (\{ \$line \});

      \$ttl++;
    \}
  \}

  if (!\$popup) \{
EmitTo(\$actor, "1");
    if (Get(\$data, "array:subqueues:" + queue) \&\& sizeof(Get(\$data, "array:subqueues:" + queue)) != 0 \&\& sizeof(assists) \< 1) \{
      assist::doqueue(\$showsubs: queue);
    \} else \{
      EmitTo(\$actor, PRE("Queue: " + capitalize(queue) + spaces(5) + "Type: " + (news == 1 ? "News" : "Standard") +
                     "\\n" + ascii::table(\$content: content, \$ignoreseparator: "top bottom right left") + \$rockline));
    \}

  if (member(\$actor."udat:name", map_indices(\$data."mapping:assistee"))) \{
    line = "You have the following tasks claimed: " + LINK(\$data."mapping:assistee"[\$actor."udat:name"], "+tas info " + \$data."mapping:assistee"[\$actor."udat:name"], "command") + ".";
    EmitTo(\$actor, TAG(line, "assist-alert"));
  \}

  if (\$actor."array:assists:assigned" \&\& sizeof(\$actor."array:assists:assigned") \> 0) \{
    line = "The following tasks have been assigned to you: " + implode(map_indices(arr_to_set(\$actor."array:assists:assigned")), ", ") +
           ".";
    EmitTo(\$actor, TAG(line, "assist-alert"));
  \}

    \$count = nil;
    return FALSE;
  \} else \{
    \$output = "Queue: " + capitalize(queue) + "\\n" + ascii::table(\$content: content, \$ignoreseparator: "top bottom right left") +
              \$rockline;
    return \$output;
  \}
\}

assist::doclaim(\$data: \$data, \$num: \$words[0], \$cmd: \$cmd);

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dolock">
         X[M] /* D=Locks a queue

    The following arguments are required:
      \$queue: The queue that is being locked
*/

\$queue = lower_case(\$queue);

if (!member(\$queue, \$data."array:queues")) \{
  EmitTo(\$actor, "That is not a valid queue to lock.");
  return FALSE;
\}

if (member(\$queue, \$data."array:queues:locked")) \{
  EmitTo(\$actor, "That queue is already locked!");
  return FALSE;
\}

\$data."array:queues:locked" += (\{ \$queue \});

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) + " has locked the " + capitalize(\$queue) + " queue.\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: \$queue, \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dologin">
         X[M] /* D=Displays defined queues.

This command works in three ways, they are:
  +/!assist login - Displays what queues you want displayed at login
  +/!assist login (queue) - Adds or removes queue from your list

     The following arguments are required:
       \$data: The DB object

     The following arguments are optional:
       \$queue: The name of the queue you want to add or remove
*/

if (!\$queue) \{
  if (!\$actor."array:assist:login") \{
    EmitTo(\$actor, "You are not monitoring any queues at login.");
    return FALSE;
  \} else \{
    \$list = \$actor."array:assist:login";
    \$line = smalltime(time()) + spaces(1) + \$tas + " \\"You are monitoring the following queues at login: " + implode(map_indices(arr_to_set(\$list)), ", ") + ".\\"";
    EmitTo(\$actor, TAG(\$line, "assist-alert"));
    return FALSE;
  \}
\}

\$queue = lower_case(\$queue);

if (!member(\$queue, \$data."array:queues")) \{
  EmitTo(\$actor, "That is not a valid queue.");
  return FALSE;
\}

if (!\$actor."array:assist:login") \{
  \$actor."array:assist:login" = (\{ \$queue \});
  EmitTo(\$actor, "The queue (" + capitalize(\$queue) + ") has been added to your monitor list.");
  return FALSE;
\}

if (!member(\$queue, \$actor."array:assist:login")) \{
  \$actor."array:assist:login" += (\{ \$queue \});
  EmitTo(\$actor, "The queue (" + capitalize(\$queue) + ") has  been added to your monitor list.");
  return FALSE;
\}

\$actor."array:assist:login" -= (\{ \$queue \});
EmitTo(\$actor, "The queue (" + capitalize(\$queue) + ") has been removed from your monitor list.");
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dologon">
         X[M] /* D=Alert line if player logs in and has an assist marked with the Alert flag. Also alert staffer if they have an assist claimed.

     The following arguments are required:
       \$data: The db object

*/

mixed *assists, *nums, *allassists, whichassist;
mapping assist;
string line;
int q;

\$delay(5, TRUE, "e5c5");

if (\$actor."udat:possessed" == 1) \{
  nums = (\{ \});
  \$tas = \$data."#systemname#";

  /*
   ********************************************************************
   ** TAS code for alerting if you have any assists claimed at login **
   ********************************************************************
  */

  if (member(\$actor."udat:name", map_indices(\$data."mapping:assistee"))) \{
    line = smalltime(time()) + spaces(1) + \$tas + " \\"You have the following tasks claimed: " + UnSAM(ParseXML("\<acmd tag='command' cmd='!tas info " + \$data."mapping:assistee"[\$actor."udat:name"] + "'\>" + \$data."mapping:assistee"[\$actor."udat:name"] + "\</acmd\>")) + ".\\"";
    EmitTo(\$actor, TAG(line, "assist-alert"));
  \}

  /*
   **********************************************************************************
   ** TAS code for alerting chatline if player has any assists set on alert status **
   **********************************************************************************
  */

  \$udat_obj = Call(\$\{UserAPI:UDatD\}, "query_udat", \$name: (\$actor."skotos:creator" ? \$actor."skotos:creator" : \$actor."udat:name"));

  \$tasks = \$actor."array:assists";

  if (\$tasks) \{
    if (\$udat_obj."array:assists") \{
      \$udat_obj."array:assists" \|= \$tasks;
    \} else \{
      \$udat_obj."array:assists" = \$tasks;
    \}
    \$actor."array:assists" = nil;
  \}

  allassists = \$udat_obj."array:assists";
  if (allassists) \{
    for (q = 0; q \< sizeof(allassists); q++) \{
      whichassist = allassists[q];
      if (!member(Str(whichassist), map_indices(\$data."mapping:assists:open"))) \{
        \$udat_obj."array:assists" -= (\{ Int(whichassist) \});
      \}
    \}
  \}

  if (\$udat_obj."array:assists") \{
    assists = \$udat_obj."array:assists";
    for (\$i = 0; \$i \< sizeof(assists); \$i++) \{
      assist = assist::dogetassist(\$num: assists[\$i]);
      if (member(assist["Flag"], (\{ "a", "u" \})) \|\| (assist["Queue"] == "new" \&\& assist["Flag"] != "s")) \{
        nums += (\{ Str(assists[\$i]) \});
      \}
    \}
    if (sizeof(nums) \> 0) \{
      int i, ix;
      string *sn, result;

      sn     = map_indices(arr_to_set(nums));
      ix     = sizeof(sn);
      result = "";
      for (i = 0; i \< ix; i++) \{
        result += (i == 0 ? "" : ", ") + "\<acmd tag='command' cmd='!tas info " + sn[i] + "'\>" + sn[i] + "\</acmd\>";
      \}

      line = smalltime(time()) + spaces(1) + \$tas + " \\"" + Describe(\$actor) + "[" + \$actor."udat:name" + "] has connected and has the following tasks set on alert status: " + UnSAM(ParseXML(result)) + ".\\"";
      chat::feed(\$chat_datlib: \$\{Data:DB:chat:tas\}, \$chat_data: line, \$chat_style: "assist-alert");
    \}
  \}

  /*
   *********************************************************************************
   ** TAS code for alerting if you are watching any assists and they have changed **
   *********************************************************************************
  */

  if (\$actor."mapping:assists:watch") \{
    \$watch = copy(\$actor."mapping:assists:watch");
    \$indices = map_indices(\$watch);
    \$changed = (\{ \});
    \$remove = (\{ \});

    for (\$i = 0; \$i \< sizeof(\$indices); \$i++) \{
      assist = assist::dogetassist(\$num: \$indices[\$i]);
      if (assist["TimeClosed"] != "") \{
        \$remove += (\{ \$indices[\$i] \});
      \}
      if (Int(assist["RevTime"]) \> \$watch[\$indices[\$i]]) \{
        \$changed += (\{ \$indices[\$i] \});
      \}
    \}
    \$indices -= \$remove;
    \$watch = nil;
    \$watch = ([ ]);
    if (sizeof(\$indices) \> 0) \{
      for (\$i = 0; \$i \< sizeof(\$indices); \$i++) \{
        \$watch += ([ \$indices[\$i]:time() ]);
      \}
    \}
    \$actor."mapping:assists:watch" = \$watch;
    if (sizeof(\$changed) \> 0) \{
      line = smalltime(time()) + spaces(1) + \$tas + " \\"The following tasks have changed since you last connected: " + implode(map_indices(arr_to_set(\$changed)), ", ") + ".\\"";
      EmitTo(\$actor, TAG(line, "assist-alert"));
    \}
  \}

  /*
   ***************************************************************
   ** TAS code for alerting you if you are watching any queues  **
   ****************************************************************
  */

  if (\$actor."array:assist:login") \{
    \$actor."array:assist:login" \&= \$data."array:queues";
    \$queues = copy(\$actor."array:assist:login");
    for (\$f = 0; \$f \< sizeof(\$queues); \$f++) \{
      /* if (!\$actor."cdat:lastlogout" \|\| !\$data."mapping:queues:timestamp"[\$queues[\$f]] \|\| (\$data."mapping:queues:timestamp"[\$queues[\$f]] \&\& \$actor."cdat:lastlogout" \<= \$data."mapping:queues:timestamp"[\$queues[\$f]])) \{
        \$list = nil;
        assist::dolistwhat(\$data: \$data, \$words: (\{ \$queues[\$f] \}));
      \} */
    assist::dolistwhat(\$data: \$data, \$words: (\{ \$queues[\$f] \}));
    \}
  \}

  /*
   ***********************************************************************
   ** TAS code for alerting you if you have any assists assigned to you **
   ***********************************************************************
  */

  if (\$actor."array:assists:assigned" \&\& sizeof(\$actor."array:assists:assigned") \> 0) \{
    int i, ix;
    string *assists, samData;

    line    = smalltime(time()) + spaces(1) + \$tas + " \\"The following tasks have been assigned to you: ";
    assists = map_indices(arr_to_set(\$actor."array:assists:assigned"));
    ix      = sizeof(assists);
    samData = "";

    for (i = 0; i \< ix; i++)
        samData += (samData == "" ? "" : ", ") + "\<acmd cmd='!tas info " + assists[i] + "'\>" + assists[i] + "\</acmd\>";
    EmitTo(\$actor, TAG(line + UnSAM(ParseXML(samData)), "assist-alert"));
  \}

  /*
   *******************************************************************
   ** TAS code for reminding you of any scheduled tasks on this day **
   *******************************************************************
  */

  if (\$actor."udat:object"."tas:calendar") \{
    \$time_month = common::reverse_ctime(\$year: ctime(time())[20..], \$month: lower_case(ctime(time())[4..6]), \$day: 1);
    \$calendar = \$actor."udat:object"."tas:calendar";
    if (member(\$time_month, map_indices(\$calendar))) \{
      \$monthly_sched = \$calendar[\$time_month];
      \$time_day = common::reverse_ctime(\$year: ctime(time())[20..], \$month: lower_case(ctime(time())[4..6]), \$day: ctime(time())[8..10]);
      if (member(\$time_day, map_indices(\$monthly_sched))) \{
        line = smalltime(time()) + spaces(1) + \$tas + " \\"The following tasks have been scheduled for today: " +
implode(map_indices(arr_to_set(\$monthly_sched[\$time_day])), ", ") + ".\\"";
        EmitTo(\$actor, TAG(line, "assist-alert"));
      \}
    \}
  \}

  /* Now lets check for memos */

  if (\$actor."tas:calendar") \{
    if (member(\$time_month, map_indices(\$actor."tas:calendar"))) \{
      if (member(\$time_day, map_indices(\$actor."tas:calendar"[\$time_month]))) \{
        EmitTo(\$actor, TAG("[Memo Reminder]: Memos noted. Please review the memos you have set for today.", "imp"));
      \}
    \}
  \}

  /*
   *****************************
   ** Do HTML cleanup, if any **
   *****************************
  */

  \$actor."html:footerhelp" = nil;
  \$actor."html:header:help" = nil;
  \$actor."html:output" = nil;
\}
return TRUE;
      </Core:Property>
      <Core:Property property="merry:lib:donote">
         X[M] /* D= Add a note to the assist

     The following arguments are required:
       \$num: Number of the assist
       \$note: The note

*/

mapping assist;
int num;

if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

num = Int(\$num);

if (num \< 0 \|\| num \> Int(\$data."assist:current")) \{
  EmitTo(\$actor, "You supplied an invalid (" + Str(num) + ") task number.");
  return FALSE;
\}

assist = assist::dogetassist(\$num: Str(num));

if (member(assist["Queue"], \$data."array:queues:locked") \&\& \$actor."udat:host" == 0) \{
  EmitTo(\$actor, "That task is in a locked queue. You may not add notes to a task in a locked queue.");
  return FALSE;
\}

\$notes = assist["Notes"] + chat::get_prefername(\$channel: "tas", \$user: \$actor) + spaces(1) + "(" + short_time(time()) + "): " + implode(\$note, " ") + "\\n\\n";

assist["Notes"] = nil;

assist += ([ "Notes":\$notes ]);

assist::dosetassist(\$num: Str(num), \$assist: assist);

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) + " has added a note to \<" + capitalize(assist["Queue"]) + "/#" + Str(num) + "\>.\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "misc", \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doonline">
         X[M] /* D=Checks connected players to see if they have any assists open.

     The following arguments are required:
       \$data: The db object.

*/

\$online = ([ ]);


if (\$queue \&\& lower_case(\$queue) != "all") \{
  if (!member(lower_case(\$queue), \$data."array:queues")) \{
    EmitTo(\$actor, "That is not a valid queue.");
    return FALSE;
  \}
  \$open = Get(\$data, "array:open:" + lower_case(\$queue));
\} else \{
  \$open = map_indices(\$data."mapping:assists:open");
\}

for (\$i = 0; \$i \< sizeof(\$open); \$i++) \{
  \$assist = assist::dogetassist(\$num: \$open[\$i]);

  \$char = Str(\$assist["CharObj"]);
  if (Obj(\$char) \&\& Obj(\$char)."udat:possessed" == 1) \{
    if (\$online[\$char]) \{
      \$nums = \$online[\$char];
      \$online[\$char] = nil;
      \$nums += (\{ Str(\$open[\$i]) \});
      \$online += ([ \$char:\$nums ]);
    \} else \{
      \$online += ([ \$char:(\{ Str(\$open[\$i]) \}) ]);
    \}
  \}
\}

if (map_sizeof(\$online) \> 0) \{
  \$table = (\{ (\{ "Character", "Open Tasks" \}) \});
  \$indices = map_indices(\$online);
  for (\$i = 0; \$i \< sizeof(\$indices); \$i++) \{
    \$table += (\{ (\{ common::get_name(\$src: Obj(\$indices[\$i])), implode(\$online[\$indices[\$i]], ", ") \}) \});
  \}
EmitTo(\$actor, PRE("Online Players for Queue: " + capitalize(\$queue) + "\\n" + ascii::table(\$content: \$table, \$ignoreseparator: "top bottom left right")));
return FALSE;
\}

EmitTo(\$actor, "There are no players online with open tasks.");
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doopage">
         X[M] /* D=Sends an opage to the player who filed the task for the assist specified

     The following arguments are required:
       \$data: The db object
       \$num: The task number
       \$page: The page text

*/

if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if (Int(\$num) \<= 0 \|\| Int(\$num) \> \$data."assist:current") \{
  EmitTo(\$actor, "That is not a valid task.");
  return FALSE;
\}

\$player = assist::docharobj(\$num: \$num);

if (\$player) \{
  common::add_page(\$user: \$player, \$message: \$(raw-evoke), \$actor: common::lookup(\$name: chat::get_prefername(\$channel: "tas", \$user: \$actor)));

  EmitTo(\$actor, "The page is in " + Describe(\$player) + "\\'s pending pages. " + capitalize( \$player."trait:nominative" ) + " will be notified of this upon connect.");
  return FALSE;
\}

EmitTo(\$actor, "I was not able to locate the player who filed that task.");

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doopen">
         X[M] /* D=Shows all open assists

     The following arguments are required:
       \$data: The db object

*/


int i, *assists;
string *queues;

assists = (\{ \});
queues = \$data."array:queues";

for (i = 0; i \< sizeof(queues); i++) \{
  if (sizeof(Get(\$data, "array:open:" + queues[i])) \> 0 \&\& !member(queues[i], \$data."array:queues:open:ignore")) \{
    assists = Get(\$data, "array:open:" + queues[i]);
    assist::dolistwhat(\$data: \$data, \$key: "open", \$list: assists, \$cmd: \$cmd, \$words: (\{ queues[i] \}));
  \}
\}

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dopopup">
         X[M] /* D=For testing TAS popup code */

Popup(\$actor, \$this, "popup", \$actor: \$actor, \$cmd: \$cmd, \$data: \$data, \$que: "new");
      </Core:Property>
      <Core:Property property="merry:lib:doprefer">
         X[M] /* D=Sets your preferred queue for the +/!tas command queue list

     The following arguments are required:
       \$data: The db object
       \$queue: The queue, none to default back to new

*/

if (!\$queue) \{
  if (!\$actor."tas:preferred:queue") \{
    EmitTo(\$actor, TAG(smalltime(time()) + spaces(1) + \$tas + " \\"You do not have a preferred queue set.\\"", "assist-alert"));
    return FALSE;
  \}
  EmitTo(\$actor, TAG(smalltime(time()) + spaces(1) + \$tas + " \\"You have " + upper_case(\$actor."tas:preferred:queue") + " set as your preferred queue.\\"", "assist-alert"));
  return FALSE;
\}

if (lower_case(\$queue) == "none") \{
  \$actor."tas:preferred:queue" = nil;
  EmitTo(\$actor, "Your preferred queue has been removed. " + \$cmd + " shall now list the default queue.");
  return FALSE;
\}

if (!member(lower_case(\$queue), \$data."array:queues")) \{
  EmitTo(\$actor, "There does not seem to be a queue called " + \$queue + ".");
  return FALSE;
\}

\$actor."tas:preferred:queue" = lower_case(Str(\$queue));

EmitTo(\$actor, "You have set (" + \$queue + ") as your preferred queue.");

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dopriority">
         X[M] /* D=Change priority of a task

     The following arguments are required
       \$data: The db object
       \$num: The assist number
       \$pri: The new priority

*/

if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if ((sscanf(\$pri, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$pri, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$pri + ") priority number.");
  return FALSE;
\}

if (Int(\$num) \< 0 \|\| Int(\$num) \> \$data."assist:current") \{
  EmitTo(\$actor, "I cannot find task #" + \$num + " in the database.");
  return FALSE;
\}

if (Int(\$pri) \< 0 \|\| Int(\$pri) \> 10) \{
  EmitTo(\$actor, "Priority number must be between 1 and 10.");
  return FALSE;
\}

\$assist = assist::dogetassist(\$num: \$num);

\$oldpri = \$assist["Priority"];

\$assist["Priority"] = nil;

\$assist += ([ "Priority":Int(\$pri) ]);

assist::dosetassist(\$num: \$num, \$assist: \$assist);

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) + " has changed the priority of task #" + \$num + " from " + Str(\$oldpri) + " to " + Str(\$pri) + ".\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "misc", \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doprivate">
         X[M] /* D=Set a queue as private

     The following arguments are required:

       \$data: The db object
       \$queue: The queue

*/

if (!member(\$queue, \$data."array:queues")) \{
  EmitTo(\$actor, "That is not a valid queue.");
  return FALSE;
\}

if (member(\$queue, map_indices(\$data."mapping:queues:private"))) \{
  EmitTo(\$actor, "The queue (" + capitalize(\$queue) + ") is already set private.");
  return FALSE;
\}

\$private = copy(\$data."mapping:queues:private");
\$private += ([ \$queue:"" ]);
\$data."mapping:queues:private" = \$private;

EmitTo(\$actor, TAG(smalltime(time()) + spaces(1) + \$data."#systemname#" + spaces(1) + "\\"You have marked the queue " + capitalize(\$queue) + " as private.\\"", "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dopublic">
         X[M] /* D=Set a queue as public

     The following arguments are required:

       \$data: The db object
       \$queue: The queue

*/

if (!member(\$queue, \$data."array:queues")) \{
  EmitTo(\$actor, "That is not a valid queue.");
  return FALSE;
\}

if (!member(\$queue, map_indices(\$data."mapping:queues:private"))) \{
  EmitTo(\$actor, "The queue (" + capitalize(\$queue) + ") is already set public.");
  return FALSE;
\}

\$private = copy(\$data."mapping:queues:private");
\$private[\$queue] = nil;
\$data."mapping:queues:private" = \$private;

EmitTo(\$actor, TAG(smalltime(time()) + spaces(1) + \$data."#systemname#" + spaces(1) + "\\"You have marked the queue " + capitalize(\$queue) + " as public.\\"", "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doqueue">
         X[M] /* D=Lists the queues

     The following arguments are required:
       \$data: The db object

*/


string *queues;
int i;

if (!\$showsubs) \{
  if (!\$actor."tas:focus" \|\| \$actor."tas:focus" == "general") \{
    queues = \$data."array:queues" ? \$data."array:queues" : (\{ \});
    queues -= (lower_case(\$(dob:words)[0]) == "all" ? (\$data."mapping:subqueues" ? map_indices(\$data."mapping:subqueues") : (\{ \})) : map_indices(\$data."mapping:queues:private"));
    queues = map_indices(arr_to_set(queues));
  \} else \{
    queues = Get(\$data, "array:subqueues:" + \$actor."tas:focus");
    queues = map_indices(arr_to_set(queues));
  \}
\} else \{
  queues = Get(\$data, "array:subqueues:" + \$showsubs);
  queues = map_indices(arr_to_set(queues));
\}


\$str = (\{ (\{ "S/E/P/G/L/F/R", "Op/Cl", "Queue", "Description" \}) \});
\$system = \$data."array:queues:system";


for (i = 0; i \< sizeof(queues); i++) \{
  \$line = (\{ (!member(queues[i], \$system) ? spaces(2) : "* ") +
             (!member(queues[i], map_indices(\$data."mapping:queues:email")) ? spaces(2) : "* ") +
             (!member(queues[i], map_indices(\$data."mapping:queues:private")) ? spaces(2) : "* ") +
             (!Get(\$data, "array:subqueues:" + queues[i]) \|\| sizeof(Get(\$data, "array:subqueues:" + queues[i])) == 0 ? spaces(2) : "* ") +
             (!member(queues[i], \$data."array:queues:locked") ? "" : "*") +
             (!member(queues[i], map_indices(\$data."mapping:queues:servertransfer")) ? "" : "*") +
             (!member(queues[i], map_indices(\$data."mapping:queues:relay")) ? "" : "*"),
             pad_left(Str(sizeof(Get(\$data, "array:open:" + queues[i]))), 2) + "/" +
             Str(sizeof(Get(\$data, "array:claimed:" + queues[i]))),
             capitalize(queues[i]),
             (!member(queues[i], map_indices(\$data."mapping:queues:description")) ? "" : \$data."mapping:queues:description"[queues[i]])
             \});
  \$str += (\{ \$line \});
\}

EmitTo(\$actor, PRE(ascii::table(\$content: \$str, \$ignoreseparator: "top bottom left right") + "\\nS: System, E: Email Alerted, P: Private, G: Contains SubQueues,\\nL: Locked Queue, F: Forwarded Queue, R: Relay Queue\\n" + (lower_case(\$(dob:words)[0]) == "all" ? "This queue list is unfiltered. See \\'" + \$cmd + " queues\\' for the filtered list.\\n" : "This queue list is filtered. See \\'" + \$cmd + " all\\' for the unfiltered list.\\n") + "Total Queues: " + Str(sizeof(queues))));
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doqueuedesc">
         X[M] /* D=Give a queue a description

     The following arguments are required
       \$data: The db object
       \$queue: The queue in question
       \$desc: The description

*/

if (!\$queue) \{
  /* Lets list all the queue descriptions */
  \$queuelist = map_indices(arr_to_set(\$data."array:queues"));
  \$output = (\{ (\{ "Queue", "Description" \}) \});
  for (\$p = 0; \$p \< sizeof(\$queuelist); \$p++) \{
    \$output += (\{ (\{ capitalize(\$queuelist[\$p]), Str(\$data."mapping:queues:description"[\$queuelist[\$p]]) \}) \});
  \}
  EmitTo(\$actor, PRE(ascii::table(\$content: \$output, \$ignoreseparator: "top bottom left right")));
  return FALSE;
\}

if (!member(lower_case(\$queue), \$data."array:queues")) \{
  EmitTo(\$actor, "I am unable to find that queue.");
  return FALSE;
\}

\$data."mapping:queues:description" += ([ lower_case(\$queue):\$desc ]);

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) + " has set the description for " + capitalize(\$queue) + " to: " + \$desc + ".\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: \$queue, \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doqueueinfo">
         X[M] /* D=Displays info for queue

    The following arguments are required:
      \$queue: The queue


------------------------------------------------------------------------
         Name: Tas                   System: Yes
         Type: Standard               Email: Yes
         Open: 1                    Private: No
      Claimed: 0                      Group: Yes
 Parent Queue: General               Locked: No
    Forwarded: Marrach                Relay: Marrach

    SubQueues: Tas-updates, Tas-wishlist
  Description: All TAS requests, comments and bugs
------------------------------------------------------------------------


*/

\{
  string queue, *queues, output;

  queue = lower_case(\$queue);
  queues = \$data."array:queues";

  if (!member(queue, queues)) \{
    EmitTo(\$actor, "I am unable to find that queue.");
    return FALSE;
  \}

  output = "----------------------------------------------------------------------\\n";
  output += pad_left("Name: ", 15) + (capitalize(queue) + spaces(20))[..20];
  output += pad_left("System: ", 9) + (member(queue, \$data."array:queues:system") ? "Yes" : "No") + "\\n";
  output += pad_left("Format: ", 15) + ((member(queue, \$data."array:queues:news") ? "Short" : "Long") + spaces(20))[..20];
  output += pad_left("Email: ", 9) + (member(queue, map_indices(\$data."mapping:queues:email")) ? "Yes" : "No") + "\\n";
  output += pad_left("Open: ", 15) + (Str(sizeof(Get(\$data, "array:open:" + queue))) + spaces(20))[..20];
  output += pad_left("Private: ", 9) + (member(queue, map_indices(\$data."mapping:queues:private")) ? "Yes" : "No") + "\\n";
  output += pad_left("Claimed: ", 15) + (Str(sizeof(Get(\$data, "array:claimed:" + queue))) + spaces(20))[..20];
  output += pad_left("Group: ", 9) + ((\$r1 = Get(\$data, "array:subqueues:" + queue)) \&\& sizeof(\$r1) \> 0 ? "Yes" : "No") + "\\n";
  output += pad_left("Parent Queue: ", 15) + ((member(queue, map_indices(\$data."mapping:subqueues")) ? capitalize(\$data."mapping:subqueues"[queue]) : "General") + spaces(20))[..20];
  output += pad_left("Locked: ", 9) + (member(queue, \$data."array:queues:locked") ? "Yes" : "No") + "\\n";
  output += pad_left("Svr Transfer: ", 15) + ((member(queue, map_indices(\$data."mapping:queues:servertransfer")) ? capitalize(\$data."mapping:queues:servertransfer"[queue]) : "None") + spaces(20))[..20];
  output += pad_left("Relay: ", 9) + (member(queue, map_indices(\$data."mapping:queues:relay")) ? capitalize(\$data."mapping:queues:relay"[queue]) : "None") + "\\n";
  output += (\$r1 \&\& sizeof(\$r1) \> 0 ? "\\n" + pad_left("SubQueues: ", 15) + common::wrap(\$string: implode(\$r1, " "), \$maxlength: 60) + "\\n" : "" );
  output += (\$data."mapping:queues:description"[queue] ? "\\n" + spaces(24) + "--=[ Description ]=--\\n" +
common::wrap(\$string: \$data."mapping:queues:description"[queue], \$maxlength: 70) + "\\n" : "");
  output += "----------------------------------------------------------------------\\n";

  EmitTo(\$actor, PRE(output));
  return FALSE;
\}
      </Core:Property>
      <Core:Property property="merry:lib:doqueuesme">
         X[M] /* D=Shows you the content of any queues you are monitoring.

     The following arguments are required:
       \$data: The db object.

*/

if (!\$actor."array:assist:login") \{
  EmitTo(\$actor, "You are not monitoring any queues at login.");
  return FALSE;
\}

\$actor."array:assist:login" \&= \$data."array:queues";
\$queues = copy(\$actor."array:assist:login");

for (\$f = 0; \$f \< sizeof(\$queues); \$f++) \{
  assist::dolistwhat(\$data: \$data, \$words: (\{ \$queues[\$f] \}), \$nofooter: (\$f + 1 \< sizeof(\$queues) ? TRUE : FALSE));
\}

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dorecap">
         X[M] /* D=Shows assists filed in last 24 hours.

     The following arguments are required:
       \$data: The db object
*/

\$recaptime = time() - 86400;
\$current   = \$data."assist:current";
\$assists   = (\{ \});
\$starttime = time();

if (\$queue \&\& !member(\$queue, \$data."array:queues")) \{
  EmitTo(\$actor, "You supplied an invalid queue.");
  return FALSE;
\}

EmitTo(\$actor, TAG(smalltime(time()) + " [TAS] \\"Searching for all tasks filed in the last 24 hours. This will take approximately " + Str(Flt(Int(\$current)) * Flt(0.035)) + " seconds.\\"", "assist-alert"));

for (\$i = \$current; \$i != 0; \$i--) \{
  if (\$queue \&\& assist::dogetassist(\$num: \$i)["Queue"] == \$queue) \{
    if (Int(assist::dogetassist(\$num: \$i)["TimeFiled"]) \>= \$recaptime) \{
      \$assists += (\{ \$i \});
    \}
  \} else if (!\$queue) \{
    if (Int(assist::dogetassist(\$num: \$i)["TimeFiled"]) \>= \$recaptime) \{
      \$assists += (\{ \$i \});
    \}
  \}
  \$delay(0.01, TRUE, "a717");
\}

assist::docurrent(\$data: \$data, \$key: "recap", \$list: \$assists);
EmitTo(\$actor, PRE("Actual Search Time: " + Str(time() - \$starttime) + " seconds"));


return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dorecent">
         X[M] /* D=Lists the top 25 most recent filed tasks */



\{

  if (sizeof(\$(dob:words)) == 2) \{
    if (\$(dob:words)[1] == "me") \{
      \$queue = "me";
      \$int   = 25;
    \} else if (member(\$(dob:words)[1], \$data."array:queues")) \{
      \$queue = \$(dob:words)[1];
      \$int = 25;
    \} else if (common::isnan(\$value: \$(dob:words)[1]) == 0) \{
      \$int = Int(\$(dob:words)[1]);
    \} else \{
      EmitTo(\$actor, "I don't understand " + \$(dob:words)[1] + ".");
      return FALSE;
    \}
  \}

  if (sizeof(\$(dob:words)) == 3) \{
    if (\$(dob:words)[1] == "me") \{
      \$queue = "me";
    \} else if (member(\$(dob:words)[1], \$data."array:queues")) \{
      \$queue = \$(dob:words)[1];
    \} else \{
      EmitTo(\$actor, "You supplied an invalid argument. Need either \\'me\\' or the name of a queue.");
      return FALSE;
    \}
    if ((sscanf(\$(dob:words)[2], "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$(dob:words)[2], "%d%s", \$number, \$dummy) == 0) \{
      EmitTo(\$actor, "You supplied an invalid (" + \$(dob:words)[2] + ") count number.");
      return FALSE;
    \} else \{
      \$int = Int(\$(dob:words)[2]);
    \}
  \}

/*
  if (!member(\$queue, \$data."array:queues") \&\& \$queue != "me") \{
    EmitTo(\$actor, "You supplied an invalid queue.");
    return FALSE;
  \}
*/

  \$int = (!\$int ? 25 : \$int);
  \$me  = Str(\$actor);

  \$current = \$data."assist:current";
  \$assists = ([ ]);

  EmitTo(\$actor, TAG(smalltime(time()) + " [TAS] \\"Searching for " + (\$queue == "me" ? "your " : "the ") + Str(\$int) + " most recent closed tasks in " + (!\$queue \|\| \$queue == "me" ? "all the queues" : "the " + capitalize(\$queue) + " queue") + ". This shall take approximately " + Flt(\$current) * Flt(0.035) + " seconds.\\"", "assist-alert"));

  for (\$i = \$current; \$i != 0 \&\& !\$actor."tas:abort"; \$i--) \{
    \$assist = assist::dogetassist(\$num: \$i);
    if ((\$queue == "me" \&\& \$assist["Assistee"] == \$me \&\& \$assist["TimeClosed"] != "") \|\| (\$assist["Queue"] == \$queue \&\& \$assist["TimeClosed"] != "") \|\| (!\$queue \&\& \$assist["TimeClosed"] != "")) \{
      \$assists += ([ Int(\$assist["TimeClosed"]):Int(\$i) ]);
      if (map_sizeof(\$assists) \> \$int) \{
        \$assists[map_indices(\$assists)[0]] = nil;
      \}
    \}
    \$delay(0.01, TRUE, "f0ee");
  \}
  assist::docurrent(\$data: \$data, \$key: "recap", \$list: map_indices(reverse_mapping(\$assists)));
  \$actor."tas:abort" = nil;
  return FALSE;
\}
      </Core:Property>
      <Core:Property property="merry:lib:dorelay">
         X[M] /* D=Relays a task to the relay server

     The following arguments are required:
       \$data: The db object
       \$num: Assist number
       \$queue: The queue

*/

string queue;
mapping assist;

if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if (!assist::dogetassist(\$num: \$num)) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if (!member(\$num, map_indices(\$data."mapping:assists:open"))) \{
  EmitTo(\$actor, "Task #" + \$num + " is closed and cannot be relayed to another server.");
  return FALSE;
\}

assist = assist::dogetassist(\$num: \$num);
queue  = assist["Queue"];

if (!member(assist["Queue"], map_indices(\$data."mapping:queues:relay"))) \{
  EmitTo(\$actor, "No relay setup for the queue the task supplied is in.");
  return FALSE;
\}

if (member(assist["Queue"], \$data."array:queues:locked") \&\& \$actor."udat:host" == 0) \{
  EmitTo(\$actor, "That task is in a locked queue. You are not allowed to relay tasks in a locked queue.");
  return FALSE;
\}

if (member(Str(\$num), map_values(\$data."mapping:assistee"))) \{
  EmitTo(\$actor, "You may not relay that task because it is currently claimed.");
  return FALSE;
\}


  \$oldqueue = assist["Queue"];

  \$server = \$data."mapping:queues:relay"[queue];
  \$id     = assist["Theatre"] + "@" + assist["Server"] + "-" + Str(\$num) + "!" + \$server;
  \$notes  = assist["Notes"];
  assist["Notes"] = nil;
  \$note   = "!TAS! (" + short_time(time()) + "): This task has been transfered to server '" + capitalize(\$server) + "' with ID '" + \$id + "'.\\n\\n";
  \$note  += "!TAS! (" + short_time(time()) + "): Original Filer: " + ((\$r1 = Obj(assist["Character"])) ? Describe(Obj(assist["Character"])) : "unknown") + " " + dump_value(assist["Character"]) + "\\n\\n";
  if (strlen(\$notes) \< 1) \{
    assist += ([ "Notes":\$note ]);
  \} else \{
    \$note = \$notes + \$note;
    assist += ([ "Notes":\$note ]);
  \}
  assist::dosetassist(\$num: \$num, \$assist: assist);
  Call(\$\{SkotOS:Assistd\}, "transfer_data", \$server: \$server, \$id: \$id, \$transfer_data: assist);

  assist::doclaim(\$data: \$data, \$num: \$num, \$cmd: \$cmd, \$silent: "true");
  if (\$ok) \{
    assist::dodone(\$data: \$data, \$msg: "Transfer Close", \$silent: "true");
  \}

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"\<#" + \$num + "/" + capitalize(\$oldqueue) + "\> relayed to server '" + capitalize(\$server) + "' by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: queue, \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doremovequeue">
         X[M] /* D=Remove a Queue if it does not exist

     The following arguments are required:
       \$data: The data object
       \$queue: Name of the queue

*/

string *queues, queue;

queues = \$data."array:queues";
queue = lower_case(\$queue);

if (member(queue, \$data."array:queues:system")) \{
  EmitTo(\$actor, "The CE and NEW queue are system queues and may not be added or removed.");
  return FALSE;
\}

if (!member(queue, queues)) \{
  EmitTo(\$actor, "The queue (" + capitalize(queue) + ") does not exist.");
  return FALSE;
\}

if (sizeof(Get(\$data, "array:open:" + queue)) != 0) \{
  EmitTo(\$actor, "There are still open tasks in the queue. Transfer or finish those tasks before removing this queue.");
  return FALSE;
\}

if (sizeof(Get(\$data, "array:claimed:" + queue)) != 0) \{
  EmitTo(\$actor, "There are still claimed tasks in the queue. Transfer or finish those tasks before removing this queue.");
  return FALSE;
\}

if (member(queue, map_indices(\$data."mapping:subqueues"))) \{
  \$subq = \$data."mapping:subqueues"[queue];
  \$data."mapping:subqueues"[queue] = nil;
  \$sublist = Get(\$data, "array:subqueues:" + \$subq);
  \$sublist -= (\{ queue \});
  Set(\$data, "array:subqueues:" + \$subq, \$sublist);

\}

if (Get(\$data, "array:subqueues:" + queue)) \{
  \$sublist = Get(\$data, "array:subqueues:" + queue);
  for (\$f = 0; \$f \< sizeof(\$sublist); \$f++) \{
    if (\$subq) \{
      \$data."mapping:subqueues"[\$sublist[\$f]] = nil;
      \$data."mapping:subqueues" += ([ \$sublist[\$f]:\$subq ]);
      \$subt = Get(\$data, "array:subqueues:" + \$subq);
      \$subt += (\{ \$sublist[\$f] \});
      Set(\$data, "array:subqueues:" + \$subq, \$subt);
    \} else \{
      \$data."mapping:subqueues"[\$sublist[\$f]] = nil;
    \}
  \}
  Set(\$data, "array:subqueues:" + queue, nil);
\}

\$data."array:queues" -= (\{ queue \});

Set(\$data, "array:claimed:" + queue, nil);
Set(\$data, "array:open:" + queue, nil);


if (Get(\$data, "array:subqueues:" + queue)) \{ Set(\$data, "array:subqueues:" + queue, nil); \}
if (member(queue, \$data."array:queues:locked")) \{ \$data."array:queues:locked" -= (\{ queue \}); \}
if (member(queue, map_indices(\$data."mapping:queues:private"))) \$data."mapping:queues:private"[queue] = nil;


\$forwards = copy(\$data."mapping:queues:forward");
\$forward  = copy(\$data."mapping:queues:forward");
\$indices  = map_indices(\$forwards);
\$sz_i     = sizeof(\$indices);

for (\$i = 0; \$i \< \$sz_i; \$i++) \{
  \$key = \$forwards[\$indices[\$i]];
  if (\$key == queue) \$forward[\$indices[\$i]] = nil;
\}

\$data."mapping:queues:forward" = \$forward;

/*
\$forward = \$actor."udat:name" + "@" + "task" + "@" + \$actor."theatre:id";
if (\$data."mapping:queues:forward"[\$forward]) \$data."mapping:queues:forward"[\$forward] = nil;

if (member(queue, map_indices(reverse_mapping(\$data."mapping:queues:forward")))) \$data."mapping:queues:forward"[reverse_mapping(\$data."mapping:queues:forward")[queue]] = nil;
*/

\$alert = smalltime(time()) + spaces(1) + \$tas + spaces(1) + "\\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) + " has removed the queue " + capitalize(queue) + ".\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: queue, \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dorename">
         X[M] /* D=Renames a queue and all assists that were members of that queue.

     The following arguments are required:
       \$data: The db object
       \$list: An array of words

*/

\$queues = \$data."array:queues";

\$queue1 = lower_case(\$list[1]);
\$queue2 = lower_case(\$list[2]);

if (!member(\$queue1, \$queues)) \{
  EmitTo(\$actor, "You supplied an invalid queue to rename.");
  return FALSE;
\}

if (member(\$queue1, \$data."array:queues:system")) \{
  EmitTo(\$actor, "You may not rename a system queue.");
  return FALSE;
\}

if (member(\$queue2, \$queues)) \{
  EmitTo(\$actor, "You cannot rename the queue to \\"" + \$queue2 + "\\" as it is already a queue in the system.");
  return FALSE;
\}

if (sscanf(\$queue2, "%d%s", \$number, \$dummy) == 2 \|\| sscanf(\$queue2, "%s%d", \$dummy, \$number) == 2 \|\| sscanf(\$queue2, "%s%d%s", \$dummya, \$number, \$dummyb) == 2) \{

  EmitTo(\$actor, "Queue names can not contain numbers.");
  return FALSE;
\}

if (member(\$queue2, \$data."array:badnames")) \{
  EmitTo(\$actor, "You cannot rename the queue to \\"" + \$queue2 + "\\". It is on the badname list.");
  return FALSE;
\}

if (strlen(\$queue2) \> 20) \{
  EmitTo(\$actor, "The queue name must be 20 characters or less.");
  return FALSE;
\}

if (Get(\$data, "array:subqueues:" + \$queue1) \&\& sizeof(Get(\$data, "array:subqueues:" + \$queue1)) \< 1) Set(\$data, "array:subqueues:" + \$queue1, nil);

if (member(\$queue1, \$data."array:queues:locked")) \{
  \$data."array:queues:locked" -= (\{ \$queue1 \});
  \$data."array:queues:locked" += (\{ \$queue2 \});
\}

if (member(\$queue1, map_indices(\$data."mapping:subqueues"))) \{
  \$subqueue = \$data."mapping:subqueues"[\$queue1];
  \$sublist = Get(\$data, "array:subqueues:" + \$subqueue);
  \$sublist -= (\{ \$queue1 \});
  \$sublist += (\{ \$queue2 \});
  Set(\$data, "array:subqueues:" + \$subqueue, \$sublist);
  \$data."mapping:subqueues"[\$queue1] = nil;
  \$data."mapping:subqueues" += ([ \$queue2:\$subqueue ]);

  if (Get(\$data, "array:subqueues:" + \$queue1)) \{
    \$qlist = Get(\$data, "array:subqueues:" + \$queue1);
    for (\$x = 0; \$x \< sizeof(\$qlist); \$x++) \{
      \$data."mapping:subqueues"[\$qlist[\$x]] = nil;
      \$data."mapping:subqueues" += ([ \$qlist[\$x]:\$queue2 ]);
    \}
    Set(\$data, "array:subqueues:" + \$queue1, nil);
    Set(\$data, "array:subqueues:" + \$queue2, \$qlist);
  \}
\}

Set(\$data, "array:open:" + \$queue2, copy(Get(\$data, "array:open:" + \$queue1)));
Set(\$data, "array:claimed:" + \$queue2, copy(Get(\$data, "array:claimed:" + \$queue1)));
Set(\$data, "array:open:" + \$queue1, nil);
Set(\$data, "array:claimed:" + \$queue1, nil);
\$data."array:queues" -= (\{ \$queue1 \});
\$data."array:queues" += (\{ \$queue2 \});

if (\$data."mapping:queues:private"[\$queue1]) \{
  \$key = \$data."mapping:queues:private"[\$queue1];
  \$data."mapping:queues:private"[\$queue1] = nil;
  \$data."mapping:queues:private" += ([ \$queue2:\$key ]);
\}

\$tempmap = copy(\$data."mapping:queues:forward");
\$mapping = copy(\$data."mapping:queues:forward");

for (\$i = 0; \$i \< map_sizeof(\$data."mapping:queues:forward"); \$i++) \{
  \$key   = map_indices(\$mapping)[\$i];
  \$value = \$mapping[\$key];
  if (\$value == \$queue1) \{
    \$tempmap[\$value] = nil;
    \$tempmap        += ([ \$key:\$queue2 ]);
  \}
\}

\$data."mapping:queues:forward" = \$tempmap;

/*
if (reverse_mapping(\$data."mapping:queues:forward")[\$queue1]) \{
  \$key = reverse_mapping(\$data."mapping:queues:forward")[\$queue1];
  \$data."mapping:queues:forward"[\$key] = nil;
  \$data."mapping:queues:forward" += ([ \$key:\$queue2 ]);
\}
*/

if (\$data."mapping:queues:email"[\$queue1]) \{
  \$group = \$data."mapping:queues:email"[\$queue1];
  \$data."mapping:queues:email"[\$queue1] = nil;
  \$data."mapping:queues:email" += ([ Str(\$queue2):Str(\$group) ]);
\}

\$open = copy(\$data."mapping:assists:open");
\$indices = map_indices(\$open);
\$change = (\{ \});

for (\$i = 0; \$i \< sizeof(\$indices); \$i++) \{
  \$cur = \$open[\$indices[\$i]];
  if (\$cur == \$queue1) \{
    \$change += (\{ \$indices[\$i] \});
  \}
  \$delay(0.1, FALSE, "abb9");
\}

for (\$i = 0; \$i \< sizeof(\$change); \$i++) \{
  \$open[\$change[\$i]] = nil;
  \$open += ([ \$change[\$i]:\$queue2 ]);
  \$delay(0.1, FALSE, "d306");
\}

\$data."mapping:assists:open" = \$open;

for (\$i = \$data."assist:current"; \$i \> 0; \$i--) \{
  \$assist = copy(assist::dogetassist(\$num: \$i));
  if (\$assist["Queue"] == \$queue1) \{
    \$assist["Queue"] = nil;
    \$assist += ([ "Queue":\$queue2 ]);

    assist::dosetassist(\$num: \$i, \$assist: \$assist);

  \}
  \$delay(0.1, FALSE, "cc3e");
\}

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"Queue " + capitalize(\$queue1) + " renamed to " + capitalize(\$queue2) + " by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "misc", \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));
      </Core:Property>
      <Core:Property property="merry:lib:doretrieve">
         X[M] /* D=Retrieve an assist and dump it back into the new queue to be dealt with as appropriate.

     The following arguments are required:
       \$data: The db object
       \$num: The assist number

*/




if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

\$assist = assist::dogetassist(\$num: \$num);

if (strlen(\$assist["TimeClosed"]) \< 1) \{
  EmitTo(\$actor, "Assist #" + \$num + " is currently an open task. You can only retrieve closed tasks.");
  return FALSE;
\}

if (member(\$assist["Queue"], \$data."array:queues:locked") \&\& \$actor."udat:host" == 0) \{
  EmitTo(\$actor, "That task is in a locked queue. You may not retrieve tasks that are part of a locked queue.");
  return FALSE;
\}

\$assist["TimeClosed"] = nil;
\$assist["TimeClaimed"] = nil;
\$assist["Assistee"] = nil;
\$assist["Queue"] = nil;
\$assist["Flag"] = nil;

\$assist += ([ "TimeClosed":"", "TimeClaimed":"", "Assistee":"", "Queue":"new", "Flag":"" ]);

assist::dosetassist(\$num: \$num, \$assist: \$assist);

\$data."array:open:new" += (\{ Int(\$num) \});
\$data."mapping:assists:open" += ([ Str(\$num):"new" ]);

\$oldbody = Call(\$\{UserAPI:UDatD\}, "query_udat", \$name: \$assist["Account"]);

if (\$oldbody) \{
  \$oldbody."array:assists" += (\{ Int(\$num) \});
\} else \{
  if(!\$actor."array:assists") \{
    \$actor."array:assists" = (\{ Int(\$num) \});
  \} else \{
    \$actor."array:assists" += (\{ Int(\$num) \});
  \}
\}

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"\<#" + \$num + "/New\> retrieved by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + "." + (!\$oldbody ? " Original filer account no longer exists. Task linked to retrievers account.\\"" :  "\\"");

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: "new", \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doreturn">
         X[M] /* D=Return your assist back to the queue it came from

     The following arguments are required:
       \$data: The db object

*/

string num, queue;
mapping assist;


if (!member(\$actor."skotos:creator", map_indices(\$data."mapping:assistee"))) \{
  EmitTo(\$actor, "You do not have a task claimed. You cannot return what you do not have.");
  return FALSE;
\}

num = \$data."mapping:assistee"[\$actor."skotos:creator"];

assist = assist::dogetassist(\$num: num);
queue = assist["Queue"];

assist["Assistee"] = nil;
assist += ([ "Assistee":"" ]);
assist["TimeClaimed"] = nil;
assist += ([ "TimeClaimed":"" ]);

assist::dosetassist(\$num: num, \$assist: assist);

Set(\$data, "array:open:" + queue, Get(\$data, "array:open:" + queue) + (\{ Int(num) \}));

Set(\$data, "array:claimed:" + queue, Get(\$data, "array:claimed:" + queue) - (\{ Int(num) \}));

\$data."mapping:assistee"[\$actor."skotos:creator"] = nil;

assist::docreatestats(\$data: \$data, \$action: "returned");

\$alert = smalltime(time())+ spaces(1) + \$tas + " \\"\<#" + num + "/" + capitalize(queue) + "\> returned by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: queue, \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));
      </Core:Property>
      <Core:Property property="merry:lib:doschedule">
         X[M] /* D=Sticks a task to the specified calendar date

    The following arguments are required:
      \$task : The task number
      \$day : The day to link it to
      \$month : The month to link it to

    The following arguments are optional:
      \$year : The year to link it to
*/

\{

mixed task;
int valid, dayone, *arr_tasks;
object udat_obj;
mapping calist, map_cal;

  udat_obj = Call(\$\{UserAPI:UDatD\}, "query_udat", \$name: \$actor."udat:name");

  if (!\$task \|\| !\$day \|\| !\$month) \{
    EmitTo(\$actor, "You must supply a task number, date and month.");
    return FALSE;
  \}

  if ((catch(Int(\$task)) ? 0 : 1) == 0) \{
    EmitTo(\$actor, "You must supply a valid task number.");
    return FALSE;
  \}

  task = Int(\$task);

  if (task \< 1 \|\| task \> \$data."assist:current") \{
    EmitTo(\$actor, "The task you supplied is out of range.");
    return FALSE;
  \}

  valid = common::reverse_ctime(\$day: \$day, \$month: \$month, \$year: (\$year ? \$year : ctime(time())[20..]));

  if (valid \< 20) \{
    EmitTo(\$actor, "The day, month or year you supplied is not valid.");
    return FALSE;
  \}

  dayone = common::reverse_ctime(\$year: (\$year ? \$year : ctime(time())[20..]), \$month: \$month, \$day: 1);
  calist = udat_obj."tas:calendar";
  task = Str(task);

  if (!calist) \{
    udat_obj."tas:calendar" = ([ dayone:([ valid:(\{ task \}) ]) ]);
    EmitTo(\$actor, "You shall be notifed on " + humanized_date(valid) + " about task #" + Str(task) + ".");
    return FALSE;
  \}

  if (!calist[dayone]) \{
    udat_obj."tas:calendar" += ([ dayone:([ valid:(\{ task \}) ]) ]);
    EmitTo(\$actor, "You shall be notifed on " + humanized_date(valid) + " about task #" + Str(task) + ".");
    return FALSE;
  \}

  map_cal = calist[dayone];

  if (map_cal[valid] \&\& member(task, map_cal[valid])) \{
    EmitTo(\$actor, "You have already stuck task #" + Str(task) + " to " + humanized_date(valid) + ".");
    return FALSE;
  \}

  arr_tasks = map_cal[valid];
  if (!arr_tasks) \{
    arr_tasks = (\{ task \});
  \} else \{
    arr_tasks += (\{ task \});
  \}
  map_cal[valid] = nil;
  map_cal += ([ valid:arr_tasks ]);
  calist[dayone] = nil;
  calist += ([ dayone:map_cal ]);
  udat_obj."tas:calendar" = calist;

  EmitTo(\$actor, "You shall be notifed on " + humanized_date(valid) + " about task #" + Str(task) + ".");
  return FALSE;
\}
      </Core:Property>
      <Core:Property property="merry:lib:dosearch">
         X[M] /* D=Searches all assists for string.

     The following arguments are required:
       \$term: The string to search for

*/



\$searchdb = Obj("Data:DB:assist:AssistSearchDB");
\$words = \$words[1..];
\$started = time();

catch \{
    \$searchdb."stats:search" = Int(\$searchdb."stats:search") + 1;
\}

if (sizeof(\$words) \> 1) \{
  if (sizeof(\$words) % 2 == 0) \{
    \$words -= (\{ sizeof(\$words) \});
  \}

  \$term = lower_case(\$words[0]);

  if (strlen(\$term) \> 3) \{
    \$letter = \$term[0..0];
    \$map    = Get(\$searchdb, "mapping:" + \$letter);
    if (\$map) \$tasks  = get_by_str(\$map, \$term);
    if (\$map \&\& \$tasks) \{
      if (typeof(\$tasks) == T_STRING) \{
        \$andlist = ::search_decode(\$data: \$tasks);
      \} else \{
        \$andlist = map_indices(\$tasks);
      \}
    \} else \{
      \$andlist = (\{ \});
    \}
  \} else \{
    \$andlist = (\{ \});
  \}
  \$notlist = (\{ \});
  \$sz      = sizeof(\$words);
  \$tasks   = nil;
  \$map     = nil;
  \$letter  = nil;

  for (\$z = 1; \$z \< \$sz; \$z = \$z + 2) \{
    \$term = lower_case(\$words[\$z]);
    if (\$term == "and") \{
      \$term   = lower_case(\$words[\$z + 1]);
      if (strlen(\$term) \< 4) \{
        continue;
      \}
      \$letter = \$term[0..0];
      \$map    = Get(\$searchdb, "mapping:" + \$letter);
      if (\$map) \$tasks  = get_by_str(\$map, \$term);
      if (\$map \&\& \$tasks) \{
        if (typeof(\$tasks) == T_STRING) \{
          \$andlist \&= ::search_decode(\$data: \$tasks);
        \} else \{
          \$andlist \&= map_indices(\$tasks);
        \}
      \} else \{
        \$andlist = (\{ \});
        break;
      \}
    \} else if (\$term == "not") \{
      \$term   = lower_case(\$words[\$z + 1]);
      if (strlen(\$term) \< 4) \{
        continue;
      \}
      \$letter = \$term[0..0];
      \$map    = Get(\$searchdb, "mapping:" + \$letter);
      if (\$map) \$tasks  = get_by_str(\$map, \$term);
      if (\$map \&\& \$tasks) \{
        if (typeof(\$tasks) == T_STRING) \{
          \$notlist \|= ::search_decode(\$data: \$tasks);
        \} else \{
          \$notlist \|= map_indices(\$tasks);
        \}
      \}
    \}
    \$map    = nil;
    \$tasks  = nil;
    \$letter = nil;
    \$term   = nil;
    /* \$delay(0.25, FALSE, "55c9"); */
  \}
  \$ints = \$andlist - \$notlist;
\} else \{
  \$term   = lower_case(\$words[0]);
  if (strlen(\$term) \> 3) \{
    \$letter = \$term[0..0];
    \$map    = Get(\$searchdb, "mapping:" + \$letter);
    if (\$map) \$tasks  = get_by_str(\$map, \$term);
    if (\$map \&\& \$tasks) \{
      if (typeof(\$tasks) == T_STRING) \{
        \$ints = ::search_decode(\$data: \$tasks);
      \} else \{
        \$ints = map_indices(\$tasks);
      \}
    \}
  \}
\}

if (\$socialcheck) \{
  return \$ints;
\}

if (\$ints) \{
  \$outp = "";
  if (sizeof(\$ints) \> 100) \{
    \$div = sizeof(\$ints) / 100;
    \$rem = sizeof(\$ints) % 100;
    for (\$l = 0; \$l \< \$div; \$l++) \{
      \$assists = \$ints[(\$l == 0 ? 0 : \$l * 100)..(\$l == 0 ? 99 : (\$l * 100) + 99)];
      \$outp += assist::docurrent(\$data: \$data, \$key: "recap", \$list: \$assists, \$search: "true");
    \}
    if (\$rem) \{
      \$assists = \$ints[(\$l * 100)..sizeof(\$ints) -1];
      \$outp += assist::docurrent(\$data: \$data, \$key: "recap", \$list: \$assists, \$search: "true");
    \}
  \} else \{
    \$outp += assist::docurrent(\$data: \$data, \$key: "recap", \$list: \$ints, \$search: "true");
  \}
  \$outp += "\\n" + ("Search Started: " + spaces(20))[..17] + ctime(\$started) + ("\\nSearch Ended: " + spaces(20))[..18] + ctime(time()) + ("\\nReal Search Time: " + spaces(20))[..18] + common::convsecs(\$secs: (time() - \$started)) + ("\\nResults Matched: " + spaces(20))[..18] + sizeof(\$ints)+"/"+\$data."assist:current";
  common::more(\$text: \$outp, \$pre: TRUE);
  return FALSE;
\}

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"Search begun for term (" + \$term + "). This search shall take approximately " + Flt(\$data."assist:current") * Flt(0.05) + " seconds.\\"";

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

\$assists = (\{ \});
\$gtotal = 0;
\$started = time();

for (\$i = \$data."assist:current"; \$i \> 0 \&\& !\$actor."tas:abort" \&\& \$actor."udat:possessed"; \$i--) \{
  \$test = contains(lower_case(replace_strings(mixed_to_ascii(map_values(assist::dogetassist(\$num: \$i))), "\\"", "")), \$term);
  if (\$test == 1) \{
    \$assists += (\{ \$i \});
    \$gtotal++;
  \}
  \$delay(0.01, FALSE, "148c");
  if (sizeof(\$assists) == 100) \{
   \$append = "true";
   assist::docurrent(\$data: \$data, \$key: "recap", \$list: \$assists);
    \$assists = (\{ \});
  \}
\}



assist::docurrent(\$data: \$data, \$key: "recap", \$list: \$assists, \$issearch: "true");

EmitTo(\$actor, PRE(("Search Started: " + spaces(20))[..17] + ctime(\$started) + ("\\nSearch Ended: " + spaces(20))[..18] + ctime(time()) + ("\\nReal Search Time: " + spaces(20))[..18] + common::convsecs(\$secs: (time() - \$started)) + ("\\nResults Matched: " + spaces(20))[..18] + \$gtotal+"/"+\$data."assist:current"));

\$actor."tas:abort" = nil;

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dosendemail">
         X[M] /* D=Sends an email for special queues as defined in mapping:queues:email

     The following arguments are required:
       \$data: The db object
       \$num: The assist number
       \$queue: The queue being transfered to.

*/

\$group = Str(\$data."mapping:queues:email"[\$queue]);

\$success = Call(\$\{SkotOS:Assistd\}, "list", \$callback: "list_results");

if (\$success == 0) \{
  EmitTo(\$actor, TAG(smalltime(time()) + spaces(1) + \$tas + " \\"There was an error while trying to escalate this task. Please try again shortly.", "assist-alert"));
  return FALSE;
\}

\$success = Call(\$\{SkotOS:Assistd\}, "query", \$group: \$group, \$callback: "query_results");

if (\$success == 0) \{
  EmitTo(\$actor, TAG(smalltime(time()) + spaces(1) + \$tas + " \\"There was an error while trying to escalate this task. Please try again shortly.", "assist-alert"));
  return FALSE;
\}

\$assist = assist::dogetassist(\$num: \$num);

\$char = Str(\$assist["CharObj"]);

\$subject = "[" + capitalize(\$assist["Queue"]) + ":" + capitalize(((\$r1 = \$assist["Server"]) ? \$r1 : "?server?")) + "] #" + \$num + "/" + common::get_name(\$src: Obj(\$char));

\$body = "Task Filed By: " + common::get_name(\$src: Obj(\$char)) + spaces(1) + dump_value(Obj(\$char)) + "\\nAccount: " + ((\$r1 = \$assist["Account"]) ? \$r1 : ((\$r2 = Obj(\$char)."skotos:creator") ? \$r2 : "Account Unknown")) + "\\nTask Filed At: " + humanized_date(Int(\$assist["TimeFiled"])) + "\\nTask Transfered At: " + humanized_date(time()) + "\\n\\nTask Message: " + \$assist["AssistText"] + "\\n\\nAdditional Notes: " + \$assist["Notes"] + "\\n\\n[Automated Task Message Email]\\n";

\$success = Call(\$\{SkotOS:Assistd\}, "send", \$group: \$group, \$subject: \$subject, \$body: \$body, \$callback: "send_results");

if (\$success == 0) \{
  EmitTo(\$actor, TAG(smalltime(time()) + spaces(1) + \$tas + " \\"There was an error while trying to escalate this assist. Please try again shortly.", "assist-alert"));
  return FALSE;
\}

return \$success;
      </Core:Property>
      <Core:Property property="merry:lib:dosetassist">
         X[M] /* D=Creates a new assist. Sets it in the appropriate DB. Creates a new DB if necessary.

     The following arguments are required:
       \$num: Number of the assist
       \$assist: The assist array

*/

int db;
mixed obj, *assist;
string queue;

db = Int(\$num) / 1000;
obj = "Data:DB:assist:AssistDB" + Str(db);

if (!Obj(obj)) \{
  \$newdb = Duplicate(\$\{Data:DB:assist:AssistDBTemplate\});
  \$newdb."base:objectname" = obj;
\}

obj = Obj(obj);

if (\$assist["RevTime"] == nil) \{
  \$assist += ([ "RevTime":Str(time()) ]);
\} else \{
  \$assist["RevTime"] = nil;
  \$assist += ([ "RevTime":Str(time()) ]);
\}

if (\$assist["Rev"] == nil) \{
  \$assist += ([ "Rev":1.0 ]);
\} else \{
  \$rev = \$assist["Rev"];
  \$rev = \$rev + 0.1;
  \$assist["Rev"] = nil;
  \$assist += ([ "Rev":\$rev ]);
\}

Set(obj, "assist:" + \$num, \$assist);
Set(obj, "#timestamp.lastupdate#", time());

queue = \$assist["Queue"];

if (\$data."mapping:queues:timestamp"[queue]) \{
  \$data."mapping:queues:timestamp"[queue] = nil;
  \$data."mapping:queues:timestamp" += ([ queue:time() ]);
\} else \{
  \$data."mapping:queues:timestamp" += ([ queue:time() ]);
\}

assist::docreatesearchdb(\$num: Int(\$num));
      </Core:Property>
      <Core:Property property="merry:lib:dosettype">
         X[M] /* D=Switches a queue between long and short format

    The following arguments are required:
      \$queue: The queue

*/

string queue, *queues, *news;

queue = lower_case(\$queue);
queues = \$data."array:queues";
news = \$data."array:queues:news";

if (!member(queue, queues)) \{
  EmitTo(\$actor, "That is not a valid queue.");
  return FALSE;
\}

if (member(queue, news)) \{
  \$data."array:queues:news" -= (\{ queue \});
  \$alert = smalltime(time())+ spaces(1) + \$tas + " \\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) + " has changed the output format of the " + capitalize(queue) + " queue to long.\\"";
  EmitTo(\$actor, TAG(\$alert, "assist-alert"));
  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: queue, \$exclude: (\{ \$actor \}));
  return FALSE;
\} else \{
  \$data."array:queues:news" += (\{ queue \});
  \$alert = smalltime(time())+ spaces(1) + \$tas + " \\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) + " has changed the output format of the " + capitalize(queue) + " queue to short.\\"";
  EmitTo(\$actor, TAG(\$alert, "assist-alert"));
  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: queue, \$exclude: (\{ \$actor \}));
  return FALSE;
\}
      </Core:Property>
      <Core:Property property="merry:lib:doshift">
         X[M] /* D=Shifts alert status from character A to character B

Is task number valid?
Is character name valid?
Is task an open task?

Get filers UDat object
Is # in the array:assists?

Remove from filders udat array:assists

Get new characters UDat object
Add to array:assists

Alert chatline

Done

*/


int num;
object oldbody, newbody, oldbody_udat, newbody_udat;
mapping assist;
string oldbody_acct;

\{

  if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
    EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
    return FALSE;
  \}


  num = Int(\$num);

  if (num \< 0 \|\| num \> Int(\$data."assist:current")) \{
    EmitTo(\$actor, "You supplied an invalid (" + Str(num) + ") task number.");
    return FALSE;
  \}

  newbody = common::lookup(\$name: \$name);

  if (!newbody) \{
    EmitTo(\$actor, "You supplied an invalid character name to shift the alert to.");
    return FALSE;
  \}

  if (!member(Str(num), map_indices(\$data."mapping:assists:open"))) \{
    EmitTo(\$actor, "Task #" + Str(num) + " is not an open task. Cannot shift alert status.");
    return FALSE;
  \}

  assist       = assist::dogetassist(\$num: Str(num));
  if (assist["AlertShift"] \&\& assist["AlertShift"] != "") \{
    oldbody_udat = Call(\$\{UserAPI:UDatD\}, "query_udat", \$name: assist["AlertShift"]);
    oldbody_acct = assist["AlertShift"];
  \} else \{
    oldbody_udat = Call(\$\{UserAPI:UDatD\}, "query_udat", \$name: assist["Account"]);
    oldbody_acct = assist["Account"];
  \}
  newbody_udat = Call(\$\{UserAPI:UDatD\}, "query_udat", \$name: newbody."skotos:creator");

  if (!oldbody_udat) \{
    EmitTo(\$actor, "I am unable to locate a udat object for account: " + assist["Account"]);
    return FALSE;
  \}

  if (!newbody_udat) \{
    EmitTo(\$actor, "I am unable to locate a udat object for account: " + newbody."skotos:creator");
    return FALSE;
  \}

  if (!member(num, oldbody_udat."array:assists")) \{
    EmitTo(\$actor, "It does not appear that task #" + Str(num) + " is an open task for account: " + assist["Account"]);
    return FALSE;
  \}

  oldbody_udat."array:assists" -= (\{ num \});

  if (!newbody_udat."array:assists") \{
    newbody_udat."array:assists" = (\{ num \});
  \} else \{
    newbody_udat."array:assists" += (\{ num \});
  \}

  if (assist["AlertShift"]) \{
    assist["AlertShift"] = nil;
    assist += ([ "AlertShift":newbody."skotos:creator" ]);
  \} else \{
    assist += ([ "AlertShift":newbody."skotos:creator" ]);
  \}

  \$notes = assist["Notes"];
  \$alertmsg = "!TAS! (" + short_time(time()) + "): Alert status shifted from account \\'" + oldbody_acct + "\\' to account \\'" + newbody."skotos:creator" + "\\' by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\n\\n";
  \$notes += \$alertmsg;

  assist["Notes"] = nil;
  assist += ([ "Notes":\$notes ]);

  assist::dosetassist(\$num: Str(num), \$assist: assist);

  \$alert = smalltime(time()) + spaces(1) + \$tas + " \\"\<#" + num + "/" + capitalize(assist["Queue"]) + "\> alert status shifted from account \\'" + oldbody_acct + "\\' to account \\'" + newbody."skotos:creator" + "\\' by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: assist["Queue"], \$exclude: (\{ \$actor \}));

  EmitTo(\$actor, TAG(\$alert, "assist-alert"));

\}
      </Core:Property>
      <Core:Property property="merry:lib:doshortclosed">
         X[M] /* D=Shows all closed assists for queue

     The following arguments are required:
       \$data: The db object
       \$queue: The queue

     The following arguments are optional:
       \$count: If provided, determines how many to show.

*/

int x;

\$total = 0;
\$tasklist = (\{ \});

if (!\$count) \{
  \$count = \$data."assist:current";
\} else \{
  \$count = Int(\$count);
\}

\$player = common::lookup(\$name: \$queue);
\$que = member(\$queue, \$data."array:queues");

if (\$que) \{
  for (x = \$data."assist:current"; x \> 0 \&\& \$total \< \$count; x--) \{
    \$assist = assist::dogetassist(\$num: x);
    if (\$assist["Queue"] == lower_case(\$queue) \&\& \$assist["TimeClosed"] != "") \{
      \$tasklist += (\{ x \});;
      \$total++;
    \}
  \}
  assist::docurrent(\$data: \$data, \$key: "recap", \$list: \$tasklist, \$issearch: "true");
\} else if (\$player) \{
    for (x = \$data."assist:current"; x \> 0 \&\& \$total \< \$count; x--) \{
    \$assist = assist::dogetassist(\$num: x);
    if (\$assist["Character"] == Str(\$player) \&\& \$assist["TimeClosed"] != "") \{
      \$tasklist += (\{ x \});
      \$total++;
    \}
  \}
  assist::docurrent(\$data: \$data, \$key: "recap", \$list: \$tasklist, \$issearch: "true");
\} else \{
  EmitTo(\$actor, "I am unable to find a queue or a player by that name.");
\}

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doshowall">
         X[M] /* D= Shows info for all assists in queue

     The following arguments are required:
       \$data: The db object.
       \$queue: The queue

     The following arguments are optional:
       \$assists: An array of assists to use

*/

string info;
int *assists, q;

if (!member(lower_case(\$queue), \$data."array:queues")) \{
  EmitTo(\$actor, "I am unable to find that queue.");
  return FALSE;
\}

if (!\$assists) \{
assists = Get(\$data, "array:open:" + lower_case(\$queue));
assists += Get(\$data, "array:claimed:" + lower_case(\$queue));
\} else \{
  assists = \$assists;
\}

if (sizeof(assists) \< 1) \{
  EmitTo(\$actor, "There are no tasks in queue " + capitalize(\$queue) + ".");
  return FALSE;
\}

for (q = 0; q \< sizeof(assists); q++) \{
  info = assist::doinfo(\$num: Str(assists[q]));
\}

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doshowclosed">
         X[M] /* D=Shows all closed assists for queue

     The following arguments are required:
       \$data: The db object
       \$queue: The queue

     The following arguments are optional:
       \$count: If provided, determines how many to show.

*/

int x;

\$total = 0;

if (!\$count) \{
  \$count = \$data."assist:current";
\} else \{
  \$count = Int(\$count);
\}

\$player = common::lookup(\$name: \$queue);
\$que = member(\$queue, \$data."array:queues");

if (\$que) \{
  for (x = \$data."assist:current"; x \> 0 \&\& \$total \< \$count; x--) \{
    \$assist = assist::dogetassist(\$num: x);
    if (\$assist["Queue"] == lower_case(\$queue) \&\& \$assist["TimeClosed"] != "") \{
      assist::doinfo(\$num: x);
      \$total++;
    \}
  \}
\} else if (\$player) \{
    for (x = \$data."assist:current"; x \> 0 \&\& \$total \< \$count; x--) \{
    \$assist = assist::dogetassist(\$num: x);
    if (\$assist["Character"] == Str(\$player) \&\& \$assist["TimeClosed"] != "") \{
      assist::doinfo(\$num: x);
      \$total++;
    \}
  \}
\} else \{
  EmitTo(\$actor, "I am unable to find a queue or a player by that name.");
\}

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:doslide">
         X[M] /* D=Moves a queue into a subqueue

    The following arguments are required:
      \$queue - The queue you are moving
      \$subqueue - THe queue you are moving it into

*/

\$queue = lower_case(\$queue);
\$subqueue = lower_case(\$subqueue);

if (!member(\$queue, \$data."array:queues")) \{
  EmitTo(\$actor, "You have selected an invalid queue.");
  return FALSE;
\}

if (!member(\$subqueue, \$data."array:queues") \&\& \$subqueue != "general") \{
  EmitTo(\$actor, "You have selected an invalid subqueue.");
  return FALSE;
\}

/*
if (member(\$queue, \$data."array:queues:system")) \{
  EmitTo(\$actor, "You may not move a system queue into a subqueue.");
  return FALSE;
\}
*/

if (\$subqueue == \$queue) \{
  EmitTo(\$actor, "You may not move a queue into itself.");
  return FALSE;
\}

if (\$subqueue == "general") \{
  if (!\$data."mapping:subqueues"[\$queue]) \{
    EmitTo(\$actor, "Queue is already a member of the general subqueue.");
    return FALSE;
  \}

  /* Remove queue from previous subqueue list */
  \$old = Get(\$data, "array:subqueues:" + \$data."mapping:subqueues"[\$queue]);
  \$old -= (\{ \$queue \});
  Set(\$data, "array:subqueues:" + \$data."mapping:subqueues"[\$queue], \$old);

  /* Remove queue from subqueue mapping */
  \$map = \$data."mapping:subqueues";
  if (\$map) \{
    \$map[\$queue] = nil;
    \$data."mapping:subqueues" = \$map;
  \}

  \$alert = smalltime(time()) + spaces(1) + \$tas + " \\"" + capitalize(\$queue) + " has been moved into the General parent queue by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: \$queue, \$exclude: (\{ \$actor \}));

  EmitTo(\$actor, TAG(\$alert, "assist-alert"));

  return FALSE;
\}

if (!\$data."mapping:subqueues"[\$queue]) \{
  /* Add queue to new subqueue list */
  \$new = Get(\$data, "array:subqueues:" + \$subqueue);
  if (\$new) \{
    \$new += (\{ \$queue \});
  \} else \{
    \$new = (\{ \$queue \});
  \}
  Set(\$data, "array:subqueues:" + \$subqueue, \$new);

  /* Update the subqueue mapping */
  \$map = \$data."mapping:subqueues";
  if (\$map) \{
    \$map += ([ \$queue:\$subqueue ]);
  \} else \{
    \$map = ([ \$queue:\$subqueue ]);
  \}
  \$data."mapping:subqueues" = \$map;

  if (!member(\$queue, map_indices(\$data."mapping:queues:private"))) \{
    \$data."mapping:queues:private" += ([ \$queue:"" ]);
  \}

  \$alert = smalltime(time()) + spaces(1) + \$tas + " \\"" + capitalize(\$queue) + " has been moved into the " + capitalize(\$subqueue) + " parent queue by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: \$queue, \$exclude: (\{ \$actor \}));

  EmitTo(\$actor, TAG(\$alert, "assist-alert"));

  return FALSE;
\}

\{
  /* Remove queue from previous subqueue list */
  \$old = Get(\$data, "array:subqueues:" + \$data."mapping:subqueues"[\$queue]);
  \$old -= (\{ \$queue \});
  Set(\$data, "array:subqueues:" + \$data."mapping:subqueues"[\$queue], \$old);

  /* Add queue to new subqueue list */
  \$new = Get(\$data, "array:subqueues:" + \$subqueue);
  if (\$new) \{
    \$new += (\{ \$queue \});
  \} else \{
    \$new = (\{ \$queue \});
  \}
  Set(\$data, "array:subqueues:" + \$subqueue, \$new);

  /* Update the mapping:subqueues list */
  \$map = \$data."mapping:subqueues";
  if (\$map) \{
    \$map[\$queue] = nil;
    \$map += ([ \$queue:\$subqueue ]);
  \} else \{
    \$map = ([ \$queue:\$subqueue ]);
  \}
  \$data."mapping:subqueues" = \$map;

  \$alert = smalltime(time()) + spaces(1) + \$tas + " \\"" + capitalize(\$queue) + " has been moved into the " + capitalize(\$subqueue) + " parent queue by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\"";

  assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: \$queue, \$exclude: (\{ \$actor \}));

  EmitTo(\$actor, TAG(\$alert, "assist-alert"));

  return FALSE;
\}
      </Core:Property>
      <Core:Property property="merry:lib:dostatbyqueue">
         X[M] /* D=Additional Script Testing Space

     The following arguments are required:
       \$data: The db object

     The following arguments are optional:
       \$queue: Specific queue to list stats for
       \$empty: If true, list queues even if they are empty.
*/

/* EmitTo(\$actor, Str(status()[ST_TICKS])); */

if (\$queue \&\& member(\$queue, \$data."array:queues")) \{
  \$include = (\{ \$queue \});
\} else if (\$queue \&\& !member(\$queue, \$data."array:queues")) \{
  EmitTo(\$actor, "Unable to locate that queue.");
  return FALSE;
\} else if (!\$queue) \{
  EmitTo(\$actor, "You must specify a queue!");
  return FALSE;
\}

if (sizeof(\$include) == 1 \&\& !\$empty) \{
  \$empty = "true";
\}

\$count = 0;
\$templist = (\{ \});
\$started = time();

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"Queue stats begun for queue (" + \$queue + "). This shall take approximately " + Flt(\$data."assist:current" / 100) * Flt(0.5) + " seconds.\\"";

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

for (\$x = 0; \$x \< sizeof(\$include); \$x++) \{

  \$gtotal = 0;

  \$totals = ([ 1800:0, 3600:0, 5400:0, 7200:0, 10800:0, 21600:0, 43200:0, 86400:0, 172800:0, 345600:0, 604800:0, 1000000:0 ]);

  \$map = ([ 1800:0, 3600:0, 5400:0, 7200:0, 10800:0, 21600:0, 43200:0, 86400:0, 172800:0, 345600:0, 604800:0, 1000000:0 ]);

  for (\$i = \$data."assist:current"; \$i \> 0; \$i--) \{
    \$assist = assist::dogetassist(\$num: \$i);

    if (\$assist["Queue"] == \$include[\$x] \&\& strlen(\$assist["TimeClosed"]) \> 0 \&\& (\$include[\$x] != "new" \|\| (\$include[\$x] == "new" \&\& \$assist["Account"] != "kargh"))) \{

/*
(\$assist["Queue"] == \$include[\$x] \&\& strlen(\$assist["TimeClosed"]) \> 0 \&\& \$assist["Queue"] != "new") \|\| (\$assist["Account"] != "kargh" \&\& \$include[\$x] == "new" \&\& strlen(\$assist["TimeClosed"]) \> 0)) \{
*/

      \$total = Int(\$assist["TimeClosed"]) - Int(\$assist["TimeFiled"]);

      if (\$total \> 0 \&\& \$total \<= 1800) \{
        \$time = 1800;
      \}

      if (\$total \> 1800 \&\& \$total \<= 3600) \{
        \$time = 3600;
      \}
      if (\$total \> 3600 \&\& \$total \<= 5400) \{
        \$time = 5400;
      \}
      if (\$total \> 5400 \&\& \$total \<= 7200) \{
        \$time = 7200;
      \}
      if (\$total \> 7200 \&\& \$total \<= 10800) \{
        \$time = 10800;
      \}
      if (\$total \> 10800 \&\& \$total \<= 21600) \{
        \$time = 21600;
      \}
      if (\$total \> 21600 \&\& \$total \<= 43200) \{
        \$time = 43200;
      \}
      if (\$total \> 43200 \&\& \$total \<= 86400) \{
        \$time = 86400;
      \}
      if (\$total \> 86400 \&\& \$total \<= 172800) \{
        \$time = 172800;
      \}
      if (\$total \> 172800 \&\& \$total \<= 345600) \{
        \$time = 345600;
      \}
      if (\$total \> 345600 \&\& \$total \<= 604800) \{
        \$time = 604800;
      \}
      if (\$total \> 604800) \{
        /* \$templist += (\{ \$i \}); */
        \$time = 1000000;
      \}
      /* EmitTo(\$actor, "Assist " + \$assist["Queue"] + "/#" + \$i + " " + dump_value(\$time)); */
      \$temp = \$totals[\$time] + 1;
      \$totals[\$time] = nil;
      \$totals += ([ \$time:\$temp ]);

      \$temp = \$map[\$time] + \$total;
      \$map[\$time] = nil;
      \$map += ([ \$time:\$temp ]);
      \$gtotal++;
      \$count++;
    \}
    if (\$count == 100) \{
      /* EmitTo(\$actor, Str(status()[ST_TICKS])); */
      \$delay(0.5, FALSE, "55ed");
      \$count = 0;
    \}
  \}

  \$tableassist = (\{ (\{ "Time", "#", "%", "Avg. Time/Assist Closed" \}) \});

  \$indices = map_indices(\$map);

  for (\$p = 0; \$p \< sizeof(\$indices); \$p++) \{

    \$add = (\{ \});
    \$add += (\{ pad_left(Str((\$p == sizeof(\$indices)-1 ? "7+d" : common::convsecs(\$secs: \$indices[\$p], \$short: "true"))), 7),
    pad_left(Str((\$totals[\$indices[\$p]] == 0 ? "-" : \$totals[\$indices[\$p]]) + "/" + \$gtotal),
    strlen(Str(\$gtotal)) + strlen(Str(\$gtotal)) + 1),
    pad_left(Str((\$totals[\$indices[\$p]] == 0 ? "0" : format_float(Flt(\$totals[\$indices[\$p]])
    / Flt(\$gtotal) * 100.0, 2)) + "%"), 6),
    pad_left(Str(common::convsecs(\$secs: (\$totals[\$indices[\$p]] == 0 ? 0 : \$map[\$indices[\$p]]
      / \$totals[\$indices[\$p]]), \$short: "true")), 15) \});

    \$tableassist += (\{ \$add \});
  \}
  if (\$gtotal \> 0 \|\| \$empty == "true") \{
    EmitTo(\$actor, PRE("Queue: " + capitalize(\$include[\$x]) + "\\nAverage Task Closure Time\\n" + ascii::table(\$content: \$tableassist, \$ignoreseparator: "top bottom left right")));
  \}
\}

EmitTo(\$actor, PRE(("Stats Started: " + spaces(20))[..17] + ctime(\$started) + ("\\nStats Ended: " + spaces(20))[..18] + ctime(time()) + ("\\nReal Search Time: " + spaces(20))[..18] + common::convsecs(\$secs: (time() - \$started))));

/* EmitIn(\$actor."base:environment", dump_value(\$templist)); */
/* assist::docurrent(\$data: \$data, \$key: "recap", \$list: \$templist, \$issearch: "true"); */
      </Core:Property>
      <Core:Property property="merry:lib:dostats">
         X[M] /* D=Displays Assist Statistics

     The following arguments are required:
       \$data: The db object

*/

string header, *tableassist, *tableplayer;
int i;

\$general = copy(\$data."mapping:general:statistics");

header = pad_left("First Task: ", 33) + humanized_date(Int(assist::dogetassist(\$num: 1)["TimeFiled"])) + "\\n" +
         pad_left("Generated On: ", 33) + humanized_date(time()) + "\\n" +
         pad_left("Total Tasks Filed: ", 33) + \$general["Filed"] + "\\n" +
         pad_left("Total Tasks Closed: ", 33) + \$general["Closed"] + "\\n" +
         pad_left("Total Time Used For Tasks: ", 33) + common::convsecs(\$secs: \$general["Total"]) +
         "\\n" +
         pad_left("Overall Average Time Per Task: ", 33) + common::convsecs(\$secs: (\$general["Total"] / \$general["Closed"])) + "\\n\\n";

tableassist = (\{ (\{ "Time", "#", "%", "Avg. Time/Task" \}) \});

\$map = copy(\$data."mapping:time:closed");
\$totals = copy(\$data."mapping:time:closed:total");
\$indices = map_indices(\$map);
\$gtotal = \$general["Closed"];

for (i = 0; i \< sizeof(\$indices); i++) \{

  \$add = (\{ \});
  \$add += (\{ pad_left(Str((i == sizeof(\$indices)-1 ? "7+d" : common::convsecs(\$secs: \$indices[i], \$short: "true"))), 7),
             pad_left(Str((\$totals[\$indices[i]] == 0 ? "-" : \$totals[\$indices[i]]) + "/" + \$gtotal),
               strlen(Str(\$gtotal)) + strlen(Str(\$gtotal)) + 1),
             pad_left(Str((\$totals[\$indices[i]] == 0 ? "0" : format_float(Flt(\$totals[\$indices[i]])
               / Flt(\$gtotal) * 100.0, 2)) + "%"), 6),
             pad_left(Str(common::convsecs(\$secs: (\$totals[\$indices[i]] == 0 ? 0 : \$map[\$indices[i]]
               / \$totals[\$indices[i]]), \$short: "true")), 15) \});

  tableassist += (\{ \$add \});

\}

tableplayer = (\{ (\{ "Account", "Claim", "Ret.", "Tran.", "Close", "Avg. Time/Task" \}) \});

\$map = copy(\$data."mapping:assistee:claimed");
\$indices = map_indices(\$map);

\$returned = copy(\$data."mapping:assistee:returned");
\$transfered = copy(\$data."mapping:assistee:transfered");
\$closed = copy(\$data."mapping:assistee:closed");
\$total = copy(\$data."mapping:assistee:time");

for (i = 0; i \< sizeof(\$indices); i++) \{
  \$add = (\{ \});
  \$add += (\{ Str(\$indices[i]),
             pad_left(Str(\$map[\$indices[i]]), 5),
             pad_left(Str((!\$returned[\$indices[i]] ? "-" : \$returned[\$indices[i]])), 5),
             pad_left(Str((!\$transfered[\$indices[i]] ? "-" : \$transfered[\$indices[i]])), 5),
             pad_left(Str((!\$closed[\$indices[i]] ? "-" : \$closed[\$indices[i]])), 5),
             pad_left(Str(common::convsecs(\$secs: (!\$total[\$indices[i]] ? 0 : \$total[\$indices[i]] /
               \$closed[\$indices[i]]), \$short: "true")), 15) \});

  tableplayer += (\{ \$add \});
\}


EmitTo(\$actor, PRE(header + ascii::table(\$content: tableassist, \$ignoreseparator: "top bottom left right") + "\\n" + ascii::table(\$content: tableplayer, \$ignoreseparator: "top bottom left right")));
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dotransfer">
         X[M] /* D=Transfers open assists from one queue to another.

     The following arguments are required:
       \$data: The db object
       \$num: Assist number
       \$queue: The queue

*/

string queue;
mapping assist, assistee;

assistee = \$data."mapping:assistee";
queue = lower_case(Str(\$queue));

if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if (!assist::dogetassist(\$num: \$num)) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") task number.");
  return FALSE;
\}

if (!member(\$num, map_indices(\$data."mapping:assists:open"))) \{
  EmitTo(\$actor, "Task #" + \$num + " is closed and cannot be transferred to another queue.");
  return FALSE;
\}

if (!member(queue, \$data."array:queues")) \{
  EmitTo(\$actor, "The queue (" + \$queue + ") is not valid.");
  return FALSE;
\}

if (member((\$filter = lower_case(queue + "@" + ((\$r1 = \$actor."theatre:id") ? \$r1 : "marrach"))),
    map_indices(\$data."mapping:queues:forward"))) \{
  queue = \$data."mapping:queues:forward"[\$filter];
\}

assist = assist::dogetassist(\$num: \$num);

if (member(assist["Queue"], \$data."array:queues:locked") \&\& \$actor."udat:host" == 0) \{
  EmitTo(\$actor, "That task is in a locked queue. You may not transfer tasks from that queue.");
  return FALSE;
\}


if (queue == assist["Queue"]) \{
  EmitTo(\$actor, "Task #" + \$num + " is already a member of the " + capitalize(queue) + " queue.");
  return FALSE;
\}

if (member(queue, map_indices(\$data."mapping:queues:servertransfer"))) \{
  if (member(Str(\$num), map_values(\$data."mapping:assistee"))) \{
    EmitTo(\$actor, "You may not transfer that task to a server forwarded queue because it is currently claimed.");
    return FALSE;
  \}


if (member(\$actor."udat:name", map_indices(assistee))) \{
  EmitTo(\$actor, "Because of the way transfers work, you cannot have one task claimed and try to transfer another. You must first close or return the claimed task. Sorry for the inconvenience.");
  return FALSE;
\}

  \$data."mapping:assists:open"[Str(\$num)] = nil;
  \$data."mapping:assists:open" += ([ Str(\$num):queue ]);
  Set(\$data, "array:open:" + assist["Queue"], Get(\$data, "array:open:" + assist["Queue"]) - (\{ Int(\$num) \}));
  Set(\$data, "array:open:" + queue, Get(\$data, "array:open:" + queue) + (\{ Int(\$num) \}));
  \$oldqueue = assist["Queue"];
  assist["Queue"] = nil;
  assist += ([ "Queue":queue ]);
  assist::dosetassist(\$num: \$num, \$assist: assist);
  assist::docreatestats(\$data: \$data, \$action: "transfered");

  \$server = \$data."mapping:queues:servertransfer"[queue];
  \$id     = assist["Theatre"] + "@" + assist["Server"] + "-" + Str(\$num) + "!" + \$server;
  \$notes  = assist["Notes"];
  assist["Notes"] = nil;
  \$note   = "!TAS! (" + short_time(time()) + "): This task has been transferred to server '" + capitalize(\$server) + "' with ID '" + \$id + "'.\\n\\n";
  \$note  += "!TAS! (" + short_time(time()) + "): Original Filer: " + ((\$r1 = Obj(assist["Character"])) ? Describe(Obj(assist["Character"])) : "unknown") + " " + dump_value(assist["Character"]) + "\\n\\n";
  if (strlen(\$notes) \< 1) \{
    assist += ([ "Notes":\$note ]);
  \} else \{
    \$note = \$notes + \$note;
    assist += ([ "Notes":\$note ]);
  \}
  assist::dosetassist(\$num: \$num, \$assist: assist);
  Call(\$\{SkotOS:Assistd\}, "transfer_data", \$server: \$server, \$id: \$id, \$transfer_data: assist);
  \$trans = "[Transferred to server '" + capitalize(\$server) + "']";

  assist::doclaim(\$data: \$data, \$num: \$num, \$cmd: \$cmd, \$silent: "true");
  if (\$ok) \{
    assist::dodone(\$data: \$data, \$msg: "Transfer Close", \$silent: "true");
  \}
\} else \{
  if (member(queue, map_indices(\$data."mapping:queues:email"))) \{
    assist::dosendemail(\$data: \$data, \$num: \$num, \$queue: queue);
  \}

  if (member(Str(\$num), map_values(\$data."mapping:assistee"))) \{
    Set(\$data, "array:claimed:" + assist["Queue"], Get(\$data, "array:claimed:" + assist["Queue"]) - (\{ Int(\$num) \}));
    Set(\$data, "array:claimed:" + queue, Get(\$data, "array:claimed:" + queue) + (\{ Int(\$num) \}));
  \} else \{
    Set(\$data, "array:open:" + assist["Queue"], Get(\$data, "array:open:" + assist["Queue"]) - (\{ Int(\$num) \}));
    Set(\$data, "array:open:" + queue, Get(\$data, "array:open:" + queue) + (\{ Int(\$num) \}));
  \}

  \$data."mapping:assists:open"[Str(\$num)] = nil;

  \$data."mapping:assists:open" += ([ Str(\$num):queue ]);

  \$oldqueue = assist["Queue"];

  assist["Queue"] = nil;
  assist += ([ "Queue":queue ]);

  \$notes  = assist["Notes"];
  assist["Notes"] = nil;
  \$note   = "!TAS! (" + short_time(time()) + "): Transferred from " + capitalize(\$oldqueue) + " to " + capitalize(queue) + " by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + ".\\n\\n";
  if (strlen(\$notes) \< 1) \{
    assist += ([ "Notes":\$note ]);
  \} else \{
    \$note = \$notes + \$note;
    assist += ([ "Notes":\$note ]);
  \}

  assist::dosetassist(\$num: \$num, \$assist: assist);

  assist::docreatestats(\$data: \$data, \$action: "transfered");
\}


\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"\<#" + \$num + "/" + capitalize(\$oldqueue) + "\> moved from " + capitalize(\$oldqueue) + " to " + capitalize(queue) + " by " + chat::get_prefername(\$channel: "tas", \$user: \$actor) + (\$success == 1 ? ". [Email alert sent]" : "") + (\$trans ? " " + \$trans + "\\"" : "\\"");

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: queue, \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dotree">
         X[M] /* D=Tree listing of all queues */

\$output = "General\\n";

\$tree = ::create_tree();

\$output = ::create_tree_output();

EmitTo(\$actor, PRE(\$output));
      </Core:Property>
      <Core:Property property="merry:lib:dotwiki">
         X[M] /* D=TWikize the output for easy copy and paste into twiki

     The following arguments are required:
       \$queue: The queue to use

*/

\$all = "";

if (!member(lower_case(\$queue), \$data."array:queues")) \{
  EmitTo(\$actor, "That is an unknown queue.");
  return FALSE;
\}

\$list = Get(\$data, "array:open:" + lower_case(\$queue));

for (\$i = 0; \$i \< sizeof(\$list); \$i++) \{

\$assist = assist::dogetassist(\$num: \$list[\$i]);

\$str = "%PUBURL%/TWiki/TWikiDocGraphics/warning.gif *Information for Task \<font color=red\>#" + Str(\$list[\$i]) + "\</font\>* \<br\>\<table border=0 cellspacing=0 cellpadding=5\>\<tr\>\<td\> ==Account:== _" + (\$assist["CharObj"] \&\& (\$r1 = \$assist["CharObj"]."skotos:creator") ? Str(\$r1) : "Unknown Account") + "_ \</td\>\<td\> ==Flags:== " + (strlen(\$r1 = \$assist["Flag"]) ? "_" + \$r1 + "_" : "") + "\</td\>\</tr\>";

\$str += "\<tr\>\<td\> ==Character:== _" + (\$assist["CharObj"] ? Describe(\$assist["CharObj"]) : "Unknown" ) + "_ \</td\>\<td\> ==Queue:== _" + \$assist["Queue"] + "_ \</td\>\</tr\>";

\$str += "\<tr\>\<td\> ==Date Filed:== _" + humanized_date(Int(\$assist["TimeFiled"])) + "_ \</td\>\<td\> ==Date Claimed:== " + (strlen( \$r1 = \$assist["TimeClaimed"]) ? "_" + humanized_date(Int(\$r1)) + "_" : "") + " \</td\>\</tr\>\<tr\>\</tr\>";

\$str += "\<tr\>\<td\> ==Assisted By:== " + ((\$r1 = Obj(\$assist["Assistee"])) ? "_" + Describe(\$r1) + "_" : "") + " \</td\>\<td\> ==Date Closed:== " + (strlen(\$r1 = \$assist["TimeClosed"]) ? "_" + humanized_date(Int(\$r1)) + "_" : "") + " \</td\>\</tr\>\</table\>\<br/\>";

\$str += " *Task Message:* \<br/\> =" + \$assist["AssistText"] + "= \<br/\>\<br/\>";

\$str += " *Additional Notes:* \<br/\> " + (strlen(\$r1 = \$assist["Notes"]) ? "=" + replace_strings(\$r1, "\\n", "\<br\>") + "=" : "") + " \<br/\>\<hr/\>\<br/\>";


\$all += \$str + "@\\n@ @\\n@";

/*
\$all += \$str + "\\n\\n";
*/
\}

\$actor.twikioutput = \$all;

if (strlen(\$actor.twikioutput) \< 1) \{
  EmitTo(\$actor, "Nothing in queue (" + capitalize(\$queue) + ") to format for twiki.");
  return FALSE;
\}

Popup(\$actor, \$this, "twikipopup", \$what: Str(\$actor));



return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dounlock">
         X[M] /* D=Unlocks a queue

    The following arguments are required:
      \$queue: The queue that is being unlocked
*/

\$queue = lower_case(\$queue);

if (!member(\$queue, \$data."array:queues")) \{
  EmitTo(\$actor, "That is not a valid queue to unlock.");
  return FALSE;
\}

if (!member(\$queue, \$data."array:queues:locked")) \{
  EmitTo(\$actor, "That queue is not locked!");
  return FALSE;
\}

\$data."array:queues:locked" -= (\{ \$queue \});

\$alert = smalltime(time()) + spaces(1) + \$tas + " \\"" + chat::get_prefername(\$channel: "tas", \$user: \$actor) + " has unlocked the " + capitalize(\$queue) + " queue.\\"";

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: \$queue, \$exclude: (\{ \$actor \}));

EmitTo(\$actor, TAG(\$alert, "assist-alert"));

return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:dowatch">
         X[M] /* D=Watches an assist for changes. Alerts you on login.

     The following arguments are required:
       \$data: The DB object
       \$num: The assist number

*/

if (!\$num) \{
  if (\$actor."mapping:assists:watch" \&\& map_sizeof(\$actor."mapping:assists:watch") \> 0) \{
    \$list = map_indices(\$actor."mapping:assists:watch");
    \$line = smalltime(time()) + spaces(1) + \$tas + " \\"You are watching the following tasks: " + implode(map_indices(arr_to_set(\$list)), ", ") + ".\\"";
    EmitTo(\$actor, TAG(\$line, "assist-alert"));
    return FALSE;
  \}
  EmitTo(\$actor, TAG(smalltime(time()) + spaces(1) + \$tas + " \\"You are not watching any tasks.\\"", "assist-alert"));
  return FALSE;
\}

if ((sscanf(\$num, "%d%s", \$number, \$dummy) == 2 \&\& strlen(\$dummy)) \|\| sscanf(\$num, "%d%s", \$number, \$dummy) == 0) \{
  EmitTo(\$actor, "You supplied an invalid (" + \$num + ") tasks number.");
  return FALSE;
\}

if (!\$data."mapping:assists:open"[Str(\$num)]) \{
  EmitTo(\$actor, "That task is not open. You may only watch open tasks.");
  return FALSE;
\}

if (!\$actor."mapping:assists:watch") \{
  \$actor."mapping:assists:watch" = ([ \$num:time() ]);
  EmitTo(\$actor, "You are now watching task #" + \$num + ".");
  return FALSE;
\}

if (member(\$num, map_indices(\$actor."mapping:assists:watch"))) \{
  EmitTo(\$actor, "You are already watching that task.");
  return FALSE;
\}

\$actor."mapping:assists:watch" += ([ \$num:time() ]);
EmitTo(\$actor, "You are now watching task #" + \$num + ".");
return FALSE;
      </Core:Property>
      <Core:Property property="merry:lib:searchdb_decode">
         X[M] /* D=Interpret (string) value in SearchDB bigmap.

     The following arguments are required:
       \$data
*/

int i, sz;
mixed *list;

list = explode(\$data, ";");
sz = sizeof(list);
for (i = 0; i \< sz; i++) \{
    list[i] = (int)list[i];
\}
return list;
      </Core:Property>
      <Core:Property property="merry:lib:searchdb_encode">
         X[M] /* D=Create string value from array (of integers), for SearchDB bigmap.

     The following arguments are required:
       \$list
*/

int i, sz;
mixed *list;

list = \$list[..];
sz = sizeof(list);
for (i = 0; i \< sz; i++) \{
    list[i] = (string)list[i];
\}

return implode(list, ";");
      </Core:Property>
      <Core:Property property="merry:lib:t2:dbg">
         X[M] /* lib:t2:dbg temp-script */

/* The Variable Declarators */
string *sublist;
int i, x, z, h, s, hnum, hpos, year, dayone, startnum, smallnum, pos, smallpos, startspot, numofdays, rows, datesecs, datestr, memos;
mapping months, startday, dayspermonth, calendar, pcalendar, s_holidays, d_holidays, subevents;
object caldb;
string month, day, header, body;

sublist = \$_t2_injected_locals["sublist"];
i = \$_t2_injected_locals["i"];
x = \$_t2_injected_locals["x"];
z = \$_t2_injected_locals["z"];
h = \$_t2_injected_locals["h"];
s = \$_t2_injected_locals["s"];
hnum = \$_t2_injected_locals["hnum"];
hpos = \$_t2_injected_locals["hpos"];
year = \$_t2_injected_locals["year"];
dayone = \$_t2_injected_locals["dayone"];
startnum = \$_t2_injected_locals["startnum"];
smallnum = \$_t2_injected_locals["smallnum"];
pos = \$_t2_injected_locals["pos"];
smallpos = \$_t2_injected_locals["smallpos"];
startspot = \$_t2_injected_locals["startspot"];
numofdays = \$_t2_injected_locals["numofdays"];
rows = \$_t2_injected_locals["rows"];
datesecs = \$_t2_injected_locals["datesecs"];
datestr = \$_t2_injected_locals["datestr"];
memos = \$_t2_injected_locals["memos"];
months = \$_t2_injected_locals["months"];
startday = \$_t2_injected_locals["startday"];
dayspermonth = \$_t2_injected_locals["dayspermonth"];
calendar = \$_t2_injected_locals["calendar"];
pcalendar = \$_t2_injected_locals["pcalendar"];
s_holidays = \$_t2_injected_locals["s_holidays"];
d_holidays = \$_t2_injected_locals["d_holidays"];
subevents = \$_t2_injected_locals["subevents"];
caldb = \$_t2_injected_locals["caldb"];
month = \$_t2_injected_locals["month"];
day = \$_t2_injected_locals["day"];
header = \$_t2_injected_locals["header"];
body = \$_t2_injected_locals["body"];


args = \$_t2_injected_args + ([ "_t2_condition_applies" : TRUE, "_t2_injected_args" : \$_t2_injected_args, "_t2_injected_locals" : \$_t2_injected_locals ]);

/* The Expression */


  EmitTo(\$actor, PRE(\$output));

/* Var Examination */
Call(\$\{Shared:sys:Merry:+t2\}, "var_exam", \$local_map: ([ "sublist" : sublist, "i" : i, "x" : x, "z" : z, "h" : h, "s" : s, "hnum" : hnum, "hpos" : hpos, "year" : year, "dayone" : dayone, "startnum" : startnum, "smallnum" : smallnum, "pos" : pos, "smallpos" : smallpos, "startspot" : startspot, "numofdays" : numofdays, "rows" : rows, "datesecs" : datesecs, "datestr" : datestr, "memos" : memos, "months" : months, "startday" : startday, "dayspermonth" : dayspermonth, "calendar" : calendar, "pcalendar" : pcalendar, "s_holidays" : s_holidays, "d_holidays" : d_holidays, "subevents" : subevents, "caldb" : caldb, "month" : month, "day" : day, "header" : header, "body" : body ]));
      </Core:Property>
      <Core:Property property="merry:lib:transfer_reply">
         X[M] /* Transfer Reply Test */

if (\$result) \{
  \$alert = smalltime(time()) + spaces(1) + "[TAS]" + spaces(1) + "\\"Transfer to server '" + capitalize(\$server) + "' successful. Transfer ID: " + \$id + "\\"";
\} else \{
  \$alert = smalltime(time()) + spaces(1) + "[TAS]" + spaces(1) + "\\"Transfer to server '" + capitalize(\$server) + "' unsuccessful! Error: " + \$message + "\\"";
\}

\$assist = assist::dogetassist(\$num: \$num);
\$notes = \$assist["Notes"];

\$notes += "!TAS! (" + short_time(time()) + "): Filed as task #" + \$message["Number"] + " on server '" + \$message["Server"] + "'.";
\$assist["Notes"] = nil;
\$assist += ([ "Notes":\$notes ]);
assist::dosetassist(\$num: \$num, \$assist: \$assist);

assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert");
      </Core:Property>
      <Core:Property property="merry:lib:transfer_request">
         X[M] /* Relay Testing */

string queue, num;
mapping assist, data;
object owner;

\{
  assist = \$transfer_data;
  \$data  = \$\{Data:DB:assist:AssistGeneralDB\};
  queue  = assist["Queue"];
  \$queue = queue;
  \$origserver = assist["Server"];

  if (!member(queue, map_indices(\$data."mapping:queues:owner"))) \{
    \$message = "No queue owner! Could not set!";
    \$result  = TRUE;
    return TRUE;
  \}

  owner = \$data."mapping:queues:owner"[queue];
  \$actor = owner;
  assist["Account"] = nil;
  assist += ([ "Account":((\$r1 = owner."skotos:creator") ? \$r1 : "unknown") ]);
  assist["Character"] = nil;
  assist += ([ "Character":Str(\$actor) ]);
  assist["Environment"] = nil;
  assist += ([ "Environment":owner."theatre:home" ]);
  assist["Links"] = nil;
  assist += ([ "Links":(\{ \}) ]);
  assist["Theatre"] = nil;
  assist += ([ "Theatre":((\$r1 = \$\{Data:info\}.id) ? \$r1 : "unknown") ]);
  assist["Server"] = nil;
  assist += ([ "Server":((\$r1 = \$\{Data:info\}.id) ? \$r1 : "unknown") ]);
  assist += ([ "CharObj":\$actor ]);


  num = Str(\$data."Assist:Next");

  assist::dosetassist(\$num: num, \$assist: assist);

  \$data."Assist:Next"++;
  \$data."Assist:Current"++;

  Set(\$data, "array:open:" + \$queue, Get(\$data, "array:open:" + \$queue) + (\{ \$data."Assist:Current" \}));

  \$data."mapping:assists:open" += ([ Str(\$data."Assist:Current"):\$queue ]);

  /* Nov 14, 2004  Kalle: if \$actor is not online, this would fail.
   * Modded to a call to udat.
   * - \$udat_obj = \$actor."udat:object";
   */
  \$udat_obj = Call(\$\{UserAPI:UDatD\}, "query_udat", \$name: \$actor."skotos:creator");

  if (!\$udat_obj."array:assists") \{
    \$udat_obj."array:assists" = (\{ \$data."assist:current" \});
  \} else \{
    \$udat_obj."array:assists" += (\{ \$data."assist:current" \});
  \}

  assist::docreatestats(\$data: \$data, \$action: "filed");


  if (member(\$queue, map_indices(\$data."mapping:queues:email"))) \{
    assist::dosendemail(\$data: \$data, \$num: \$data."Assist:Current", \$queue: \$queue);
  \}

  \$alert = smalltime(time()) + spaces(1) + "[TAS]" + " \\"\<#" + \$data."Assist:Current" + "/" + capitalize(\$queue) + "\> Transfered from server '" + capitalize(\$origserver) + "': " + assist["AssistText"] + (\$success == 1 ? " [Email alert sent]\\"" : "\\"");;

  if (!\$syslvl) \$syslvl = "1";

  if ((\$imperative != "task" \|\| \$loud == 1) \&\& !member(\$queue, \$data."array:queues:locked")) \{
    assist::dochatfeed(\$alert: \$alert, \$style: "assist-alert", \$ignore: \$queue);
  \}

  \$message = ([ "Server":assist["Server"], "Number":num ]);

  \$result = TRUE;

  return TRUE;
\}
      </Core:Property>
      <Core:Property property="new property name">
         "New Property Value"
      </Core:Property>
      <Core:Property property="revisions">
         (\{ 1060029904, "kargh", "E", 1061320404, "kargh", "E", 1062220308, "kargh", "E", 1062220469, "kargh", "E", 1062640017, "kargh", "E", 1062640129, "kargh", "E", 1062640302, "kargh", "E", 1062640441, "kargh", "E", 1062640522, "kargh", "E", 1063379618, "kargh", "E", 1063380135, "kargh", "E", 1063380395, "kargh", "E", 1063380532, "kargh", "E", 1063380642, "kargh", "E", 1063380853, "kargh", "E", 1063381082, "kargh", "E", 1063381153, "kargh", "E", 1063381223, "kargh", "E", 1063381551, "kargh", "E", 1063381648, "kargh", "E", 1065879671, "kargh", "P", 1065879754, "kargh", "P", 1065879768, "kargh", "P", 1065879940, "kargh", "P", 1065881996, "kargh", "P", 1066582219, "kargh", "P", 1066900844, "kargh", "P", 1067565967, "kargh", "P", 1067941997, "kargh", "P", 1067942128, "kargh", "P", 1067942175, "kargh", "P", 1067959318, "kargh", "P", 1068824211, "kargh", "P", 1068827025, "kargh", "P", 1068827336, "kargh", "P", 1068914201, "kargh", "P", 1068914237, "kargh", "P", 1068914545, "kargh", "P", 1068915152, "kargh", "P", 1068915324, "kargh", "P", 1068916170, "kargh", "P", 1068916354, "kargh", "P", 1069101530, "kargh", "P", 1069101817, "kargh", "P", 1069101878, "kargh", "P", 1069101926, "kargh", "P", 1069101974, "kargh", "P", 1069102413, "kargh", "P", 1069103003, "kargh", "P", 1069103547, "kargh", "P", 1069103776, "kargh", "P", 1069103970, "kargh", "P", 1069107400, "kargh", "P", 1069107590, "kargh", "P", 1069107639, "kargh", "P", 1069107780, "kargh", "P", 1069108408, "kargh", "P", 1069108601, "kargh", "P", 1069108926, "kargh", "P", 1069109031, "kargh", "P", 1069109180, "kargh", "P", 1069109218, "kargh", "P", 1069109369, "kargh", "P", 1069109466, "kargh", "P", 1069110064, "kargh", "P", 1069110270, "kargh", "P", 1069110343, "kargh", "P", 1069110586, "kargh", "P", 1069110676, "kargh", "P", 1069111936, "kargh", "P", 1069112025, "kargh", "P", 1069112106, "kargh", "P", 1069151363, "kargh", "P", 1069151489, "kargh", "P", 1069197221, "kargh", "P", 1069197324, "kargh", "P", 1069197530, "kargh", "P", 1069197627, "kargh", "P", 1069198210, "kargh", "P", 1069198432, "kargh", "P", 1069201013, "kargh", "P", 1069201082, "kargh", "P", 1069201125, "kargh", "P", 1069201275, "kargh", "P", 1069201355, "kargh", "P", 1069201518, "kargh", "P", 1069201530, "kargh", "P", 1069201560, "kargh", "P", 1069202436, "kargh", "P", 1069203039, "kargh", "P", 1069203208, "kargh", "P", 1069203250, "kargh", "P", 1069255088, "kargh", "P", 1069255340, "kargh", "P", 1069255361, "kargh", "P", 1069255466, "kargh", "P", 1069256307, "kargh", "P", 1069256325, "kargh", "P", 1069258361, "kargh", "P", 1069258459, "kargh", "P", 1069260350, "kargh", "P", 1069260468, "kargh", "P", 1069260497, "kargh", "P", 1069274732, "kargh", "P", 1069274790, "kargh", "P", 1069274881, "kargh", "P", 1069276836, "kargh", "P", 1069276881, "kargh", "P", 1069276932, "kargh", "P", 1069276995, "kargh", "P", 1069277046, "kargh", "P", 1069277084, "kargh", "P", 1069277373, "kargh", "P", 1069277389, "kargh", "P", 1069277463, "kargh", "P", 1069277558, "kargh", "P", 1069277722, "kargh", "P", 1069277817, "kargh", "P", 1069277838, "kargh", "P", 1069277905, "kargh", "P", 1069277925, "kargh", "P", 1069278149, "kargh", "P", 1069278191, "kargh", "P", 1069278232, "kargh", "P", 1069278333, "kargh", "P", 1069278372, "kargh", "P", 1069278425, "kargh", "P", 1069278445, "kargh", "P", 1069278510, "kargh", "P", 1069278554, "kargh", "P", 1069278593, "kargh", "P", 1069278629, "kargh", "P", 1069278711, "kargh", "P", 1069278912, "kargh", "P", 1069278975, "kargh", "P", 1069279038, "kargh", "P", 1069279122, "kargh", "P", 1069279235, "kargh", "P", 1069279264, "kargh", "P", 1069279368, "kargh", "P", 1069279529, "kargh", "P", 1069279669, "kargh", "P", 1069279706, "kargh", "P", 1069279796, "kargh", "P", 1069280082, "kargh", "P", 1069280341, "kargh", "P", 1069281029, "kargh", "P", 1069281049, "kargh", "P", 1069322251, "kargh", "P", 1069322407, "kargh", "P", 1069323152, "kargh", "P", 1069323570, "kargh", "P", 1069323614, "kargh", "P", 1069324634, "kargh", "P", 1069324846, "kargh", "P", 1069324900, "kargh", "P", 1069345601, "kargh", "P", 1069345690, "kargh", "P", 1069346195, "kargh", "P", 1069346233, "kargh", "P", 1069347592, "kargh", "P", 1069347892, "kargh", "P", 1069348688, "kargh", "P", 1069348771, "kargh", "P", 1069348806, "kargh", "P", 1069348881, "kargh", "P", 1069349052, "kargh", "P", 1069349139, "kargh", "P", 1069356140, "kargh", "P", 1069356488, "kargh", "P", 1069383525, "kargh", "P", 1069383569, "kargh", "P", 1069383721, "kargh", "P", 1069383822, "kargh", "P", 1069384445, "kargh", "P", 1069384521, "kargh", "P", 1069384617, "kargh", "P", 1069439081, "kargh", "P", 1069439450, "kargh", "P", 1069439493, "kargh", "P", 1069439671, "kargh", "P", 1069440059, "kargh", "P", 1069440463, "kargh", "P", 1069446357, "kargh", "P", 1069446589, "kargh", "P", 1069446872, "kargh", "P", 1069538163, "kargh", "P", 1069538826, "kargh", "P", 1069538895, "kargh", "P", 1069538981, "kargh", "P", 1069539635, "kargh", "P", 1069539701, "kargh", "P", 1069539736, "kargh", "P", 1069539767, "kargh", "P", 1069539804, "kargh", "P", 1069542952, "kargh", "P", 1069542973, "kargh", "P", 1069543096, "kargh", "P", 1069543184, "kargh", "P", 1069543333, "kargh", "P", 1069543356, "kargh", "P", 1069543396, "kargh", "P", 1069554930, "kargh", "P", 1069555050, "kargh", "P", 1069555229, "kargh", "P", 1069555392, "kargh", "P", 1069555471, "kargh", "P", 1069693543, "kargh", "P", 1069693845, "kargh", "P", 1069699302, "kargh", "P", 1069699468, "kargh", "P", 1069699609, "kargh", "P", 1069699984, "kargh", "P", 1069700017, "kargh", "P", 1069700273, "kargh", "P", 1069704288, "kargh", "P", 1069704494, "kargh", "P", 1069704558, "kargh", "P", 1069710245, "kargh", "P", 1069712016, "kargh", "P", 1069712158, "kargh", "P", 1069712840, "kargh", "P", 1069782915, "kargh", "P", 1069783064, "kargh", "P", 1069783759, "kargh", "P", 1069866492, "kargh", "P", 1069867097, "kargh", "P", 1069869524, "kargh", "P", 1069877755, "kargh", "P", 1070390877, "kargh", "P", 1070391285, "kargh", "P", 1070393380, "kargh", "P", 1070394009, "kargh", "P", 1070394043, "kargh", "P", 1070394062, "kargh", "P", 1070397319, "kargh", "P", 1070397596, "kargh", "P", 1070397665, "kargh", "P", 1070397944, "kargh", "P", 1070397999, "kargh", "P", 1070478795, "kargh", "P", 1070479371, "kargh", "P", 1070479444, "kargh", "P", 1070479466, "kargh", "P", 1070479642, "kargh", "P", 1070559736, "kargh", "P", 1070560643, "kargh", "P", 1070560702, "kargh", "P", 1070561120, "kargh", "P", 1070561405, "kargh", "P", 1070561816, "kargh", "P", 1070561952, "kargh", "P", 1070562729, "kargh", "P", 1070562877, "kargh", "P", 1070642480, "kargh", "P", 1070645510, "kargh", "P", 1070645579, "kargh", "P", 1070645641, "kargh", "P", 1070646088, "kargh", "P", 1070646144, "kargh", "P", 1070646201, "kargh", "P", 1070646984, "kargh", "P", 1070647030, "kargh", "P", 1070649259, "kargh", "P", 1070661547, "kargh", "P", 1070662390, "kargh", "P", 1070662464, "kargh", "P", 1070662915, "kargh", "P", 1070662970, "kargh", "P", 1070663252, "kargh", "P", 1070663290, "kargh", "P", 1070663380, "kargh", "P", 1070668218, "kargh", "P", 1070668613, "kargh", "P", 1070668796, "kargh", "P", 1070669497, "kargh", "P", 1070675172, "kargh", "P", 1070675283, "kargh", "P", 1070675442, "kargh", "P", 1070676031, "kargh", "P", 1070676099, "kargh", "P", 1070676176, "kargh", "P", 1070676235, "kargh", "P", 1070676333, "kargh", "P", 1070676393, "kargh", "P", 1070676470, "kargh", "P", 1070676707, "kargh", "P", 1070676746, "kargh", "P", 1070677155, "kargh", "P", 1070677247, "kargh", "P", 1070677344, "kargh", "P", 1070677464, "kargh", "P", 1070677535, "kargh", "P", 1070677668, "kargh", "P", 1070677952, "kargh", "P", 1070678056, "kargh", "P", 1070678352, "kargh", "P", 1070679680, "kargh", "P", 1070679695, "kargh", "P", 1070736714, "kargh", "P", 1070737080, "kargh", "P", 1070747992, "kargh", "P", 1070748093, "kargh", "P", 1070748150, "kargh", "P", 1070748219, "kargh", "P", 1070748267, "kargh", "P", 1070749659, "kargh", "P", 1070749806, "kargh", "P", 1070750024, "kargh", "P", 1070750053, "kargh", "P", 1070750092, "kargh", "P", 1070750134, "kargh", "P", 1070750406, "kargh", "P", 1070750555, "kargh", "P", 1070750805, "kargh", "P", 1070750925, "kargh", "P", 1070751090, "kargh", "P", 1070751299, "kargh", "P", 1070751382, "kargh", "P", 1070751568, "kargh", "P", 1070751679, "kargh", "P", 1070751698, "kargh", "P", 1070752930, "kargh", "P", 1070752971, "kargh", "P", 1070753061, "kargh", "P", 1070753143, "kargh", "P", 1070753223, "kargh", "P", 1070753246, "kargh", "P", 1070753384, "kargh", "P", 1070753649, "kargh", "P", 1070806170, "kargh", "P", 1070806252, "kargh", "P", 1070806292, "kargh", "P", 1070806358, "kargh", "P", 1070806394, "kargh", "P", 1070806427, "kargh", "P", 1070806473, "kargh", "P", 1070806538, "kargh", "P", 1070806863, "kargh", "P", 1070807980, "kargh", "P", 1070808219, "kargh", "P", 1070808369, "kargh", "P", 1070808426, "kargh", "P", 1070808490, "kargh", "P", 1070808592, "kargh", "P", 1070809690, "kargh", "P", 1070809729, "kargh", "P", 1070809778, "kargh", "P", 1070809842, "kargh", "P", 1070809880, "kargh", "P", 1070810427, "kargh", "P", 1070810510, "kargh", "P", 1070810595, "kargh", "P", 1070810659, "kargh", "P", 1070810716, "kargh", "P", 1070810795, "kargh", "P", 1070813168, "kargh", "P", 1070845096, "kargh", "P", 1070900809, "kargh", "P", 1070905941, "kargh", "P", 1070905954, "kargh", "P", 1070906085, "kargh", "P", 1070906979, "kargh", "P", 1070907677, "kargh", "P", 1070908719, "kargh", "P", 1070908816, "kargh", "P", 1070909003, "kargh", "P", 1070909056, "kargh", "P", 1070909087, "kargh", "P", 1070909106, "kargh", "P", 1070911560, "kargh", "P", 1070911612, "kargh", "P", 1070911714, "kargh", "P", 1070911982, "kargh", "P", 1070912163, "kargh", "P", 1070912223, "kargh", "P", 1070912238, "kargh", "P", 1070912324, "kargh", "P", 1070912344, "kargh", "P", 1070912408, "kargh", "P", 1070912426, "kargh", "P", 1070912489, "kargh", "P", 1070912504, "kargh", "P", 1070912534, "kargh", "P", 1070912579, "kargh", "P", 1070912724, "kargh", "P", 1070912896, "kargh", "P", 1070913012, "kargh", "P", 1070913066, "kargh", "P", 1070913169, "kargh", "P", 1070913208, "kargh", "P", 1070913254, "kargh", "P", 1070913347, "kargh", "P", 1070913383, "kargh", "P", 1070913452, "kargh", "P", 1070913489, "kargh", "P", 1070915581, "kargh", "P", 1070915604, "kargh", "P", 1070915809, "kargh", "P", 1070917398, "kargh", "P", 1070917935, "kargh", "P", 1070933726, "kargh", "P", 1070934288, "kargh", "P", 1070934431, "kargh", "P", 1070934477, "kargh", "P", 1070935121, "kargh", "P", 1070935245, "kargh", "P", 1071096693, "kargh", "P", 1071096815, "kargh", "P", 1071096891, "kargh", "P", 1071097090, "kargh", "P", 1071097117, "kargh", "P", 1071097209, "kargh", "P", 1071097349, "kargh", "P", 1071097373, "kargh", "P", 1071098229, "kargh", "P", 1071098269, "kargh", "P", 1071098345, "kargh", "P", 1071098431, "kargh", "P", 1071098540, "kargh", "P", 1071098679, "kargh", "P", 1071098974, "kargh", "P", 1071105312, "kargh", "P", 1071105379, "kargh", "P", 1071105399, "kargh", "P", 1071159468, "kargh", "P", 1071160612, "kargh", "P", 1071160932, "kargh", "P", 1071247244, "kargh", "P", 1071247539, "kargh", "P", 1071247605, "kargh", "P", 1071322641, "zwoc", "P", 1071322669, "zwoc", "P", 1071322823, "zwoc", "P", 1071322873, "zwoc", "P", 1071324816, "zwoc", "P", 1071324878, "zwoc", "P", 1071324918, "zwoc", "P", 1071324942, "zwoc", "P", 1071325086, "zwoc", "P", 1071325263, "zwoc", "P", 1071325332, "zwoc", "P", 1071325513, "zwoc", "P", 1071325548, "zwoc", "P", 1071325902, "zwoc", "P", 1071328958, "zwoc", "P", 1071329049, "zwoc", "P", 1071329137, "zwoc", "P", 1071329248, "zwoc", "P", 1071329337, "zwoc", "P", 1071329371, "zwoc", "P", 1071329528, "zwoc", "P", 1071329693, "zwoc", "P", 1071329835, "zwoc", "P", 1071329881, "zwoc", "P", 1071329922, "zwoc", "P", 1071330462, "zwoc", "P", 1071330502, "zwoc", "P", 1071330549, "zwoc", "P", 1071330592, "zwoc", "P", 1071330879, "zwoc", "P", 1071330943, "zwoc", "P", 1071331052, "zwoc", "P", 1071331131, "zwoc", "P", 1071331174, "zwoc", "P", 1071503711, "kargh", "P", 1071606099, "zwoc", "P", 1071637721, "kargh", "P", 1071708524, "kargh", "P", 1071900116, "kargh", "P", 1071900152, "kargh", "P", 1071900197, "kargh", "P", 1072026019, "kargh", "P", 1072213804, "kargh", "P", 1072214171, "kargh", "P", 1072214212, "kargh", "P", 1072214229, "kargh", "P", 1072214409, "kargh", "P", 1072214456, "kargh", "P", 1072214681, "kargh", "P", 1072214721, "kargh", "P", 1072214972, "kargh", "P", 1072215645, "kargh", "P", 1072215846, "kargh", "P", 1072215880, "kargh", "P", 1072215970, "kargh", "P", 1072216320, "kargh", "P", 1072216769, "kargh", "P", 1072216913, "kargh", "P", 1072217041, "kargh", "P", 1072217111, "kargh", "P", 1072217133, "kargh", "P", 1072217275, "kargh", "P", 1072217457, "kargh", "P", 1072217583, "kargh", "P", 1072217837, "kargh", "P", 1072217956, "kargh", "P", 1072218182, "kargh", "P", 1072218247, "kargh", "P", 1072218372, "kargh", "P", 1072220147, "kargh", "P", 1072220696, "kargh", "P", 1072221908, "kargh", "P", 1072222121, "kargh", "P", 1072222201, "kargh", "P", 1072222258, "kargh", "P", 1072222420, "kargh", "P", 1072222639, "kargh", "P", 1072222708, "kargh", "P", 1072222774, "kargh", "P", 1072223003, "kargh", "P", 1072223710, "kargh", "P", 1072719946, "kargh", "P", 1072720706, "kargh", "P", 1072720735, "kargh", "P", 1072720784, "kargh", "P", 1072720856, "kargh", "P", 1072720896, "kargh", "P", 1072721002, "kargh", "P", 1072721026, "kargh", "P", 1072721065, "kargh", "P", 1072721079, "kargh", "P", 1072721430, "kargh", "P", 1072736618, "kargh", "P", 1072736795, "kargh", "P", 1072736829, "kargh", "P", 1072736888, "kargh", "P", 1072736920, "kargh", "P", 1072736983, "kargh", "P", 1072737033, "kargh", "P", 1072737218, "kargh", "P", 1072737377, "kargh", "P", 1072737413, "kargh", "P", 1072737749, "kargh", "P", 1072738093, "kargh", "P", 1072738139, "kargh", "P", 1072738171, "kargh", "P", 1072738211, "kargh", "P", 1072738260, "kargh", "P", 1072738366, "kargh", "P", 1072738534, "kargh", "P", 1072738777, "kargh", "P", 1072739710, "kargh", "P", 1072740449, "kargh", "P", 1072740505, "kargh", "P", 1072740566, "kargh", "P", 1072740658, "kargh", "P", 1072740675, "kargh", "P", 1072740756, "kargh", "P", 1072740781, "kargh", "P", 1072741024, "kargh", "P", 1072741049, "kargh", "P", 1072741159, "kargh", "P", 1072741198, "kargh", "P", 1072741254, "kargh", "P", 1072741472, "kargh", "P", 1072741506, "kargh", "P", 1072741569, "kargh", "P", 1072741672, "kargh", "P", 1072741952, "kargh", "P", 1072742068, "kargh", "P", 1072742093, "kargh", "P", 1072742666, "kargh", "P", 1072742728, "kargh", "P", 1072742821, "kargh", "P", 1072742862, "kargh", "P", 1072743767, "kargh", "P", 1072743884, "kargh", "P", 1072744166, "kargh", "P", 1072744192, "kargh", "P", 1072744234, "kargh", "P", 1072749781, "kargh", "P", 1072749843, "kargh", "P", 1072749976, "kargh", "P", 1072750056, "kargh", "P", 1072750090, "kargh", "P", 1072750127, "kargh", "P", 1072750268, "kargh", "P", 1072750429, "kargh", "P", 1072750488, "kargh", "P", 1072750550, "kargh", "P", 1072750639, "kargh", "P", 1072750681, "kargh", "P", 1072750898, "kargh", "P", 1072750949, "kargh", "P", 1072751006, "kargh", "P", 1072972745, "kargh", "P", 1073848003, "kargh", "P", 1073848212, "kargh", "P", 1075303530, "kargh", "P", 1078190670, "kargh", "P", 1079902667, "kargh", "P", 1079903790, "kargh", "P", 1079903829, "kargh", "P", 1079903864, "kargh", "P", 1079904430, "kargh", "P", 1079904634, "kargh", "P", 1079904660, "kargh", "P", 1080002271, "kargh", "P", 1080003494, "kargh", "P", 1080003651, "kargh", "P", 1080083744, "kargh", "P", 1080774931, "kargh", "P", 1081007602, "kargh", "P", 1081084545, "kargh", "P", 1081084872, "kargh", "P", 1081085335, "kargh", "P", 1081870276, "kargh", "P", 1081870400, "kargh", "P", 1081871714, "kargh", "P", 1081872164, "kargh", "P", 1081872440, "kargh", "P", 1082313360, "kargh", "P", 1082313391, "kargh", "P", 1082314014, "kargh", "P", 1082314176, "kargh", "P", 1082314459, "kargh", "P", 1082315309, "kargh", "P", 1082315861, "kargh", "P", 1082316008, "kargh", "P", 1082334793, "kargh", "P", 1082335012, "kargh", "P", 1082335113, "kargh", "P", 1082335144, "kargh", "P", 1082335167, "kargh", "P", 1082337415, "kargh", "P", 1082337515, "kargh", "P", 1082338003, "kargh", "P", 1082368515, "kargh", "P", 1082407130, "kargh", "P", 1082407909, "kargh", "P", 1082925321, "kargh", "P", 1082926167, "kargh", "P", 1082927307, "kargh", "P", 1083015614, "kargh", "P", 1083015690, "kargh", "P", 1083015745, "kargh", "P", 1083016448, "kargh", "P", 1083069007, "kargh", "P", 1083070144, "kargh", "P", 1083070269, "kargh", "P", 1083070297, "kargh", "P", 1083070549, "kargh", "P", 1083070866, "kargh", "P", 1083071229, "kargh", "P", 1083071285, "kargh", "P", 1083071625, "kargh", "P", 1083071695, "kargh", "P", 1083156751, "kargh", "P", 1083157887, "kargh", "P", 1083157987, "kargh", "P", 1083158167, "kargh", "P", 1083158510, "kargh", "P", 1083158750, "kargh", "P", 1083158960, "kargh", "P", 1083159024, "kargh", "P", 1083159067, "kargh", "P", 1083159111, "kargh", "P", 1083159195, "kargh", "P", 1083184525, "kargh", "P", 1083185264, "kargh", "P", 1083185799, "kargh", "P", 1083186086, "kargh", "P", 1083186218, "kargh", "P", 1083186830, "kargh", "P", 1083187432, "kargh", "P", 1083189147, "kargh", "P", 1083195876, "kargh", "P", 1083195910, "kargh", "P", 1083196053, "kargh", "P", 1083196393, "kargh", "P", 1083196615, "kargh", "P", 1083196664, "kargh", "P", 1083196858, "kargh", "P", 1083199085, "kargh", "P", 1083199392, "kargh", "P", 1083199695, "kargh", "P", 1083200151, "kargh", "P", 1083200208, "kargh", "P", 1083200329, "kargh", "P", 1083200419, "kargh", "P", 1083200638, "kargh", "P", 1083200763, "kargh", "P", 1083202241, "kargh", "P", 1083243421, "kargh", "P", 1083243660, "kargh", "P", 1083247383, "kargh", "P", 1083247437, "kargh", "P", 1083247497, "kargh", "P", 1083248668, "kargh", "P", 1083248686, "kargh", "P", 1083249212, "kargh", "P", 1083334986, "kargh", "P", 1083335666, "kargh", "P", 1083336627, "kargh", "P", 1083337136, "kargh", "P", 1083338513, "kargh", "P", 1083339103, "kargh", "P", 1083339991, "kargh", "P", 1083372768, "kargh", "P", 1083373021, "kargh", "P", 1083373069, "kargh", "P", 1083373095, "kargh", "P", 1083373249, "kargh", "P", 1083373717, "kargh", "P", 1083443121, "kargh", "P", 1083444217, "kargh", "P", 1083553577, "kargh", "P", 1083593044, "kargh", "P", 1083605109, "kargh", "P", 1083605129, "kargh", "P", 1083605549, "kargh", "P", 1083976474, "kargh", "P", 1084068341, "zwoc", "P", 1084145536, "kargh", "P", 1084183527, "kargh", "P", 1084183630, "kargh", "P", 1084184142, "tangerine", "E", 1084184279, "tangerine", "E", 1084548083, "kargh", "P", 1084548531, "kargh", "P", 1084637305, "kargh", "P", 1085231647, "kargh", "P", 1085231658, "kargh", "P", 1085231689, "kargh", "P", 1085232544, "kargh", "P", 1085518010, "kargh", "P", 1085771279, "kargh", "P", 1086188092, "kargh", "P", 1086189645, "kargh", "P", 1086189655, "kargh", "P", 1095921742, "kargh", "P", 1095922796, "kargh", "P", 1095922917, "kargh", "P", 1095923190, "kargh", "P", 1095923392, "kargh", "P", 1095923507, "kargh", "P", 1095923579, "kargh", "P", 1095923635, "kargh", "P", 1098390991, "kargh", "P", 1100445485, "zwoc", "P", 1100445522, "zwoc", "P", 1100445921, "zwoc", "P", 1100445941, "zwoc", "P", 1100446301, "zwoc", "P", 1100707407, "zwoc", "P", 1100797471, "kargh", "P", 1100976918, "kargh", "P", 1100977061, "kargh", "P", 1100977181, "kargh", "P", 1100977341, "kargh", "P", 1100977439, "kargh", "P", 1100977901, "kargh", "P", 1100977954, "kargh", "P", 1100996239, "kargh", "P", 1100996356, "kargh", "P", 1101071872, "kargh", "P", 1101146892, "kargh", "P", 1101147146, "kargh", "P", 1101147312, "kargh", "P", 1101148020, "kargh", "P", 1103023832, "zwoc", "P", 1106881228, "kargh", "P", 1109535658, "zwoc", "P", 1109948741, "kargh", "P", 1110493711, "zwoc", "P", 1110495032, "zwoc", "P", 1120725728, "zwoc", "P", 1120726358, "zwoc", "P", 1120726470, "zwoc", "P", 1120726666, "zwoc", "P", 1120726726, "zwoc", "P", 1120726775, "zwoc", "P", 1120726917, "zwoc", "P", 1120727193, "zwoc", "P", 1120727379, "zwoc", "P", 1120727398, "zwoc", "P", 1120727474, "zwoc", "P", 1120728784, "zwoc", "P", 1120728842, "zwoc", "P", 1120728912, "zwoc", "P", 1120728969, "zwoc", "P", 1120729046, "zwoc", "P", 1120729091, "zwoc", "P", 1120763305, "zwoc", "P", 1120763345, "zwoc", "P", 1120763373, "zwoc", "P", 1120763511, "zwoc", "P", 1120763692, "zwoc", "P", 1120763740, "zwoc", "P", 1120763807, "zwoc", "P", 1120764119, "zwoc", "P", 1120764253, "zwoc", "P", 1120764344, "zwoc", "P", 1120764382, "zwoc", "P", 1120824817, "zwoc", "P", 1120824850, "zwoc", "P", 1120825072, "zwoc", "P", 1120825125, "zwoc", "P", 1120825511, "zwoc", "P", 1120826064, "zwoc", "P", 1120826109, "zwoc", "P", 1120826196, "zwoc", "P", 1120826256, "zwoc", "P", 1120826297, "zwoc", "P", 1120830310, "zwoc", "P", 1120959724, "zwoc", "P", 1120959747, "zwoc", "P", 1124129676, "zwoc", "P", 1124129738, "zwoc", "P", 1124483047, "zwoc", "P", 1124485780, "zwoc", "P", 1126813735, "kargh", "P", 1126815716, "kargh", "P", 1126817421, "kargh", "P", 1126818175, "kargh", "P", 1126818935, "kargh", "P", 1127172373, "zwoc", "P", 1127172436, "zwoc", "P", 1127172454, "zwoc", "P", 1129800866, "kargh", "P", 1130976601, "kargh", "P", 1131015798, "kargh", "P", 1131376219, "kargh", "P", 1131376412, "kargh", "P", 1131376665, "kargh", "P", 1131376711, "kargh", "P", 1131376741, "kargh", "P", 1131380130, "kargh", "P", 1131380272, "kargh", "P", 1133036034, "kargh", "P", 1133036174, "kargh", "P", 1133036243, "kargh", "P", 1133036316, "kargh", "P", 1133036385, "kargh", "P", 1133036427, "kargh", "P", 1133036469, "kargh", "P", 1133036503, "kargh", "P", 1133036544, "kargh", "P", 1133036765, "kargh", "P", 1133036847, "kargh", "P", 1133036886, "kargh", "P", 1133036985, "kargh", "P", 1133037212, "kargh", "P", 1133037249, "kargh", "P", 1133037371, "kargh", "P", 1133037551, "kargh", "P", 1133037585, "kargh", "P", 1133037723, "kargh", "P", 1135284356, "kargh", "P", 1139325247, "kargh", "P", 1139325329, "kargh", "P", 1139325400, "kargh", "P", 1139430299, "???", "P", 1139432324, "???", "P", 1140034434, "???", "P", 1140035531, "???", "P", 1140035602, "???", "P", 1142628173, "zwoc", "P", 1143376418, "zwoc", "P", 1143376472, "zwoc", "P", 1151185509, "zwoc", "P", 1151575432, "zwoc", "P", 1156120548, "nino", "P", 1156775561, "nino", "P", 1156775859, "nino", "P", 1156775863, "nino", "P", 1157666026, "nino", "P", 1157666174, "nino", "P", 1157666934, "nino", "P", 1176137662, "kargh", "P", 1199084145, "kargh", "P", 1306938121, "zwoc", "E" \})
      </Core:Property>
      <Core:Property property="{author}">"Aziel"</Core:Property>
      <Core:Property property="{email}">
         "kargh@eternalis.com"
      </Core:Property>
      <Core:Property property="{rev}">10</Core:Property>
      <Core:Property property="{sub_rev_stamp}">
         1306938121
      </Core:Property>
      <Core:Property property="{sub_rev}">45</Core:Property>
    </Core:PCProperties>
    <Notes:Notes/>
  </Core:PropertyContainer>
</object>
