<object clone="/obj/properties" owner="zwoc">
  <Core:PropertyContainer>
    <Ur:UrObject/>
    <Core:PCProperties>
      <Core:Property property="add_properties">
         (\{ "syntaxes", "returns", "retprops", "related", "examples", "description" \})
      </Core:Property>
      <Core:Property property="descript_properties">
         (\{ "Wrote syntax for function '\<fun\>()' as: \<fun\>( \<value\> ).\\nPlease describe the returned value(s) (if any). If none, simply type \\"\\"", "Wrote return value description for '\<fun\>()' as: \<value\>\\nReturn property type (e.g. \\"int\\" if the function returns an integer):", "Set return property type for '\<fun\>()' to \<value\>.\\nRefer to other related functions. Separate each reference with a comma.", "Referring '\<fun\>()' with \<count\> other functions: \<value\>.\\nExamples for '\<fun\>()': When you're done, say \\".\\"", "Added \<count\> lines of example text.\\nGeneral description of '\<fun\>()': When you're done, say \\".\\"", "Thank you! Your submission is appreciated!" \})
      </Core:Property>
      <Core:Property property="description">
         ([ "\$delay":"\$delay() is used to prematurely exit a script, and return to it a set amount of seconds later (wait, 1st argument), specified as a floating value (up to 60.0) or an integer value (no limit).\\r\\n\\r\\nNot only does the script exit, though, but if the script was called from another script, that script is returned the return value (return, 2nd argument).\\r\\nIf the script is an act/react/witness script, the first time a non-FALSE value is returned, the action will go through, as pointed out in the example(s) section below.\\r\\n\\r\\nOnly the first argument is required, second is optional, third is automatic.\\r\\nThe second value defaults to FALSE, the third value becomes a four-digit unique character identifier for the switch. Make careful note that no two \$delay() statements in a single script may contain two identical identifiers. The script will fail to compile with a \\"duplicate case labels in switch\\" error. Remove the third argument from the copied \$delay() statements and another identifier will be generated.\\r\\n\\r\\nNote: only \$variables and constants are maintained after a \$delay() returns control to a script. The following script would fail,\\r\\n\\r\\nstring s;\\r\\ns = \\"Hello world!\\";  /* s == \\"Hello world!\\" */\\r\\n\$delay( 1, FALSE );  /* s is reset */\\r\\nEmitTo( \$actor, s ); /* s is nil */\\r\\n\\r\\n- because the variable s is nil after the \$delay() call.\\r\\nSolve by storing the necessary variables in some appropriate object, or use \$variables.", "act":"Another extremely powerful function, this is how Merry commands some object to perform an action, optionally specified by an array of arguments. The argument \$silent can be sent as TRUE in order to suppress all output for (presumably) all signals.\\r\\n", "allocate":"Allocate an array with size number of elements. All elements are initialized to zero. The new array is returned.", "allocate_float":"Allocate an array with size elements.  All elements are initialized to 0.0.  The new array is returned.", "allocate_int":"Allocate an array with size elements. All elements are initialized to 0. The new array is returned.", "arr":"Return \<v\> in the form of an array. If \<v\> is an array already, \<v\> will be returned in its present state, otherwise (\{ \<v\> \}) is returned.", "arr_to_set":"Use arr_to_set to convert an array value to a mapping where each unique property in the array is an indice (key) in the resulting mapping.\\nAs mappings are automatically represented in alphabetical order, arr_to_set may for instance be used to sort an array of strings.\\nAs you see in the second example, applying map_indices to the result of an arr_to_set-call will result in an identical, but sorted, array.\\nTake note, however, that if any two values in an array are identical (which is valid for an array), these two values will be merged into a single value by arr_to_set, as indices must be unique.", "ascii_to_mixed":"Convert an ascii value into the appropriate property type.", "ascii_typeof":"Return a string representation of the property type of value.", "atan":"Return the arc tangent of the argument.\\n", "atan2":"Return the arc tangent of y/x, using the signs of the arguments to determine the quadrant of the result.\\n", "bilbo":"Merry can call Bilbo directly -- but as Merry at this point has exceeded bilbo in all/any aspect, it is recommended that you use this function scarcely; preferably never.", "break_paragraph":"For a fixed-size font, break str into lines each no longer than len characters, and start all of it with the string head.", "calculate_stamp":"Create a UNIX timestamp pointing to midnight, year \<year\>, day \<day\> of month \<month\>.", "call_other":"Call a function in an object.  The first argument must be either an object or a string.  If it is a string, call_object() will be called in the driver object to get the corresponding object.\\nOnly non-private functions can be called with call_other().  If the function is static, the object in which the function is called must be the same as the object from which the function is called, or the call will fail.\\nAny additional arguments to call_other() will be passed on to the called function.\\nIn LPC, obj-\>func(arg1, arg2, argn) can be used as a shorthand for call_other(obj, \\"func\\", arg1, arg2, argn).\\n", "call_out":"Call a function in the current object with a delay.  The function to be called must not be private.  The delay is specified in seconds.\\nThe minimum delay is 1 second; if the given delay is less, it is changed into 1 second.\\nThe returned value is the callout handle, an integer \> 0 which must be used if the callout is to be removed.\\n", "call_trace":"Return the function call trace as an array.  The elements are of the following format:\\n\\n(\{ objname, progname, function, line, extern, arg1, ..., argn \})\\n\\nThe line number is 0 if the function is in a compiled object.\\nExtern is 1 if the function was called with call_other(), and 0 otherwise.\\nThe last element of the returned array is the trace of the current function.\\n", "capitalize":"Make sure the first letter of str is capitalized.", "cardinal":"Convert a string expression of a cardinal number into an integer value.", "catch":"Execute the code for  until an error results, or until execution is complete.  If an error resulted, catch() will return the error message as a string; otherwise, it will return 0.\\nNote: catch() is not a real kfun.  catch(a, b) will evaluate the expression (a, b), rather than \\"call catch() with arguments a and b\\".\\n", "ceil":"Round the argument towards positive infinity.\\n", "char_to_string":"Convert a numeric character code value into a string.", "clear_by_int":"Clear the value in \<bigmap\> for the indice specified using integer identifier \<ix\>, effectively removing the map entry altogether.", "clear_by_ob":"Clear the value in \<bigmap\> for the indice specified using object identifier \<ob\>, effectively removing the map entry altogether.", "clear_by_str":"Clear the value in \<bigmap\> for the indice specified using string identifier \<str\>, effectively removing the map entry altogether.", "comma":"Make num readable by inserting a comma after every third digit.", "contains":"If sub is a sub-string of str, return TRUE, else FALSE.\\nThat is, if str contains sub.", "copy":"The copy() function is useful when modifying for instance arrays and/or mappings, to avoid harming the original source. VAR = ARRAY does not instantly create a copy of ARRAY, which means there is a slight chance that modifying VAR will also modify ARRAY (the original source).", "cos":"Return the cosine of the argument.\\n", "cosh":"Return the hyperbolic cosine of the argument.\\n", "crypt":"Encrypt a password, of which only the first 8 characters are significant.  If the optional second argument is given, its first two characters are used to perturb the encryption algorithm additionally; without one, the encryption is perturbed randomly.  The returned string is 13 characters long, the first two of which are equal to the used salt.\\n", "ctime":"Convert the specified time, which is an integer such as is returned by the kfun time(), into a string of the form \\"Tue Aug  3 14:40:18 1993\\".\\n", "days":"Generate a string value representation of the amount of days and hours since Jan 1st, 1970.", "decapitalize":"Make sure the first letter of str is lower case.", "desc_cardinal":"Describe the cardinal n in English.", "desc_ordinal":"Describe the ordinal n in English.", "describe":"Describe() is used to get string descriptions of objects, like \$actor, \$target, etc. in a merry script.\\r\\nIt can take multiple objects simultaneously as (\{ object one, object two, ... \}).\\r\\nIt can take an optional second parameter which will describe o in objective form.\\r\\nIf the second param is nil and the third parameter is o, Describe() will describe in first person (you).\\r\\nIf both the second and third parameters are o, Describe() will describe in possessive first person (yourself).\\r\\nThe fourth parameter is a flag that can optionally be set to:\\r\\nSTYLE_NONPOSS /* don't do the 'his frog' thing */\\r\\nSTYLE_DEFINITE /* the frog */\\r\\nSTYLE_REL_LOC /* the frog in his bag */\\r\\nSTYLE_FIRST_PERSON /* the frog in your bag */\\r\\nSTYLE_REDUCE_CHUNK /* avoid look frogs -\> four frogs */\\r\\nSTYLE_PRONOUN /* allow i.e. 'yourself' vs 'you' */\\r\\nSTYLE_NOCLUSTER /* (undocumented) */\\r\\nSTYLE_NO_SHOW_INVIS /* don't show unseen objects */\\r\\nSTYLE_WEAK_LOOKER /* don't replace Zell with You */\\r\\nSTYLE_IGNORE_VISIBILITY /* ignores luminosity from the actors p.o.v. */", "do":"Do..while loops work exactly like while-loops except that the condition is checked AFTER the block is executed, rather than before. This means the block will be executed at least once regardless.", "dump_value":"Convert any property into a string value.", "duplicate":"This function makes a copy of an existing object, just like the \\"Duplicate\\" button in WOE works.\\nFor a merryized version of +spawn, check out Spawn().", "emitto":"Merry command to emit a string of text to a single object.", "error":"Cause an error, which will stop execution. If the error is caught, execution will continue after the catch.\\n\\nNote that error() and Error() -- with only error() documented here -- do the exact same thing.", "every":"Every() is used to create an infinitely looping process.\\nIt returns an identifier string for the process it creates, and it takes two arguments,\\n- the timer:-script to execute\\n- the frequency in seconds\\n\\nThere is no need to do any loops on your own, like while( TRUE )\{ ... \}, when using Every(), but take note that the script is actually halted, and all variables it uses are reset each time it's called.\\nIt is also very important to keep track of the identifier string it returns, as without it you cannot ever turn off the loop.", "exp":"Return the exponential value of the given argument.\\n", "explode":"Return an array of substrings of str, divided by the given separator.\\nThe separators that str starts and ends with, if any, are not taken into account.\\n", "fabs":"Return the absolute value of the argument.\\n", "find_object":"The string argument is resolved as a file path, and the object with the resulting name is searched for.  Either the object, if found, or zero is returned.\\n", "findmerry":"FindMerry is used in cases where it is imperative to figure out 1) whether a particular Merry script is present in an object, and/or 2) where that Merry script is located.\\r\\n\\r\\nAs objects may have references for Merry scripts (aka \\"inherits\\"), the actual location of the script itself is at times not equal to the object nor either of its UrParents.", "first_elements":"Retrieve \<num\> number of elements from \<arr\>, starting at the beginning and moving toward the end resulting in the first \<num\> values of \<arr\>.", "flatten":"Convert a two-dimensional array -- e.g. (\{ (\{ 1 \}) \}) -- to a regular array through the use of the flatten() function.", "floor":"Round the argument towards negative infinity.\\n", "flt":"Convert an appropriate value to a float.\\nNote that this does not work with all properties.\\n- Strings must begin with a numeric character, and are truncated at the first non-numeric character (except points ('.')), including e.g. '+', '-', e.t.c.\\n- All floats and integers are applicable.\\n- No objects, arrays or mappings are applicable.", "fmod":"Return the value f, for which there exists an integer k such that\\nk * y + f == x, f has the same sign of x, and the absolute value of\\nf is less than the absolute value of y.\\n", "for":"for-loops are essentially a compression of the following:\\n---\\n/* for( \<x\>; \<y\>; \<z\> )\{ \<code\> \} */\\n\<x\>;\\nwhile( \<y\> )\{\\n\<code\>\\n\<z\>;\\n\}\\n---\\n\\nThey are traditional and frequently occuring in almost all programming languages. If the concept of for-loops still elude you, you may wish to look around on the internet for other, more verbose explanations.", "format_float":"Return f such that the result has dec decimal points.", "frexp":"The argument is split into a fraction f and an integer exponent n, such that either f == 0.0, or 0.5 \<= \| f \| \< 1.0, and f * 2 ** n == x.\\n(\{ f, n \}) is returned.  If x == 0.0, both f and n will be zero.\\n", "get":"Get() is used to retrieve a property from an object. It has a built-in shorter syntax as well,\\n\\nGet( x, \\"y\\" ) -\> x.\\"y\\"\\n\\nThe shorter version only works if y is an absolute string value (\\"abc\\" is absolute, \$property is not), otherwise the Get() function must be used.", "get_by_int":"Get a value from a bigmap mapping from a bigmap indice specified using an integer identifier.", "get_by_ob":"Get a value from a bigmap mapping from a bigmap indice specified using an object identifier.", "get_by_str":"Get a value from a bigmap mapping from a bigmap indice specified using a string identifier.", "get_day":"Derive the month day from the UNIX timestamp \<n\> and return this as an integer value.", "get_hour":"Return the hour as specified in the UNIX timestamp \<n\> as an integer value.", "get_minute":"Return the minutes passed since last new hour as specified in the UNIX timestamp \<n\> as an integer value.", "get_month":"Derive the month of the year from the UNIX timestamp \<n\> and return this as an integer value.", "get_second":"Return the seconds since last new minute as specified in the UNIX timestamp \<n\> as an integer value.", "get_year":"Return the year as specified in the UNIX timestamp \<n\> as an integer value.", "getvar":"GetVar() is used to retrieve the value of a variable with a name reference, usually used when the variable's name itself is unresolved at compile time.\\r\\n", "hash_crc16":"Compute the 16 bit Cyclic Redundancy Code of the concatenation of all string arguments, with polynomial:\\n\\nX^16 + X^12 + X^5 + 1\\n\\nCRC-16 is considered suitable for strings of up to a total of 4096 characters.\\n", "hash_md5":"Compute the 128 bit MD5 message digest of the concatenation of all string arguments.  The result is a string of 16 characters.\\n", "hex_digit":"Return the hexadecimal character of nibble, smaller than 16.", "humanized_date":"Extract a humanized date from a unix timestamp integer value, such as the one retrieved from time().", "if":"Mastering if-statements is an absolute necessity for any programmer of almost any language.\\nIf-statements occur regularly and are used to control and specify how a piece of code should react and handle various 'situations' (conditions) by scanning conditions and variables and acting based on the results.\\nBelow are a good amount of examples describing a good amount (but not all) of the various ways if-cases can be used in merry.\\nTake note, however, that things such as AND, OR, etc. are not exclusively used in if-statements (hence, it's not at all a bad idea to learn them all as soon as you can).", "implode":"Return a string, consisting of all string elements of the array arr concatenated, separated by the string separator.\\n", "index":"The index() function is used to retrieve the index position in an array of the first occurence of a value.\\nindex() will return the integer index position, or -1 if the value is not found anywhere in the array.", "int":"Convert an appropriate value to an integer.\\nNote that this does not work with all properties.\\n- Strings must begin with a numeric character, and are truncated at the first non-numeric character, including e.g. '+', '-', e.t.c. AND points ('.'), which are taken into account in Flt().\\n- All floats and integers are applicable.\\n- No objects, arrays or mappings are applicable.", "last_elements":"Retrieve \<num\> number of elements from \<arr\>, starting at the end and moving toward the beginning resulting in the last \<num\> values of \<arr\>.", "ldexp":"Return the value x * 2 ** n.\\n", "log":"Return the natural logarithm of the argument.\\n", "log10":"Return the logarithm of the argument to base 10.\\n", "lower_case":"Downcase each letter in str.", "make_url":"The make_url() function creates a string URL which includes page (\<base\>) and any amount of arguments (\<args\>).", "map_indices":"Return an array containing the indices of mapping map.\\n", "map_sizeof":"map_sizeof() is used to determine the size of a mapping.", "match":"Match a name (name) and any amount of adjectives (adj...) with a source's inventory (ob).", "matchplural":"Match a pname (plural name) and any amount of adjectives (adj...) with a source's inventory (ob).", "member":"To figure out whether an array contains a certain value, you use member(). The following:\\nfor( i = 0; i \< sizeof( a ); i++ )\\nif( a[i] == val ) \{\\n/* found it! */\\n\}\\nCould instead be written as:\\nif( member( val, a )) \{\\n/* found it! */\\n\}", "millitime":"Return the current time as an array (\{ time, fraction \}), where time is an integer denoting the current time in seconds, and fraction is a float in range [0.0 .. 1.0\>, denoting the fraction of the current second that has passed, with a resolution of 0.001.\\n", "mixed_to_ascii":"Convert any property to a string value.\\nNote that this function is a clone of dump_value().\\nFor examples and further information, read the 'dump_value' reference.", "modf":"Split the argument into a fraction f and an integer part n, such that \| f \| \< 1.0, and f + n == x.  (\{ f, n \}) is returned.  Note that n is returned as a float, and may not be representable in type int.\\n", "name":"The name() function is used to retrieve the string reference of an object.", "newnref":"Create a new NRef for an object.", "nrefdetail":"Find out the detail ID an NRef is referring to.", "nrefob":"Figure out which object an NRef is referring to.", "nrefsequal":"NRefsEqual is used to check whether two NRefs are equal.\\nNote that 'if( NRef1 == NRef2 )' will always return FALSE, regardless.\\nHence, you must do 'if( NRefsEqual( NRef1, NRef2 ))' instead.", "num":"Turn a string value \<v\> into a float or integer value. The function will cause an error if \<v\> is not convertable.", "number_digit":"Convert any numeric value into a one-digit number, based on the character code position (ASCII, in this case), into the numeric value it represents. \\r\\n'5', the char, equals 53, the numeric value. \\r\\nnumber_digit( 53 ) equals 5, the numeric value.", "obj":"Obj() is used to retrieve an object's reference through the object's string-name.\\nFor instance, if you have a string objectname, which contains the name of an object you need to access, you could do ob = Obj( objectname );\\nIf the objectname is user-specified, you mustn't count on its validity; if the object \<objectname\> does not exist, Obj() will return nil. if( !ob ) /* object not exist error handling */\\nIf the object is static, i.e. the name of the object is predetermined and won't ever change, you are encouraged to use the syntax \$\{objectname\} instead. This is the exact same thing as Obj() except that a reference in \$\{\}'s will be updated automatically if the object is ever renamed.", "object_name":"Return the name of object obj.\\n", "oneof":"Similar to the SAM oneof, \{One\|two\|three\}, oneof() can be used to produce a random string based on a number of alternatives.", "ordinal":"Convert a string expression of an ordinal number into an integer value.", "pad_left":"Pad var with spaces to the left, so that the result is size long.", "pad_right":"Pad var with spaces to the right, so that the result is size long.", "parse_string":"Parse a string as described by the grammar. The format of the grammar is described in the document called 'Parsing'. If parsing is successful, the parse tree is returned as an array. The optional third argument specifies the number of alternative parse trees to integrate in the result, if the grammar is ambiguous. parse_string() uses internal object storage to cache grammars and generated automatons, which is not removed until the object is destructed.\\nThis function cannot be used from a user or editor object.\\n\\nNote:\\nThe parse_string kfun is a very powerful parser to which you supply a grammar of your choice. It's reminiscent of lex and yacc if you've used them before. DGD's parse_string, unlike most parsers, keeps track of all your ambiguous matches. That fact is both a great power and a great responsibility.\\n\\nWhat that means is that if your grammar allows something to be parsed a couple of different ways then DGD will keep track of them all while parsing. If there are two ways to parse a double-if statement with else (the else can go with either if) in your grammar, and you feed parse_string a chunk with fifteen of those, you'll find that DGD is keeping track of 2^15 (that's around 32,000) different interpretations of your file. Then it will cheerfully return only the first. That's slow, just in case you hadn't guessed.\\n\\nHowever, sometimes you want ambiguous parsing. For instance, you may have a natural language parser for player commands, and you'd like the player to be able to type \\"get down\\" and have it mean either of \\"get down from the platform\\" or \\"take the down pillow\\" according to two different grammar rules. DGD's parse_string will return both parses, and you can decide which makes more sense where the player is standing at the time. Most parsers won't do this for you. Lucky you found DGD, hey?\\n\\nA fellow named Steve Foley has graciously put together a tutorial on parse_string, with the aid of our own Nino (Erwin Harte). You can find it at http://www.mindspring.com/~zeppo1/parse_string.html\\n", "parsexml":"ParseXML() is used to convert an XML string to the appropriate value (a SAM-string, for instance).\\nLike the Bilbo \$sam(), ParseXML() used with UnSAM() constitute Merry's portal to the XML/SAM engine. It's not going to be used as much as Bilbo's is, because SAM has few abilities that Merry does not have natively. To emulate \$sam(foo), use UnSAM(ParseXML(\\"foo\\")).\\n\\nThe real use of UnSAM() is to handle binary SAM data stored in e.g. descriptions. If you have a room with a description containing oneof's, for example, and you want to create a text representation of this, you'd want to do something like,\\nstr = UnSAM(Get(this, \\"details:default:description:examine\\"));", "popup":"There is a new Merry function called Popup(). If the user is running an official Skotos client (Java, Zealous or Alice) this will cause a browser window to pop up for the player, filled with whatever content you specify. For example,\\n\\nPopup(\$actor, \$actor.\\"base:environment\\", \\"painting\\");\\nwill popup a window to \$actor, displaying the contents of the property html:painting in the actor's current room.\\n\\nUnsurprisingly, popup window content is written in HTML, and we're lucky in that SAM -- which we normally use to write text description -- is closely related to HTML.\\n\\nAs an example, we might have...\\n\\nroom.html:painting = X[S]\\n\<BODY bgcolor=\\"black\\"\>\\n\<IMG src=\\"http://www.mydomain.com/images/painting.jpg\\"/\>\\n\</BODY\>\\n\\nwhich wouldn't look good -- it'd be up to you to do cook up some nice looking stylesheet, or something -- but you get the idea.\\n\\nOf course, SAM can do more than just represent static HTML. SAM for popups can use the same active tags that it does for text... we can pull values from the room and apply logic to the values. For example, display different paintings depending on the light level of the room...\\n\\nroom.html:painting = X[S]\\n\<BODY bgcolor=\\"\$(this.painting:bgcolor)\\"\>\\n\{? \| \$this.base:dark \|\\n\<IMG src=\\"http://www.mydomain.com/images/painting-in-dark.jpg\\"/\> \|\\n\<IMG src=\\"http://www.mydomain.com/images/painting-in-light.jpg\\"/\>\\n\}\\n\</BODY\>\\n\\nAgain, you get the basic idea.\\n\\nThese popups are built on top of a general way for browsers to fetch the value of a property from an in-game object. This system a special form of the basic URL syntax you are used to from browsing the web. A URL that fetches the property 'html:painting' from 'Zell:Rooms:PaintingRoom' and displays it would look like, /SAM/Prop/Zell:Rooms:PaintingRoom/painting and that is in fact precisely the URL constructed by the Popup() call in Merry, above.\\n\\nThe special format of this URL allows us to use relative linking in a very handy way. Let's add a hyperlink to our example:\\n\\nroom.html:painting = X[S]\\n\<BODY bgcolor=\\"\$(this.painting:bgcolor)\\"\>\\n\<A href=\\"painting-closeup\\"\>\\n\{? \| \$this.base:dark \|\\n\<IMG src=\\"http://www.mydomain.com/images/painting-in-dark.jpg\\"/\> \|\\n\<IMG src=\\"http://www.mydomain.com/images/painting-in-light.jpg\\"/\>\\n\}\\n\</A\>\\n\</BODY\>\\n\\nYou will note that the 'href' attribute of the link is a relative URL. The browser will automatically expand this to /SAM/Prop/Zell:Rooms:PaintingRoom/painting-closeup and so if you click on the link, you will be taken to the contents of the property 'html:painting-closeup' in the same object as 'html:painting' is already defined. This makes it easy to create links that navigate between web properties in a single object.\\n\\nFor further complexity, Merry can now be embedded anywhere in SAM -- either to be included in the stream of text, or as attribute value to another SAM tag. For example, let's say we want to automate the example above with different paintings even further. We could dynamically create the URL from the derived property base:light-category:\\n\\nroom.html:painting = X[S]\\n\<BODY bgcolor=\\"black\\"\>\\n\<IMG src='\$[\\n/* MERRY: add the light category into the middle of the URL */\\n\\"http://www.mydomain.com/images/painting-\\" +\\n\$this.\\"base:light-category\\" +\\n\\".jpg\\"\\n]'/\>\\n\</BODY\>\\n\\nThings get -really- exciting when you begin to use the zform and zact SAM tags, which allow a Merry script to be executed on the server when the user hits a submit button or a link. This means popups can contain controls, such as start story configuration panels.", "pow":"Return x to the power y.\\n", "pre":"Use PRE() to get the equivalent of the HTML \<PRE\> tag.", "prefixed_map":"Extract all elements from map where the indice (key) begins with prefix.\\nThere are known issues with mappings that contain non-alphanumeric characters, that may result in invalid results for this specific function.", "previous_object":"Return the object n+1 (default: 1) steps back in the call_other chain.\\nIf the object is destructed, or the number of steps is larger than the number of call_others involved, zero is returned.\\n", "previous_program":"Return the name of the object with the function n+1 (default: 1) steps back in the function call chain.  If the number of steps is larger than the number of function calls involved, nil is returned.\\n", "proper":"Make sure the first letter of each space-delimited word in str is capitalized.", "query_colour":"I'm honestly unsure what this function does but am adding it as a placeholder for now. A SAM string will return \\"17\\" while, as far as I can see, any other property will return 0. ", "query_editor":"Return the editor status of an object.  This is either \\"command\\", if the editor instance is in command mode, \\"insert\\", if the editor instance is in input mode, or 0, if there is no editor instance for the given object.\\n", "query_ip_name":"Return the IP name of a user, as a string, or nil if the given object is not a user object.  If the IP name could not be resolved, the IP number is returned, instead.\\n", "query_ip_number":"Return the ip number of a user, as a string, or 0 if the given object is not a user object.", "random":"Return a positive random number between 0 and integer specified within () minus 1.\\r\\nThe example would return a random number between 1 and 5 due to the modifier of +1.\\r\\nIf modifier is less than 1, 0 is returned.", "replace_html":"Use replace_html() to escape HTML.", "replace_strings":"Replace substrings in str given in swaps.", "replace_xml":"Escape a string, adding a backslash character before any character significant to SAM.", "restore_object":"Restore all global variables in an object that are not private or static from a file.  All variables which qualify, but were not restored and do not contain object values, will be set to 0.  1 is returned if the variables could be restored, 0 otherwise.\\n", "reverse":"Reverse the array \<orig\>, result being an array listing the values of \<orig\> backwards.", "reverse_lookup":"Mappings are sequences of pairs, each pair containing an indice (key) and a value. The ordinary way to read from a map is to read the values by providing the indice - map[\<indice\>] == \<value\>. The reverse_lookup function is used to read the indices by providing the values.", "reverse_mapping":"Reverse a mapping by setting indice-\>value, and value-\>indice.\\nNote that if a mapping contains several identical values, such as ([ \\"foo\\" : \\"bar\\", \\"foo2\\" : \\"bar\\" ]), a call to reverse_mapping will result in a \\"mapping is not injective\\" runtime error.", "rfc_1123_date":"Extract a UNIX time stamp date as a string, formatted RFC-1123 compliant.", "save_object":"Save all global variables in an object that are not private or static to a file.  Only non-zero and non-object values are actually saved.\\n", "set":"Set() is used to set a property in an object to a value. It has a built-in shorter syntax as well,\\n\\nSet( x, \\"y\\", z ) -\> x.\\"y\\" = z;\\n\\nThe shorter version only works if y is an absolute string value (\\"abc\\" is absolute, \$property is not), otherwise the Set() function must be used.", "set_by_int":"Set the value in \<bigmap\> for the indice specified using integer identifier \<ix\> to \<val\>.", "set_by_ob":"Set the value in \<bigmap\> for the indice specified using object identifier \<ob\> to \<val\>.", "set_by_str":"Set the value in \<bigmap\> for the indice specified using string identifier \<str\> to \<val\>.", "setvar":"SetVar() is used to set the value of a variable with a possibly constructed name, usually used when the variable's name is unresolved at compile time.", "short_time":"Extract a brief string version of a UNIX timestamp date (stamp).", "sin":"Return the sine of the argument.\\n", "sinh":"Return the hyperbolic sine of the argument.\\n", "sizeof":"sizeof() is used to determine the size of an array.", "slay":"Slay() undoes what Spawn() does.\\nA word of warning though: there is no such thing as a 'trashcan'.\\nKnow what you're doing.", "smalltime":"Return the hour and minute of the UNIX timestamp date (stamp).", "social":"Social() is a shortcut for what could actually be accomplished through the use of Act(), by calling the \\"social\\" action. However, the social action is complex enough and socials are so common that this convenience function is quite warranted. Note that this executes real socials, not just emits. This means all the signals and scripts associated with the social are run as well.\\nSocial() can take a good amount of argument and can generate any results with the parser that any regular player can.\\nOnly the first two arguments are required: the object to command, and the verb to execute. The adverbs and evokes should be straight-forward. The last string of arguments specify the different targets and at least for now, more than one pair of preposition and object should be quite rare.\\nIn some cases, though, when a Social() doesn't seem to do what you ask, you may have to look into Act().\\n\\n(Hack) Set the property \$(adverb:position) to one of the following, right before the call to Social() to determine the position of the adverb:\\nPRE_VERB     = \\"pv\\"  e.g. 'happily wave the sword'\\nPRE_ROLE     = \\"pr\\"  e.g. 'wave happily to the creature'\\nPRE_PREP     = \\"pp\\"  e.g. 'wave the sword angrily at the mutant'\\nPRE_EVOKE    = \\"pe\\"  e.g. 'wave the sword at the mutant angrily'\\n\\nE.g.:\\n\$(adverb:position) = PRE_VERB;\\nSocial( \$actor, \\"smile\\", \\"happily\\", \\"Hi Charles!\\" ); -\> You happily smile, \\"Hi Charles!\\"\\n", "spaces":"Return a string of num spaces.", "spawn":"Extremely straight-forward, this is how we generate new objects. Merry can only create spawns of existing ur-objects, though this limitation may go out the door in time. The spawn behaves exactly as spawns do throughout the Skotos system.", "sqrt":"Return the square root of the argument.\\n", "sscanf":"Parse the string str, using the format string fmt.  The following character sequences have a special meaning in the format string:\\n\\n%s   match a substring\\n%d   match a number\\n%f   match a floating-point number\\n%c   match a character\\n%%   match single %\\n\\nOther characters must be matched exactly.  %*s, %*d, %*f and %*c can be used to match without assignment.  Matched substrings and numbers are assigned to the successive lvalue arguments following the format string.  The number of matched substrings and numbers is returned.\\n", "status":"Called without an argument, this kfun returns information about resources used by the system.  With an object as argument, resource usage by that object is given.  The returned value is an array, the fields of which are described in the include file .\\n", "stop":"Stop() is used to terminate a running loop, instantiated using the Every() function.\\nIt takes the identifier string returned by the Every() function as single argument.", "str":"Convert an appropriate value to a string.\\nNote that this does not work with all properties.\\n- All strings, floats, integers and objects are applicable.\\n- No arrays or mappings are applicable.", "string_to_hex":"Return the hexadecimal representation of bytes.", "strip":"Strip whitespace from both sides of str.", "strip_left":"Strip whitespace from the left of str.", "strip_right":"Strip whitespace from the right of str.", "strlen":"Return the length of string s.", "switch":"The switch() statement is in a way an extension of if(). For example,\\nif( \$a == 1 ) EmitTo( \$actor, \\"One\\" );\\nif( \$a == 2 ) EmitTo( \$actor, \\"Two\\" );\\nif( \$a == 3 ) EmitTo( \$actor, \\"Three\\" );\\n- can also be written as,\\nswitch( \$a )\{\\ncase 1: EmitTo( \$actor, \\"One\\" ); break;\\ncase 2: EmitTo( \$actor, \\"Two\\" ); break;\\ncase 3: EmitTo( \$actor, \\"Three\\" ); break;\\n\}\\n\\nWithin the switch() block, the case and default keywords are used to check conditions, both concluded using the break keyword. Several case statements can be made in which case the code after the first TRUE case statement is executed regardless until the next break. Example:\\n\\nswitch( \$a )\{\\ncase 1: EmitTo( \$actor, \\"One.\\" ); /* no break; */\\ncase 2: EmitTo( \$actor, \\"Two.\\" ); break;\\ncase 3: EmitTo( \$actor, \\"Three.\\" ); break;\\n\}\\nIf \$a is 1, the output will be \\"One.\\" followed by \\"Two.\\" but if \$a is 2 the output will be \\"Two.\\" only.\\nIf \$a is 3, the output will be \\"Three.\\" only.", "tabulate":"For a fixed-sized font, render the arrays in arrlist in a table.", "tag":"Use TAG() to colorize text using the client user's preset theme colors.", "tan":"Return the tangent of the argument.\\n\\nNote:\\nFor values close to a multiple of PI/2, the result may be inaccurate.\\n", "tanh":"Return the hyperbolic tangent of the argument.\\n", "this_object":"The this_object() function returns the internal object name for 'this'.", "time":"Return the current time as an integer.  The time can be converted into a string with the kfun ctime().\\n", "to_hex":"Transform a sequence of characters (a string) into a sequence of hexadecimal values.", "typeof":"Return the type of a value.  The return values are declared in the include file.\\r\\n", "unsam":"UnSAM() is used to convert a SAM-string into a regular string.\\r\\nLike the Bilbo \$sam(), ParseXML() used with UnSAM() constitute Merry's portal to the XML/SAM engine. It's not going to be used as much as Bilbo's is, because SAM has few abilities that Merry does not have natively. To emulate \$sam(foo), use UnSAM(ParseXML(\\"foo\\")).\\r\\n\\r\\nThe real use of UnSAM() is to handle binary SAM data stored in e.g. descriptions. If you have a room with a description containing oneof's, for example, and you want to create a text representation of this, you'd want to do something like,\\r\\nstr = UnSAM(Get(this, \\"details:default:description:examine\\"));", "upper_case":"Capitalize (uppercase) every letter in str.", "ur_name":"Objects in SkotOS have two \\"names.\\" One is the ur-name, which never changes. The other is the woename, which can be modified at the whim of the staff.", "while":"While-loops are used when a block of code needs to be repeated until certain condition requirements are met." ])
      </Core:Property>
      <Core:Property property="examples">
         ([ "\$delay":"Example act:smile in the actor:\\r\\n----------------------------\\r\\nEmitTo( \$actor, \\"You won't smile ever, cause we return FALSE below.\\" );\\r\\n\$delay( 1, FALSE );\\r\\n----------------------------\\r\\n\\r\\nExample act:smile in the actor:\\r\\n----------------------------\\r\\nEmitTo( \$actor, \\"You will smile after seeing this message, because we return TRUE below.\\" );\\r\\n\$delay( 1, TRUE );\\r\\n----------------------------\\r\\n", "acos":"Merry code: acos(0.0)\\nMerry result: 1.5707963\\n\\nMerry code: acos( 0.5 )\\nMerry result: 1.0471976\\n\\nMerry code: acos( 1.0 )\\nMerry result: 0.0", "act":"Act( \$actor, \\"drop\\", \$what: sword_objects, \$into: container_object );\\r\\n\\r\\n(see TWiki page on signals for more verbose information on what exactly you can do with what)", "allocate":"Merry code: allocate(5)\\nMerry result: (\{ nil, nil, nil, nil, nil \})", "allocate_float":"Merry code: allocate_float(5)\\nMerry result: (\{ 0.0, 0.0, 0.0, 0.0, 0.0 \})", "allocate_int":"Merry code: allocate_int(5)\\nMerry result: (\{ 0, 0, 0, 0, 0 \})", "arr":"Merry code:   Arr( \\"Hello\\" )\\r\\nMerry result: (\{ \\"Hello\\" \})\\r\\n\\r\\nMerry code:   Arr( (\{ \\"Hello\\" \}) )\\r\\nMerry result: (\{ \\"Hello\\" \})", "arr_to_set":"Merry code:   arr_to_set( (\{ \\"Kalle\\", \\"Anders\\", \\"Erik\\", \\"Maria\\" \}) )\\nMerry result: ([ \\"Anders\\":1, \\"Erik\\":1, \\"Kalle\\":1, \\"Maria\\":1 ])\\nMerry code:   map_indices( arr_to_set( (\{ \\"Kalle\\", \\"Anders\\", \\"Erik\\", \\"Maria\\" \}) ))\\nMerry result: (\{ \\"Anders\\", \\"Erik\\", \\"Kalle\\", \\"Maria\\" \})", "ascii_to_mixed":"Merry code:   ascii_to_mixed( \\"15\\" )\\nMerry result: 15\\n\\nMerry code:   ascii_to_mixed( \\"(\{ \\\\\\"a\\\\\\", \\\\\\"cute\\\\\\", \\\\\\"array!\\\\\\" \})\\" )\\nMerry result: (\{ \\"a\\", \\"cute\\", \\"array!\\" \})\\n\\nMerry code:   ascii_to_mixed( \\"\<Marrach:players:K:kalle\>\\" )\\nMerry result: \<Marrach:players:K:kalle\>", "ascii_typeof":"ascii_typeof( nil ) == \\"nil\\"\\nascii_typeof( 123 ) == \\"int\\"\\nascii_typeof( 3.14 ) == \\"float\\"\\nascii_typeof( \\"abc\\" ) == \\"string\\"\\nascii_typeof( \$actor ) == \\"object\\"\\nascii_typeof( (\{ \\"a\\", \\"b\\", \\"c\\" \}) ) == \\"array\\"\\nascii_typeof( ([ \\"foo\\" : \\"bar\\" ]) ) == \\"mapping\\"", "asin":"Merry code:   asin(0.0)\\nMerry result: 0.0\\n\\nMerry code:   asin(0.5)\\nMerry result: 0.52359878\\n\\nMerry code:   asin(1.0)\\nMerry result: 1.5707963", "atan":"Merry code:   atan(0.0)\\nMerry result: 0.0\\n\\nMerry code:   atan(0.5)\\nMerry result: 0.46364761\\n\\nMerry code:   atan(1.0)\\nMerry result: 0.78539816", "atan2":"Merry code:   atan2(0.0, 0.0)\\nMerry result: 0.0\\n\\nMerry code:   atan2(1.0, 0.0)\\nMerry result: 1.5707963\\n\\nMerry code:   atan2(0.0,1.0)\\nMerry result: 0.0\\n\\nMerry code:   atan2(1.0,1.0)\\nMerry result: 0.78539816\\n", "bilbo":"Bilbo( \$actor, \\"react\\", \\"smile\\" ); /* will execute bilbo:react:smile found in \$actor */", "break_paragraph":"Merry code: break_paragraph( \\"You say: \\", \\"sputnik was a  satellite\\", 20 )\\nMerry result: \\"You say: sputnik was\\\\n         a satellite\\\\n\\"\\n- which renders to\\nYou say: sputnik was\\na satellite\\n(note that \\"a satellite\\" is directly below \\"sputnik was\\" if pre-formated)", "calculate_stamp":"Merry code:   calculate_stamp( 1980, 9, 24 )\\r\\nMerry result: 338616000\\r\\n\\r\\nMerry code:   ctime( 338616000 ) + \\", Kalle was born.\\"\\r\\nMerry result: \\"Wed Sep 24 00:00:00 1980, Kalle was born.\\"", "call":"Merry's means of calling other Merry functions. If the script argument is e.g. 'checktimer', the property search will be for merry:lib:checktimer; there is no way to avoid the 'lib' portion. All functions that are callable in Merry must exist in the 'lib' namespace. This makes sense, as you will see in time.\\r\\n\\r\\nThe third argument is on precisely the same format as in Act. For example, if you do\\r\\n\\r\\nCall(this, \\"inflict\\", \$damage: 100);\\r\\n\\r\\nthen the merry:lib:inflict script will be called from the current object, and inside this script \$damage will contain the integer value 100. The local value is not changed, so after\\r\\n\\r\\n\$damage = 50;\\r\\nCall(this, \\"inflict\\", \$damage: 100);\\r\\n\$damage will still be 50.\\r\\n\\r\\nTo call a script from inside a different object:\\r\\n\\r\\nCall(\$\{objectname\}, \\"scriptname\\");", "call_trace":"Merry code:   call_trace()\\nMerry result: (\{ (\{ \\"/kernel/obj/binary#10769\\", \\"/kernel/obj/binary\\", \\"receive_message\\", 85, 1 \}), (\{ \\"/kernel/obj/binary#10769\\", \\"/kernel/lib/connection\\", \\"receive_message\\", 233, 0 \}), (\{ \\"/usr/TextIF/obj/user#10798\\", \\"/usr/TextIF/obj/user\\", \\"receive_message\\", 371, 1 \}), (\{ \\"/usr/TextIF/obj/user#10798\\", \\"/usr/TextIF/obj/user\\", \\"receive_line\\", 720, 0 \}), (\{ \\"/usr/TextIF/obj/user#10798\\", \\"/kernel/lib/auto\\", \\"call_limited\\", 719, 0 \}), (\{ \\"/usr/TextIF/obj/user#10798\\", \\"/kernel/lib/auto\\", \\"_F_call_limited\\", 698, 0 \}), (\{ \\"/usr/TextIF/obj/user#10798\\", \\"/usr/TextIF/obj/user\\", \\"parse_command\\", 812, 1 \}), (\{ \\"/usr/TextIF/main\\", \\"/usr/TextIF/main\\", \\"command\\", 230, 1 \}), (\{ \\"/usr/Tool/sys/tool\\", \\"/usr/Tool/sys/tool\\", \\"cmd_DEV_tool\\", 117, 1 \}), (\{ \\"/usr/Tool/sys/merry\\", \\"/usr/Tool/lib/merry\\", \\"cmd_merry_eval\\", 133, 1 \}), (\{ \\"/usr/Tool/sys/merry\\", \\"/usr/Tool/lib/merry\\", \\"run_merry_code\\", 45, 0 \}), (\{ \\"/usr/SkotOS/data/merry#-1\\", \\"/usr/SkotOS/data/merry\\", \\"evaluate\\", 223, 1, (\{ \<Chatters:LC:ch:allen-christopher\>, nil, nil, ([ \\"actor\\":\<Chatters:LC:ch:allen-christopher\>, \\"body\\":\<Chatters:LC:ch:allen-christopher\>, \\"here\\":\<Examples:complete:desc:room-go-nowhere\>, \\"looker\\":\<Chatters:LC:ch:allen-christopher\> ]), nil \}) \}), (\{ \\"/usr/SkotOS/merry/c8a82e895d135325ccf56f4106de1b80\\", \\"/usr/SkotOS/lib/merrynode\\", \\"evaluate\\", 56, 1, \<Chatters:LC:ch:allen-christopher\>, nil, nil, @14, nil, nil \}), (\{ \\"/usr/SkotOS/merry/c8a82e895d135325ccf56f4106de1b80\\", \\"/usr/SkotOS/merry/c8a82e895d135325ccf56f4106de1b80\\", \\"merry\\", 6, 1, nil, nil, \\"virgin\\" \}), (\{ \\"/usr/SkotOS/merry/c8a82e895d135325ccf56f4106de1b80\\", \\"/kernel/lib/auto\\", \\"call_trace\\", 524, 0 \}) \})\\n", "capitalize":"\\"zell\\" -\> \\"Zell\\"", "cardinal":"Merry code:   cardinal( \\"one\\" )\\r\\nMerry result: 1\\r\\n\\r\\nMerry code:   cardinal( \\"five\\" )\\r\\nMerry result: 5\\r\\n\\r\\nMerry code:   cardinal( \\"fiftytwo\\" )\\r\\nMerry result: 52\\r\\n\\r\\nMerry code:   cardinal( \\"ninetynine\\" )\\r\\nMerry result: 99", "ceil":"Merry code:   ceil(14.1)\\nMerry result: 15.0\\n\\n", "char_to_string":"Merry code:   char_to_string( 'A' )\\r\\nMerry result: \\"A\\"\\r\\n\\r\\nMerry code:   char_to_string( 65 )\\r\\nMerry result: \\"A\\"", "comma":"Merry code: comma( 1344266 )\\nMerry result: \\"1,344,266\\"", "contains":"Merry code: contains( \\"foobar\\", \\"ob\\" )\\nMerry result: TRUE", "copy":"Merry code: copy( \\"abc\\" )\\nMerry result: \\"abc\\nMerry code: copy( (\{ \\"a\\", \\"b\\", \\"c\\" \}) )\\nMerry result: (\{ \\"a\\", \\"b\\", \\"c\\" \})\\nMerry code: copy( \$actor )\\nMerry result: \<Marrach:players:K:kalle\>", "cos":"Merry code:   cos(0.0)\\nMerry result: 1.0\\n\\nMerry code:   cos(0.5)\\nMerry result: 0.87758256\\n\\nMerry code:   cos(1.0)\\nMerry result: 0.54030231\\n", "cosh":"Merry code:   cosh(0.0)\\nMerry result: 1.0\\n\\nMerry code:   cosh(0.5)\\nMerry result: 1.127626\\n\\nMerry code:   cosh(1.0)\\nMerry result: 1.5430806\\n", "crypt":"Merry code:   crypt(\\"test\\")\\nMerry result: \\"MKfcAguU0/rhs\\"\\n\\nMerry code:   crypt(\\"test\\", \\"te\\")\\nMerry result: \\"teH0wLIpW0gyQ\\"\\n", "ctime":"Merry code:   ctime(0)\\nMerry result: \\"Wed Dec 31 19:00:00 1969\\"\\n\\nMerry code:   ctime(time())\\nMerry result: \\"Fri Apr  4 19:38:09 2003\\"\\n", "days":"Merry code:   days( time() )\\nMerry result: \\"12203 d, 12 h\\"", "decapitalize":"\\"Chocolate\\" -\> \\"chocolate\\"", "desc_cardinal":"123 -\> \\"one hundred twenty-three\\"", "desc_ordinal":"123 -\> \\"one hundred twenty-third\\"", "describe":"Examples using the first and second parameters:\\r\\nDescribe( \$actor ) -\> \\"StoryCoder Kalle\\"\\r\\nDescribe( \$actor, \$actor ) -\> \\"him\\"\\r\\nDescribe( \$actor, nil, \$actor ) -\> \\"you\\"\\r\\nDescribe( \$actor, \$actor, \$actor ) -\> \\"yourself\\"", "dgd_version":"Merry code:   dgd_version()\\r\\nMerry result: 12071", "do":"Example #1:\\n-----------\\nint i;\\n\\ni = 0;\\ndo \{\\ni ++;\\nEmitTo( \$actor, \\"i is now \\"+Str(i) );\\n\} while( i \< 10 );\\nEmitTo( \$actor, Str(i)+\\" is NOT less than 10, so the do..while-loop has ended.\\" );\\n----------\\n\\nResult:\\n-------\\ni is now 1\\ni is now 2\\ni is now 3\\ni is now 4\\ni is now 5\\ni is now 6\\ni is now 7\\ni is now 8\\ni is now 9\\ni is now 10\\n10 is NOT less than 10, so the do..while-loop has ended.\\n-------\\n\\nExample #2:\\n-----------\\nint i = 0;\\ndo \{\\ni++;\\nEmitTo( \$actor, \\"i is \\"+Str(i) );\\n\} while( FALSE );\\nEmitTo( \$actor, \\"Loop has ended with i at \\"+Str(i)+\\".\\" );\\n----------\\n\\nResult:\\n-------\\ni is 1\\nLoop has ended with i at 1.", "dump_value":"Merry code:   dump_value( \$actor )\\nMerry result: \\"\<Marrach:players:K:kalle\>\\"\\n\\nMerry code:   dump_value( args )\\nMerry result: \\"([ \\\\\\"actor\\\\\\":\<Marrach:players:K:kalle\>, \\\\\\"body\\\\\\":\<Marrach:players:K:kalle\>, \\\\\\"here\\\\\\":\<Marrach:Coders:kalle:rooms:home\>, \\\\\\"looker\\\\\\":\<Marrach:players:K:kalle\>, \\\\\\"this\\\\\\":\<Marrach:players:K:kalle\> ])\\"", "duplicate":"\$copy_of_Generic_drink_mug_coffee = Duplicate( \$\{Generic:drink:mug-coffee\} );\\n\$copy_of_Generic_drink_mug_coffee.\\"base:objectname\\" = \\"Marrach:Coders:kalle:my_own_coffee_object\\";", "emitin":"Merry command to emit a string of text into an environment, such as a room.\\nExample:\\nEmitIn( \$actor.\\"base:environment\\", \\"This goes to everyone in the same room as \$actor.\\" );\\nEmitIn( \$actor.\\"base:environment\\", \\"This also goes to everyone in \$actor's presence, except \$actor himself.\\", \$actor );", "emitto":"EmitTo( \$actor, \\"Tag! You're it!\\" );", "every":"[Also see C. Allen's example torch at: Examples:complete:light:torch]\\n\\nExample script timer:my_loop\\n----------------------------\\n/* my_loop is executed once every Nth second, specified\\nin the Every() call below. */\\nEmitTo( \$\{Marrach:players:K:kalle\}, \\"Alive and kicking!\\" );\\n/* \$actor isn't defined here, so we emit directly instead */\\n----------------------------\\n\\nExample script lib:start_my_loop\\n--------------------------------\\n/* To make sure we don't \\"screw up\\" and lose an identifier, we check if a loop is running already, and stop it automagically on our own if it is */\\nif( \$actor.\\"my_loop:identifier\\" ) Call( this, \\"stop_my_loop\\" );\\n\\nEmitTo( \$actor, \\"Initiating loop. Call stop_my_loop to stop it!\\" );\\n\$actor.\\"my_loop:identifier\\" = Every( \\"my_loop\\", 60 );\\n/* we must remember that identifier...! */\\n--------------------------------\\n\\nExample script lib:stop_my_loop\\n-------------------------------\\nEmitTo( \$actor, \\"Stopping loop!\\" );\\nif( !\$actor.\\"my_loop:identifier\\" )\{\\nEmitTo( \$actor, \\"Whoops! No loop found!\\" );\\nreturn FALSE;\\n\}\\nStop( \$actor.\\"my_loop:identifier\\" );\\n\$actor.\\"my_loop:identifier\\" = nil;\\nEmitTo( \$actor, \\"Done!\\" );\\n-------------------------------", "exp":"Merry code:   exp(0.0)\\nMerry result: 1.0\\n\\nMerry code:   exp(0.5)\\nMerry result: 1.6487213\\n\\nMerry code:   exp(1.0)\\nMerry result: 2.7182818\\n", "explode":"Merry code:   explode(\\"This is a test\\",\\" \\")\\nMerry result: (\{ \\"This\\", \\"is\\", \\"a\\", \\"test\\" \})\\n", "fabs":"Merry code:   fabs(-14.9)\\nMerry result: 14.9\\n", "find_object":"Merry code:   find_object(\\"/base/obj/thing#4803\\")\\nMerry result: \<Chatters:LC:ch:allen-christopher\>\\n", "findmerry":"Merry code:   FindMerry( \$actor, \\"react-post\\", \\"hit-dob\\" )\\r\\nMerry result: \<MGeneric:UrHuman\>\\r\\n", "first_elements":"Merry code:   first_elements( (\{ \\"1\\", \\"2\\", \\"3\\", \\"4\\" \}), 2 )\\r\\nMerry result: (\{ \\"1\\", \\"2\\" \})", "flatten":"Merry code:   flatten( (\{ (\{ \\"A1\\", \\"B1\\", \\"C1\\" \}), (\{ \\"A2\\", \\"B2\\", \\"C2\\" \}) \}) )\\nMerry result: (\{ \\"A1\\", \\"B1\\", \\"C1\\", \\"A2\\", \\"B2\\", \\"C2\\" \})", "floor":"Merry code:   floor(14.9)\\nMerry result: 14.0\\n", "flt":"Flt( 3 ) -\> 3.0\\nFlt( 3+3 ) -\> 6.0\\nFlt( 3.14 ) -\> 3.14\\nFlt( \\"5.9\\" ) -\> 5.9\\nFlt( \\"15\\" ) -\> 15.0\\nFlt( \\"123 muffins\\" ) -\> 123.0\\nFlt( \\"5+5\\" ) -\> 5.0\\nFlt( nil ) -\> 0.0\\nFlt( \\"Muffin\\" ) -\> ERROR: cannot convert value to float\\nFlt( \$actor.\\"base:intrinsiccapacity\\" ) -\> 10.0\\nFlt( \$actor.\\"base:actualcapacity\\" ) -\> 9.8574127", "fmod":"Merry code:   fmod(25.0,5.0)\\nMerry result: 0.0\\n\\nMerry code:   fmod(25.0,6.0)\\nMerry result: 1.0\\n", "for":"Example #1:\\n-----------\\nint step;\\nfor( step = 0; step \< 10; step ++ )\{\\nEmitTo( \$actor, \\"Taking step \\"+Str( step ));\\n\}\\nEmitTo( \$actor, \\"Done stepping. 'step' is now: \\"+Str( step ));\\n----------\\n\\nResult:\\n-------\\nTaking step 0\\nTaking step 1\\nTaking step 2\\nTaking step 3\\nTaking step 4\\nTaking step 5\\nTaking step 6\\nTaking step 7\\nTaking step 8\\nTaking step 9\\nDone stepping. 'step' is now: 10\\n-------\\n\\nExample #2:\\n-----------\\nint i;\\n\\n\$colors = (\{ \\"red\\", \\"green\\", \\"blue\\", \\"turquoise\\", \\"pink\\", \\"yellow\\" \})\\n\\nEmitTo( \$actor, \\"These colors are available:\\" );\\nfor( i = 0; i \< sizeof( \$colors ); i++ )\{\\nEmitTo( \$actor, \$colors[i] );\\n\}\\n-----------\\n\\nResult:\\n-------\\nThese colors are available:\\nred\\ngreen\\nblue\\nturquoise\\npink\\nyellow\\n-------", "format_float":"Merry code: format_float( 0.3, 4 )\\nMerry result: \\"0.3000\\"", "frexp":"Merry code:   frexp(1.0)\\nMerry result: (\{ 0.5, 1 \})\\n\\nMerry code:   frexp(1.1)\\nMerry result: (\{ 0.55, 1 \})\\n\\nMerry code:   frexp(1.5)\\nMerry result: (\{ 0.75, 1 \})\\n\\nMerry code:   frexp(2.0)\\nMerry result: (\{ 0.5, 2 \})\\n\\nMerry code:   frexp(5.0)\\nMerry result: (\{ 0.625, 3 \})\\n\\nMerry code:   frexp(10.0)\\nMerry result: (\{ 0.625, 4 \})\\n\\nMerry code:   frexp(100.0)\\nMerry result: (\{ 0.78125, 7 \})\\n", "full_explode":"Merry code:   full_explode( \\"\|foo\|\\", \\"\|\\" )\\r\\nMerry result: (\{ \\"\\", \\"foo\\", \\"\\" \})\\r\\n\\r\\n(compared to)\\r\\n\\r\\nMerry code:   explode( \\"\|foo\|\\", \\"\|\\" )\\r\\nMerry result: (\{ \\"foo\\" \})", "get":"\$foo = Get( ob, \\"prop\\" ); /* Get the property \\"prop\\" from the object ob */\\n\$foo = Get( \$actor, \\"prop\\" ); /* Get the property \\"prop\\" from the actor */\\n\$propertyName = \\"appearance:eyecolor\\";\\n\$eye = Get( \$actor, \$propertyName ); /* Get the property \\"appearance:eyecolor\\" (as defined in \$propertyName) from \$actor */\\n\$otherProperty = \\"skin\\";\\n\$skin = Get( \$actor, \\"appearance:\\" + \$otherProperty ); /* Get \\"appearance:skin\\" (whereas 'skin' is defined in \$otherProperty) from \$actor.\\n\\n\$foo = ob.\\"prop\\"; /* Get property \\"prop\\" from object ob (yes, exactly like above) */\\n\$foo = \$actor.\\"prop\\"; /* Get \\"prop\\" from actor */\\n\\nCurrently, x = Get( y, \\"z\\" ); can be shortened to x = y.\\"z\\";\\nBut this only works if the property name argument (z) is absolute. That is, we cannot: x = y.\$foo;\\n", "get_day":"Merry code:   \\"Day of the month: \\" + get_day( time() )\\r\\nMerry result: \\"Day of the month: 12\\"", "get_hour":"Merry code:   \\"Current hour: \\" + get_hour( time() )\\r\\nMerry result: \\"Current hour: 7\\"", "get_minute":"Merry code:   \\"Minutes since last new hour: \\" + get_minute( time() )\\r\\nMerry result: \\"Minutes since last new hour: 40\\"", "get_month":"Merry code:   \\"Month of the year: \\" + get_month( time() )\\r\\nMerry result: \\"Month of the year: 5\\"", "get_second":"Merry code:   \\"Seconds since last new minute: \\" + get_second( time() )\\r\\nMerry result: \\"Seconds since last new minute: 33\\"", "get_year":"Merry code:   get_year( time() )\\r\\nMerry result: 2004", "getvar":"\$name = \\"address\\";\\r\\n\$address = \\"Skogsb. 27\\";\\r\\nEmitTo( \$actor, GetVar( \$name ));\\r\\n/*\\r\\n * emits \\"Skogsb. 27\\", found in \$address, to \$actor\\r\\n */", "hash_crc16":"Merry code: hash_crc16(\\"text\\")\\nMerry result: 49980", "hash_md5":"(test cases as per http://www.ietf.org/rfc/rfc1321.txt )\\n\\nMerry code:   to_hex(hash_md5(\\"\\"))\\nMerry result: \\"d41d8cd98f00b204e9800998ecf8427e\\"\\n\\nMerry code:   to_hex(hash_md5(\\"a\\"))\\nMerry result: \\"0cc175b9c0f1b6a831c399e269772661\\"\\n\\nMerry code:   to_hex(hash_md5(\\"abc\\"))\\nMerry result: \\"900150983cd24fb0d6963f7d28e17f72\\"\\n\\nMerry code:   to_hex(hash_md5(\\"message digest\\"))\\nMerry result: \\"f96b697d7cb7938d525a2f31aaf161d0\\"\\n\\nMerry code:   to_hex(hash_md5(\\"abcdefghijklmnopqrstuvwxyz\\"))\\nMerry result: \\"c3fcd3d76192e4007dfb496cca67e13b\\"\\n\\nMerry code:   to_hex(hash_md5(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\\"))\\nMerry result: \\"d174ab98d277d9f5a5611c2c9f419d9f\\"\\n\\nMerry code:   to_hex(hash_md5(\\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\\"))\\nMerry result: \\"57edf4a22be3c955ac49da2e2107b67a\\"\\n", "hex_digit":"11 -\> 'b'", "humanized_date":"Merry code: humanized_date( time() )\\nMerry result: \\"8:19 AM, May 31st, 2003\\"", "if":"Example #1: (simple if)\\n-----------\\nif( 1 + 1 == 2 ) EmitTo( \$actor, \\"Believe it or not! 1+1 is 2!\\" );\\n/* note that we use two equal-signs ('=='), since one ('=') is reserved for setting properties (like \$a = 2) */\\n-----------\\n\\nResult:\\n-------\\nBelieve it or not! 1+1 is 2!\\n-------\\n\\nExample #2: (not equals)\\n-----------\\nif( \\"abc\\" != \\"def\\" ) EmitTo( \$actor, \\"'abc' is not 'def'\\" ); /* TRUE */\\nif( 123 != 456 )     EmitTo( \$actor, \\"123 is not 456.\\" );    /* TRUE */\\nif( 1+2+3+4 != 10 )  EmitTo( \$actor, \\"1+2+3+4 is not 10.\\" ); /* FALSE */\\n/* == means equals. != means NOT equals, thus in the above if statements, we're asking if the left value is NOT equal to the right value */\\n-----------\\n\\nResult:\\n-------\\n'abc' is not 'def'\\n123 is not 456.\\n-------\\n\\nExample #3: (less than, greater than, less/greater than or equal to)\\n-----------\\nif( 5 + 5 \> 10 ) EmitTo( \$actor, \\"5+5 is greater than 10\\" ); /* FALSE */\\nif( 10*3 \> 20 ) EmitTo( \$actor, \\"10 times 3 is greater than 20\\" ); /* TRUE */\\nif( 50 / 5 \< 20 ) EmitTo( \$actor, \\"50 divided by 5 is less than 20\\" ); /* TRUE */\\nif( 10 \>= 5 + 5 ) EmitTo( \$actor, \\"10 is more than or equal to 5+5\\" ); /* TRUE */\\nif( 50 \<= 25 * 2 ) EmitTo( \$actor, \\"50 is less than or equal to 25*2\\" ); /* TRUE */\\n-----------\\n\\nResult:\\n-------\\n10 times 3 is greater than 20\\n50 divided by 5 is less than 20\\n10 is more than or equal to 5+5\\n50 is less than or equal to 25*2\\n-------\\n\\nExample #4: (if ... else ...)\\n-----------\\nif( 10 \> 20 ) \{\\nEmitTo( \$actor, \\"10 is more than 20.\\" ); /* wrong */\\n\} else \{\\nEmitTo( \$actor, \\"10 isn't more than 20.\\" ); /* right */\\n\}\\nif( \\"George\\" == \\"James\\" ) \{\\nEmitTo( \$actor, \\"George is James.\\" ); /* wrong */\\n\} else \{\\nEmitTo( \$actor, \\"George is not James.\\" ); /* right */\\n\}\\n-----------\\n\\nResult:\\n-------\\n10 isn't more than 20.\\nGeorge is not James.\\n-------\\n\\nExample #5: (multiple condition prerequisites; AND)\\n-----------\\nif( 1 + 2 == 3 \&\& 5 \> 4 ) EmitTo( \$actor, \\"1+2 is 3, and 5 is more than 4.\\" ); /* TRUE */\\nif( 5 == 2 + 3 \&\& \\"kalle\\" == \\"you\\" ) EmitTo( \$actor, \\"5 is 2+3 and 'kalle' is 'you'.\\" ); /* FALSE */\\nif( 1+1 == 2 \&\& 1+2 == 3 \&\& 10*10 == 100 ) EmitTo( \$actor, \\"1+1 is 2, 1+2 is 3 and 10*10 is 100.\\" ); /* TRUE */\\n/* \&\& represents AND */\\n-----------\\n\\nResult:\\n-------\\n1+2 is 3, and 5 is more than 4.\\n1+1 is 2, 1+2 is 3 and 10*10 is 100.\\n-------\\n\\nExample #6: (multiple condition prerequisites; OR)\\n-----------\\nif( \\"kalle\\" == \\"you\\" \|\| \\"you\\" == \\"you\\" ) EmitTo( \$actor, \\"Either 'kalle' is 'you', or 'you' is 'you'.\\" ); /* TRUE */\\nif( 50 - 1 == 40 \|\| 9 \> 9 \|\| 1+2+3 == 6 ) EmitTo( \$actor, \\"50-1 is 40, or 9 is more than 9, or 1+2+3 is 6. Either one works (though only one is of course true).\\" ); /* TRUE */\\n/* \|\| represents OR */\\n-----------\\n\\nResult:\\n-------\\nEither 'kalle' is 'you', or 'you' is 'you'.\\n50-1 is 40, or 9 is more than 9, or 1+2+3 is 6. Either one works (though only one is of course true).\\n-------\\n\\nExample #7: (multiple condition prerequisites; parenthesis in if statements)\\n-----------\\nif( 15 == 7+8 \|\| (1 == 2 \&\& 2 == 3) ) EmitTo( \$actor, \\"15 is 7+8, or 1 is 2 and 2 is 3.\\" ); /* TRUE */\\n-----------\\n\\nResult:\\n-------\\n15 is 7+8, or 1 is 2 and 2 is 3.\\n-------\\n\\nExample #8: (variables in conditions)\\n-----------\\n\$name = \\"Kalle\\";\\nif( \$name == \\"Kalle\\" ) EmitTo( \$actor, \\"Hi Kalle!\\" ); else EmitTo( \$actor, \\"You're not Kalle.\\" );\\n\\n\$number = 123;\\nif( \$number == 100 + 20 + 3 ) EmitTo( \$actor, Str( \$number )+\\" is 100 + 20 + 3.\\" );\\n\\n\$snack = (\{ \\"muffin\\" \});\\nif( \$snack[0] == \\"muffin\\" ) EmitTo( \$actor, \\"Element 0 in the array \$snack is 'muffin'! Mmm!\\" );\\nif( sizeof( \$snack ) \> 0 ) EmitTo( \$actor, \\"Array \$snack is not empty. It has at LEAST one element.\\" );\\n-----------\\n\\nResult:\\n-------\\nHi Kalle!\\n123 is 100 + 20 + 3.\\nElement 0 in the array \$snack is 'muffin'! Mmm!\\nArray \$snack is not empty. It has at LEAST one element.\\n-------", "implode":"Merry code:   implode((\{ \\"This\\", \\"is\\", \\"a\\", \\"test\\" \}), \\" \\")\\nMerry result: \\"This is a test\\"\\n", "index":"Merry code:   \$array = (\{ \\"Kalle\\", \\"Jess\\", \\"Jim\\", \\"Bob\\" \}); EmitTo(\$actor, dump_value(index(\\"Bob\\", \$array)));\\nReturn value: 3\\nMerry code:   \$array = (\{ \\"Kalle\\", \\"Jess\\", \\"Jim\\", \\"Bob\\" \}); EmitTo(\$actor, dump_value(index(\\"George\\", \$array)));\\nReturn value: -1", "int":"Int( 3.4 ) -\> 3\\nInt( 3.5 ) -\> 4\\nInt( 123 ) -\> 123\\nInt( \\"5.9\\" ) -\> 5\\nInt( \\"15\\" ) -\> 15\\nInt( \\"15+1\\" ) -\> 15 /* note math operation unresolved */\\nInt( \\"abc\\" ) -\> ERROR: cannot convert value to integer\\nInt( \$actor.\\"base:intrinsiccapacity\\" ) -\> 10\\nInt( \\"1\\" + \\"0\\" ) -\> 10\\nInt( \\"22 years old\\" ) -\> 22\\nInt( nil ) -\> 0", "last_elements":"Merry code:   last_elements( (\{ \\"1\\", \\"2\\", \\"3\\", \\"4\\" \}), 2 )\\r\\nMerry result: (\{ \\"3\\", \\"4\\" \})", "ldexp":"Merry code:   ldexp(4.0, 0)\\nMerry result: 4.0\\n\\nMerry code:   ldexp(4.0, 1)\\nMerry result: 8.0\\n\\nMerry code:   ldexp(4.0, 2)\\nMerry result: 16.0\\n\\nMerry code:   ldexp(4.0, 3)\\nMerry result: 32.0\\n", "log":"Merry code:   log(0.5)\\nMerry result: -0.69314718\\n\\nMerry code:   log(1.0)\\nMerry result: 0.0\\n\\nMerry code:   log(2.0)\\nMerry result: 0.69314718\\n", "log10":"Merry code:   log10(0.5)\\nMerry result: -0.30103\\n\\nMerry code:   log10(1.0)\\nMerry result: 0.0\\n\\nMerry code:   log10(2.0)\\nMerry result: 0.30103\\n", "lower_case":"\\"SkotOS\\" -\> \\"skotos\\"", "make_url":"Merry code:   make_url( \\"some_page\\", ([ \\"some property\\" : \\"some value\\", \\"other property\\" : \\"other value\\", \\"actor\\" : \$actor, \\"year\\" : 2004 ]) )\\r\\nMerry result: \\"some_page?actor=Marrach%3Aplayers%3AK%3Akalle\&other property=other+value\&some property=some+value\&year=2004\\"\\r\\n", "map_indices":"Merry code:   map_indices(([ \\"Monday\\" : \\"Meatloaf\\", \\"Tuesday\\" : \\"Chicken\\", \\"Wednesday\\" : \\"Tater tots\\", \\"Thursday\\" : \\"Fish\\", \\"Friday\\" : \\"Leftovers\\", ]))\\nMerry result: (\{ \\"Friday\\", \\"Monday\\", \\"Thursday\\", \\"Tuesday\\", \\"Wednesday\\" \})\\n\\n", "map_sizeof":"Merry code: map_sizeof( ([ \\"foo\\" : \\"bar\\", \\"george\\" : \\"hamster\\" ]) )\\nMerry result: 2", "map_values":"Merry code: map_values(([ \\"Monday\\" : \\"Meatloaf\\", \\"Tuesday\\" : \\"Chicken\\", \\"Wednesday\\" : \\"Tater tots\\", \\"Thursday\\" : \\"Fish\\", \\"Friday\\" : \\"Leftovers\\", ]))\\nMerry result: (\{ \\"Leftovers\\", \\"Meatloaf\\", \\"Fish\\", \\"Chicken\\", \\"Tater tots\\" \})", "match":"\$black_cats = Match(\$actor, \\"cat\\", \$actor, \\"black\\");\\r\\nEmitTo(\$actor, \\r\\n  \\"The following black cats are in your inventory: \\" +\\r\\n   Describe(\$black_cats));", "matchplural":"\$black_cats = MatchPlural( \$actor, \\"cats\\", \$actor, \\"black\\" );\\r\\nEmitTo(\$actor, \\r\\n  \\"The following black cats are in your inventory: \\" + \\r\\n  Describe(\$black_cats));", "member":"Merry result: 1\\nMerry code:   member( \\"a\\", (\{ \\"a\\", \\"b\\", \\"c\\" \}) )", "millitime":"Merry code:   millitime()\\nMerry result: (\{ 1049514170, 0.983 \})", "modf":"Merry code:   modf(0.0)\\nMerry result: (\{ 0.0, 0.0 \})\\n\\nMerry code:   modf(0.5)\\nMerry result: (\{ 0.5, 0.0 \})\\n\\nMerry code:   modf(1.0)\\nMerry result: (\{ 0.0, 1.0 \})\\n\\nMerry code:   modf(2.0)\\nMerry result: (\{ 0.0, 2.0 \})\\n", "name":"Merry code:   name(\$actor)\\r\\nMerry result: \\"Marrach:players:K:kalle\\"", "newnref":"Merry code: NewNRef( \$actor, \\"nose\\" )\\nMerry result: (43)O(/base/data/nref#-1, \<Marrach:players:K:kalle\>, \\"nose\\")", "nrefdetail":"Merry condition: Actor is smiling at someone's arm (\$target). To figure out which part of 'someone' the actor is smiling at:\\nMerry code: NRefDetail( \$target )\\nMerry result: \\"arm", "nrefob":"Merry condition: Actor is smiling at someone's arm (\$target). To figure out who 'someone' is:\\nMerry code: NRefOb( \$target )\\nMerry result: (object reference for 'someone')", "nrefsequal":"Merry code: NRefsEqual( NewNRef( \$actor, \\"nose\\" ), NewNRef( \$actor, \\"nose\\" ))\\nMerry result: 1\\nMerry code: NRefsEqual( NewNRef( \$actor, \\"default\\" ), \$actor ))\\nMerry result: 1\\nMerry code: NRefsEqual( \$actor, \$actor )\\nMerry result: 1\\nMerry code: NRefsEqual( \$actor, NewNRef( \$actor, \\"ear\\" ))\\nMerry result: 0", "num":"Merry code:   Num( \\"4\\" )\\r\\nMerry result: 4\\r\\n\\r\\nMerry code:   Num( \\"4.5\\" )\\r\\nMerry result: 4.5\\r\\n", "number_digit":"Merry code:   number_digit( 1 )\\r\\nMerry result: 0\\r\\n\\r\\nMerry code:   number_digit( 50 )\\r\\nMerry result: 2\\r\\n\\r\\nMerry code:   number_digit( 51 )\\r\\nMerry result: 3\\r\\n\\r\\nMerry code:   number_digit( 52 )\\r\\nMerry result: 4\\r\\n\\r\\nMerry code:   number_digit( 57 )\\r\\nMerry result: 9\\r\\n\\r\\nMerry code:   number_digit( 58 )\\r\\nMerry result: 0\\r\\n\\r\\nMerry code:   number_digit( '5' )\\r\\nMerry result: 5\\r\\n\\r\\nMerry code:   number_digit( '9' )\\r\\nMerry result: 9\\r\\n", "obj":"Merry code:   Obj( \\"Generic:UrMale\\" )\\nMerry result: \<Generic:UrMale\>\\nMerry code:   Obj( \\"Something:nonexistent\\" )\\nMerry result: nil", "object_name":"Merry code:    object_name(\$actor)\\nRuntime error: object_name() is replaced by name() and ur_name()\\n\\nMerry code:    name(\$actor)\\nMerry result:  \\"Chatters:LC:ch:allen-christopher\\"\\n\\nMerry code:    ur_name(\$actor)\\nMerry result:  \\"/base/obj/thing#4803\\"\\n", "oneof":"oneof( \\"George\\", \\"James\\", \\"John\\" ) -\> either \\"George\\", \\"James\\" or \\"John\\".\\n\\"Mr. \\" + oneof( \\"George\\", \\"James\\", \\"John\\" ) + \\" \\" + oneof( \\"Georgeson\\", \\"Jameson\\", \\"Johnson\\" ) -\> Mr. George/James/John Georgeson/Jameson/Johnson, e.g. Mr. George Johnson.", "ordinal":"Merry code:   ordinal( \\"first\\" )\\r\\nMerry result: 1\\r\\n\\r\\nMerry code:   ordinal( \\"fifth\\" )\\r\\nMerry result: 5\\r\\n\\r\\nMerry code:   ordinal( \\"tenth\\" )\\r\\nMerry result: 10\\r\\n\\r\\nMerry code:   ordinal( \\"ninetyninth\\" )\\r\\nMerry result: 99", "pad_left":"Merry code: pad_left( \\"foo\\", 8 )\\nMerry result: \\"     foo\\"\\n(note that the result above contains five spaces, but only one is displayed in non-pre style)", "pad_right":"Merry code: pad_right( \\"foo\\", 8 )\\nMerry result: \\"foo     \\"\\n(note that the result above contains five spaces, but only one is displayed in non-pre style)", "parsexml":"Merry code:   ParseXML( \\"\{sam-style\|one\|of\}\\" )\\nMerry result: X[S] \{sam-style\|one\|of\}\\n\\nMerry code:   ParseXML( \\"\<describe what=\\\\\\"\$actor\\\\\\"/\>\\" )\\nMerry result: X[S] \<describe what=\\"\$(actor)\\"/\>\\n\\nMerry code:   UnSAM( ParseXML( \\"\<describe what=\\\\\\"\$actor\\\\\\"/\>\\" )\\nMerry result: \\"StoryCoder Kalle\\"\\n\\nMerry code:   ParseXML( \\"You are \<describe what=\\\\\\"\$actor\\\\\\"/\>, the \{heroic\|fantastic\|extraordinary\|hulkhoganish\|awesome\|illiterate\|analphabetic\|dyslectic\} \{thief\|villain\|joe\|wizard\|viking\|lord\|knight\|master\} \{of\|from\} \{Sweden\|Norway\|York\|Denmark\|London\|Scandinavia\}!\\" )\\nMerry result: X[S] You are \<describe what=\\"\$(actor)\\"/\>, the \{heroic\|fantastic\|extraordinary\|hulkhoganish\|awesome\|illiterate\|analphabetic\|dyslectic\} \{thief\|villain\|joe\|wizard\|viking\|lord\|knight\|master\} \{of\|from\} \{Sweden\|Norway\|York\|Denmark\|London\|Scandinavia\}!", "pow":"Merry code:   pow(10.0, 3.0)\\nMerry result: 1000.0\\n", "prefixed_map":"Merry code:   prefixed_map( ([ \\"Monday\\" : \\"Meatloaf\\", \\"Tuesday\\" : \\"Chicken\\", \\"Wednesday\\" : \\"Tater tots\\", \\"Thursday\\" : \\"Fish\\", \\"Friday\\" : \\"Leftovers\\" ]), \\"Monday\\" )\\nMerry result: ([ \\"Monday\\":\\"Meatloaf\\" ])\\n\\nMerry code:   prefixed_map( ([ \\"ape\\" : \\"monkey\\", \\"adam\\" : \\"pig\\", \\"bertram\\" : \\"prince\\" ]), \\"a\\" )\\nMerry result: ([ \\"adam\\":\\"pig\\", \\"ape\\":\\"monkey\\" ])", "previous_object":"Merry code:   previous_object()\\nMerry result: \</usr\>\\n", "previous_program":"Merry code:   previous_program()\\nMerry result: \\"/usr/SkotOS/lib/merrynode\\"\\n", "proper":"\\"the kingdom of sweden\\" -\> \\"The Kingdom Of Sweden\\"", "query_colour":"+setp me \\"test X[S] 123\\r\\n[..]\\r\\n+to me ev query_colour(\$actor.test)\\r\\nMerry code:   query_colour(\$actor.test)\\r\\nMerry result: 17\\r\\nTicks used for this code: 1350", "query_editor":"Merry code:   query_editor(\$actor)\\nMerry result: nil\\n", "random":"random(5)+1", "replace_html":"\\"foo \& bar\\" -\> \\"foo \&amp; bar\\"", "replace_strings":"Merry code: replace_strings( \\"You, someone, must something!\\", \\"someone\\", \\"Kalle\\", \\"something\\", \\"jump\\" )\\nMerry result: \\"You, Kalle, must jump!\\"", "replace_xml":"Merry code:       ParseXML( \\"1\<2 \& 3\>2\\" )\\r\\nRuntime error:    XML: file N/A line 1: unexpected token\\r\\n\\r\\nMerry code:   replace_xml( \\"1\<2 \& 3\>2\\" )\\r\\nMerry result: \\"1\\\\\\\\\&lt;2 \\\\\\\\\&amp; 3\\\\\\\\\&gt;2\\"\\r\\n\\r\\nMerry code:   ParseXML( replace_xml( \\"1\<2 \& 3\>2\\" ))\\r\\nMerry result: X[S] 1\\\\\&lt;2 \\\\\&amp; 3\\\\\&gt;2\\r\\n\\r\\nMerry code:   UnSAM( ParseXML( replace_xml( \\"1\<2 \& 3\>2\\" )))\\r\\nMerry result: \\"1\&lt;2 \&amp; 3\&gt;2\\"\\r\\n", "reverse":"Merry code:   reverse( (\{ \\"ape\\", \\"monkey\\", \\"giraffe\\" \}) )\\r\\nMerry result: (\{ \\"giraffe\\", \\"monkey\\", \\"ape\\" \})", "reverse_lookup":"Merry code:   reverse_lookup( ([ \\"a\\":1, \\"b\\":2, \\"c\\":3 ]), 2 )\\r\\nMerry result: \\"b\\"", "reverse_mapping":"Merry code: reverse_mapping( ([ \\"foo\\" : \\"bar\\", \\"name\\" : \\"kalle\\" ]) )\\nMerry result: ([ \\"bar\\":\\"foo\\", \\"kalle\\":\\"name\\" ])", "rfc_1123_date":"Merry code: rfc_1123_date( time() )\\nMerry result: \\"Sat, 31 May 2003 14:21:43 GMT\\"", "set":"\$foo = \\"I'ma value.\\";\\nSet( ob, \\"prop\\", \$foo ); /* Set \\"prop\\" in ob to \\"I'ma value.\\" (as defined in \$foo) */\\nSet( \$actor, \\"prop\\", \$foo ); /* Set \\"prop\\" in actor to \\"I'ma value.\\" (as defined in \$foo) */\\n\$changeWhat = \\"appearance:eyecolor\\";\\n\$value = \\"rainbow\\";\\nSet( \$actor, \$changeWhat, \$value ); /* Set \\"appearance:eyecolor\\" (as defined in \$changeWhat) in \$actor to \\"rainbow\\" (as defined in \$value) */\\n\$changeSomethingElse = \\"skin\\";\\n\$value = \\"pink with blue dots\\";\\nSet( \$actor, \\"appearance:\\" + \$changeSomethingElse, \$value ); /* Set \\"appearance:skin\\" in \$actor to \\"pink with blue dots\\" */\\n\\nob.\\"prop\\" = \$foo; /* Set \\"prop\\" in ob to \\"I'ma value.\\" */\\n\$actor.\\"prop\\" = \$foo;\\n\\nCurrently, Set( x, \\"y\\", z ); can be shortened to x.\\"y\\" = z;\\nBut this only works if the property name argument (y) is absolute. That is, we cannot: x.\$foo = z;", "setvar":"\$property = \\"address\\";\\r\\n\$value = \\"Skogsb. 27\\";\\r\\nSetVar( \$property, \$value );\\r\\nEmitTo( \$actor, \$address );\\r\\n/*\\r\\n * Emits \\"Skogsb. 27\\", found in \$address, to \$actor. \\r\\n */", "short_time":"Merry code:   short_time( time() )\\nMerry result: \\"May 31 08:28\\"", "sin":"Merry code:   sin(0.0)\\nMerry result: 0.0\\n\\nMerry code:   sin(0.5)\\nMerry result: 0.47942554\\n\\nMerry code:   sin(1.0)\\nMerry result: 0.84147098", "sinh":"Merry code:   sinh(0.0)\\nMerry result: 0.0\\n\\nMerry code:   sinh(0.5)\\nMerry result: 0.52109531\\n\\nMerry code:   sinh(1.0)\\nMerry result: 1.1752012\\n", "sizeof":"Merry code: sizeof( (\{ \\"foo\\", \\"bar\\", \\"george\\", \\"hamster\\" \}) )\\nMerry result: 4", "slay":"Slay( \$steaming_hot_cup_of_java );", "smalltime":"Merry code:   smalltime( time () )\\nMerry result: \\"08:29\\"", "social":"Social( \$actor, \\"smile\\" ); -\> You smile.\\nSocial( \$actor, \\"smile\\", \\"happily\\" ); -\> You smile happily.\\nSocial( \$actor, \\"smile\\", \\"happily\\", \\"G'day everyone!\\" ); -\> You smile happily, \\"G'day everyone!\\"\\nSocial( \$actor, \\"smile\\", \\"happily\\", nil, \\"at\\", \$actor ); -\> You smile happily at yourself.\\nSocial( \$actor, \\"smile\\", \\"happily\\", nil, \\"at\\", (\{ \$actor, NewNRef( \$actor, \\"toe\\" ) \}) ); -\> You smile happily at yourself and your toe.\\nSocial( \$actor, \\"turn\\", \\"seriously\\", nil, nil, NewNRef( \$actor, \\"head\\" ), \\"to\\", NewNRef( \$actor, \\"feet\\" ) ); -\> You turn seriously your head to your feet.", "spaces":"Merry code: spaces( 5 )\\nMerry result: \\"     \\"\\n(note that the result above contains five spaces, but only one is displayed in non-pre style)", "spawn":"\$steaming_hot_cup_of_java = Spawn( \$\{Generic:drink:mug-coffee\} );", "sqrt":"Merry code:   sqrt(2.0)\\nMerry result: 1.4142136", "status":"Merry code:   status()\\nMerry result: (\{ \\"DGD 1.2.55p2s\\", 997809254, 1046300140, 51470076, 1048576, 112323, 1024, 0, 0, 25037884, 24893744, 124032000, 118680792, 262144, 11447, 10000, 15, 41, 400, 40, 1048576, 8192, 243, 499975398, (\{  \}), \\"198.232.133.147\\" \})", "stop":"[Also see C. Allen's example torch at: Examples:complete:light:torch]\\n\\nSee the Every() function reference for an example.", "str":"Str( 3 ) -\> \\"3\\"\\nStr( 3+3 ) -\> \\"6\\"\\nStr( 3.14 ) -\> \\"3.14\\"\\nStr( \\"5.9\\" ) -\> \\"5.9\\"\\nStr( \\"15\\" ) -\> \\"15\\"\\nStr( \\"123 muffins\\" ) -\> \\"123 muffins\\"\\nStr( \\"5+5\\" ) -\> \\"5+5\\"\\nStr( nil ) -\> \\"\\"\\nStr( \\"Muffin\\" ) -\> \\"Muffin\\"\\nStr( \$actor.\\"base:intrinsiccapacity\\" ) -\> \\"10.0\\"\\nStr( \$actor.\\"base:actualcapacity\\" ) -\> \\"9.8574127\\"\\nStr( \$actor ) -\> \\"Marrach:players:K:kalle\\"\\nStr( (\{ \\"a\\", \\"b\\", \\"c\\" \}) ) -\> ERROR: cannot convert value to string", "string_to_hex":"'FOO' -\> 464f4f", "strip":"\\"  abc \\" -\> \\"abc\\"", "strip_left":"\\"    abc   \\" --\> \\"abc   \\"", "strip_right":"\\"   abc   \\" --\> \\"   abc\\"", "strlen":"Merry code: strlen( \\"test\\" )\\nMerry result: 4", "switch":"Example #1:\\n-----------\\n\$i = 2;\\nswitch( \$i )\{\\ncase 0:\\nEmitTo( \$actor, \\"Zero value.\\" );\\nbreak;\\n\\ncase 1:\\nEmitTo( \$actor, \\"Value is one.\\" );\\nbreak;\\n\\ncase 2:\\nEmitTo( \$actor, \\"Value is two.\\" );\\nbreak;\\n\\ndefault:\\nEmitTo( \$actor, \\"It's not 0, not 1, not 2.\\" );\\nbreak;\\n\}\\n-----------\\n\\nResult:\\n-------\\nValue is two.\\n-------\\n\\nExample #2: (advanced)\\n-----------\\n/* Compare two values, \$left and \$right, regardless of value type.\\nWe call this script lib:compare in this (since we will be calling ourselves further down) */\\n\\nif( typeof( \$left ) != typeof( \$right ))\\n/* They're not even the same type, so we check their dump values and just compare those. */\\nreturn dump_value( \$left ) == dump_value( \$right );\\n\\nswitch( typeof( \$left ))\{\\ncase T_ARRAY: /* this is an array, so we do some special checks, cause in this compare function, (\{ \\"a\\", \\"b\\" \}) is the same as (\{ \\"b\\", \\"a\\" \}) */\\n/* firstly, check if the size of both is the same (if not, they're not similar) */\\nif( sizeof( \$left ) != sizeof( \$right )) return FALSE;\\n\\n/* We sort'em. */\\n\$left = map_indices( arr_to_set( \$left ));\\n\$right = map_indices( arr_to_set( \$right ));\\n\\n/* and step through'em each to see if we find any differences */\\nfor( \$i = 0; \$i \< sizeof( \$left ); \$i++ )\\n/* Here we call ourselves recursively on each element in the array, and if we get a \\"not similar\\" anywhere, we have reached the conclusion that the two properties aren't similar */\\nif( !Call( this, \\"compare\\", \$left: \$left[\$i], \$right: \$right[\$i] )) return FALSE;\\nbreak;\\n\\ncase T_MAPPING: /* this is a mapping, so we need to do some other special checks */\\n/* size check, like we did with the arrays above, but we use 'map_sizeof' since we're dealing with mappings */\\nif( map_sizeof( \$left ) != map_sizeof( \$right )) return FALSE;\\n\\n/* Okay, sizes are right. Let's extract indices and values, and do a check on both */\\n\$left_indices = map_indices( \$left ); /* ([ \\"foo\\" : \\"bar\\" ]) becomes (\{ \\"foo\\" \}) */\\n\$right_indices = map_indices( \$right );\\nfor( \$i = 0; \$i \< sizeof( \$left_indices ); \$i++ )\\nif( !Call( this, \\"compare\\", \$left: \$left_indices[\$i], \$right: \$right_indices[\$i] )) return FALSE;\\n\\n/* indices seem to be the same; checking values now ... */\\n\$left_values = map_values( \$left ); /* ([ \\"foo\\" : \\"bar\\" ]) becomes (\{ \\"bar\\" \}) */\\n\$right_values = map_values( \$right );\\nfor( \$i = 0; \$i \< sizeof( \$left_values ); \$i++ )\\nif( !Call( this, \\"compare\\", \$left: \$left_values[\$i], \$right: \$right_values[\$i] )) return FALSE;\\n\\nbreak;\\n\\ndefault: /* anything that wasn't caught above (arrays and mappings) is caught here */\\nreturn \$left == \$right; /* simple enough, neh? */\\nbreak;\\n\\n\}\\nreturn TRUE;\\n-----------\\n\\nComment:\\n--------\\nThe above function, while a little long, is a perfect example for what switch() may be used for. Try putting the function in for instance your body and call it like:\\n+tool merry eval Call( \$actor, \\"compare\\", \$left: ([ (\{ \\"a\\", \\"b\\", \\"c\\" \}) : ([ \\"foo\\" : \\"bar\\" ]) ]), \$right : ([ (\{ \\"c\\", \\"b\\", \\"a\\" \}) : ([ \\"foo\\" : \\"bar\\" ]) ]) )\\n(which will result in a '1' which means TRUE (they are the same))\\n--------", "tan":"Merry code:   tan(0.0)\\nMerry result: 0.0\\n\\nMerry code:   tan(0.5)\\nMerry result: 0.54630249\\n\\nMerry code:   tan(1.5)\\nMerry result: 14.10142\\n", "tanh":"Merry code:   tanh(0.0)\\nMerry result: 0.0\\n\\nMerry code:   tanh(0.5)\\nMerry result: 0.46211716\\n\\nMerry code:   tanh(1.5)\\nMerry result: 0.90514825\\n", "this_object":"Merry code: this_object()\\nMerry result: \</usr/SkotOS/merry/4a6e774b0814ac8f2c8c693ec75c0e5b\>", "time":"Merry code:   time()\\nMerry result: 1049521697\\n", "to_hex":"Merry code:   to_hex( \\"Kalle\\" )\\r\\nMerry result: \\"4b616c6c65\\"", "typeof":"typeof( nil ) == 0 /* T_NIL */\\r\\ntypeof( 123 ) == 1 /* T_INT */\\r\\ntypeof( 3.14 ) == 2 /* T_FLOAT */\\r\\ntypeof( \\"abc\\" ) == 3 /* T_STRING */\\r\\ntypeof( \$actor ) == 4 /* T_OBJECT */\\r\\ntypeof( (\{ \\"a\\", \\"b\\", \\"c\\" \}) ) == 5 /* T_ARRAY */\\r\\ntypeof( ([ \\"foo\\" : \\"bar\\" ]) ) == 6 /* T_MAPPING */\\r\\n", "unsam":"Merry code:   UnSAM( ParseXML( \\"\{sam-style\|one\|of\}\\" ))\\r\\nMerry result: \\"sam-style\\"\\r\\nor:          \\"one\\"\\r\\nor:          \\"of\\"\\r\\n\\r\\nMerry code:   UnSAM( ParseXML( \\"\<describe what=\\\\\\"\$actor\\\\\\"/\>\\" ))\\r\\nMerry result: \\"StoryCoder Kalle\\"\\r\\n\\r\\nMerry code:     UnSAM( ParseXML( \\"You are \<describe what=\\\\\\"\$actor\\\\\\"/\>, the \{heroic\|fantastic\|extraordinary\|hulkhoganish\|awesome\|illiterate\|analphabetic\|dyslectic\} \{thief\|villain\|joe\|wizard\|viking\|lord\|knight\|master\} \{of\|from\} \{Sweden\|Norway\|York\|Denmark\|London\|Scandinavia\}!\\" )\\r\\nExample result: \\"You are StoryCoder Kalle, the fantastic lord from Scandinavia!\\"", "upper_case":"\\"SkotOS\\" -\> \\"SKOTOS\\"", "ur_name":"Merry code:   ur_name(\$actor)\\r\\nMerry result: \\"/base/obj/thing#82546\\"", "url_absolute":"Merry code:   url_absolute( \\"/page?somearg=somevalue\\" )\\r\\nMerry result: \\"http://marrach.skotos.net:8080/page?somearg=somevalue\\"", "url_decode":"Merry code:   url_decode( \\"Hi,+I'm+Kalle+%26+this+is+an+evil+smiley%3A+%3E%3A-)\\" )\\r\\nMerry result: \\"Hi, I'm Kalle \& this is an evil smiley: \>:-)\\"", "url_encode":"Merry code:   url_encode( \\"Hi, I'm Kalle \& this is an evil smiley: \>:-)\\" )\\r\\nMerry result: \\"Hi,+I'm+Kalle+%26+this+is+an+evil+smiley%3A+%3E%3A-)\\"", "while":"Example #1:\\n-----------\\nint i;\\n\\ni = 0;\\nwhile( i \< 10 )\{\\ni ++;\\nEmitTo( \$actor, Str(i)+\\" is less than 10.\\" );\\n\}\\nEmitTo( \$actor, Str(i)+\\" is NOT less than 10, so the while-loop has ended.\\" );\\n----------\\n\\nResult:\\n-------\\n0 is less than 10.\\n1 is less than 10.\\n2 is less than 10.\\n3 is less than 10.\\n4 is less than 10.\\n5 is less than 10.\\n6 is less than 10.\\n7 is less than 10.\\n8 is less than 10.\\n9 is less than 10.\\n10 is NOT less than 10, so the while-loop has ended.\\n-------\\n\\nExample #2:\\n-----------\\nint i = 0;\\nwhile( TRUE )\{\\ni++;\\n\}\\n/* Warning: this script will loop eternally, or rather -- until an \\"Out of ticks\\" error occurs. It is not recommended to test it. */\\n----------" ])
      </Core:Property>
      <Core:Property property="functions">
         ([ "":1149215559, "\$delay":1064538700, "=":1141086572, "acos":1054325384, "act":1081101042, "allocate":1054326515, "allocate_float":1054330272, "allocate_int":1054330679, "arr":1084366454, "arr_to_set":1058378733, "ascii_to_mixed":1054385683, "ascii_typeof":1054385091, "asin":1054330990, "atan":1054374471, "atan2":1054374415, "base64_decode":1084363372, "bilbo":1054460901, "break_paragraph":1054380954, "calculate_stamp":1084362292, "call":1139672833, "call_other":1054374555, "call_out":1054374647, "call_trace":1054377966, "capitalize":1054379679, "cardinal":1084359868, "catch":1054375139, "ceil":1054375284, "char_to_string":1084360265, "clear_by_int":1084368347, "clear_by_ob":1084368440, "clear_by_str":1084368469, "comma":1054380645, "contains":1054379601, "copy":1055689781, "cos":1054375322, "cosh":1054375357, "crypt":1054375539, "ctime":1054375633, "days":1054383804, "decapitalize":1054379811, "desc_cardinal":1054383063, "desc_ordinal":1054383119, "describe":1083687630, "dgd_version":1084364581, "do":1054387952, "dump_value":1054385544, "duplicate":1054466904, "emitin":1054322588, "emitto":1054322402, "error":1054459545, "every":1054468389, "exp":1054375883, "explode":1054377921, "fabs":1054375959, "find_object":1054376105, "findmerry":1094101812, "first_elements":1084360934, "flatten":1058380915, "flatten_structmap":1091675309, "floor":1080671070, "flt":1054466421, "fmod":1054376169, "foo":1064177840, "for":1063046736, "format_float":1054380529, "frexp":1054377889, "full_explode":1084372173, "get":1054458165, "get_by_int":1084366756, "get_by_ob":1084367847, "get_by_str":1084367909, "get_day":1084361377, "get_hour":1084361733, "get_minute":1084361961, "get_month":1084361561, "get_second":1084362244, "get_year":1084361634, "getvar":1080746172, "hash_crc16":1054376468, "hash_md5":1054376616, "hex_digit":1054382212, "humanized_date":1054383516, "if":1054474971, "implode":1054376654, "in":1096428766, "index":1058379978, "int":1054466405, "last_elements":1084360689, "ldexp":1054376685, "log":1054376756, "log10":1054376790, "lower_case":1054379222, "make_url":1084364064, "map_indices":1054377841, "map_sizeof":1054326288, "map_values":1054320856, "match":1103229532, "matchplural":1103229580, "member":1058379203, "millitime":1054377805, "mixed_to_ascii":1054385904, "modf":1054377773, "name":1109075329, "newnref":1054330059, "nrefdetail":1054329926, "nrefob":1054329792, "nrefsequal":1055688918, "num":1084364698, "number_digit":1084358787, "obj":1057423737, "object_name":1054376993, "obstat":1093918997, "oneof":1054495533, "ordinal":1084360135, "pad_left":1054380242, "pad_right":1054380437, "parse_string":1054377117, "parsexml":1054461473, "popup":1054498067, "pow":1062203323, "pre":1057935386, "prefixed_map":1054384252, "previous_object":1054377237, "previous_program":1054377272, "proper":1054379935, "query_colour":1119541497, "query_editor":1054377318, "query_ip_name":1054377355, "query_ip_number":1054377387, "random":1083598055, "replace_html":1054383425, "replace_strings":1054383164, "replace_xml":1084359246, "restore_object":1054377457, "reverse":1084360397, "reverse_lookup":1084362699, "reverse_mapping":1054384851, "rfc_1123_date":1054383669, "save_object":1054377485, "set":1054458225, "set_by_int":1084367981, "set_by_ob":1121285925, "set_by_str":1084368292, "setvar":1080745794, "short_time":1054384038, "sin":1054377518, "sinh":1054377548, "sizeof":1054326438, "slay":1054461960, "smalltime":1054384155, "social":1054422230, "spaces":1054380009, "spawn":1054461737, "sqrt":1054377607, "sscanf":1054377648, "stat":1115514781, "status":1054377717, "stop":1054468514, "str":1054466690, "string_to_hex":1054382580, "strip":1054379069, "strip_left":1054378798, "strip_right":1054378967, "strlen":1054326131, "structure_propmap":1091675297, "switch":1054413407, "tabulate":1054380802, "tag":1057935308, "tan":1054378064, "tanh":1054378090, "this_object":1055689452, "time":1054378143, "to_hex":1084358613, "typeof":1070916435, "unsam":1111087725, "upper_case":1054379339, "ur_name":1109075428, "url_absolute":1084364481, "url_decode":1084363845, "url_encode":1084363722, "while":1054387594 ])
      </Core:Property>
      <Core:Property property="names">
         ([ "\$delay":"\$delay", "=":"=", "acos":"acos", "act":"Act", "allocate":"allocate", "allocate_float":"allocate_float", "allocate_int":"allocate_int", "arr":"Arr", "arr_to_set":"arr_to_set", "ascii_to_mixed":"ascii_to_mixed", "ascii_typeof":"ascii_typeof", "asin":"asin", "atan":"atan", "atan2":"atan2", "base64_decode":"base64_decode", "bilbo":"Bilbo", "break_paragraph":"break_paragraph", "calculate_stamp":"calculate_stamp", "call":"Call", "call_other":"call_other", "call_out":"call_out", "call_trace":"call_trace", "capitalize":"capitalize", "cardinal":"cardinal", "catch":"catch", "ceil":"ceil", "char_to_string":"char_to_string", "clear_by_int":"clear_by_int", "clear_by_ob":"clear_by_ob", "clear_by_str":"clear_by_str", "comma":"comma", "contains":"contains", "copy":"copy", "cos":"cos", "cosh":"cosh", "crypt":"crypt", "ctime":"ctime", "days":"days", "decapitalize":"decapitalize", "desc_cardinal":"desc_cardinal", "desc_ordinal":"desc_ordinal", "describe":"Describe", "dgd_version":"dgd_version", "do":"do", "dump_value":"dump_value", "duplicate":"Duplicate", "emitin":"EmitIn", "emitto":"EmitTo", "error":"error", "every":"Every", "exp":"exp", "explode":"explode", "fabs":"fabs", "find_object":"find_object", "findmerry":"FindMerry", "first_elements":"first_elements", "flatten":"flatten", "flatten_structmap":"flatten_structmap", "floor":"floor", "flt":"Flt", "fmod":"fmod", "foo":"foo", "for":"for", "format_float":"format_float", "frexp":"frexp", "full_explode":"full_explode", "get":"Get", "get_by_int":"get_by_int", "get_by_ob":"get_by_ob", "get_by_str":"get_by_str", "get_day":"get_day", "get_hour":"get_hour", "get_minute":"get_minute", "get_month":"get_month", "get_second":"get_second", "get_year":"get_year", "getvar":"GetVar", "hash_crc16":"hash_crc16", "hash_md5":"hash_md5", "hex_digit":"hex_digit", "humanized_date":"humanized_date", "if":"if", "implode":"implode", "in":"In", "index":"index", "int":"Int", "last_elements":"last_elements", "ldexp":"ldexp", "log":"log", "log10":"log10", "lower_case":"lower_case", "make_url":"make_url", "map_indices":"map_indices", "map_sizeof":"map_sizeof", "map_values":"map_values", "match":"Match", "matchplural":"MatchPlural", "member":"member", "millitime":"millitime", "mixed_to_ascii":"mixed_to_ascii", "modf":"modf", "name":"name", "newnref":"NewNRef", "nrefdetail":"NRefDetail", "nrefob":"NRefOb", "nrefsequal":"NRefsEqual", "num":"Num", "number_digit":"number_digit", "obj":"Obj", "object_name":"object_name", "obstat":"obstat", "oneof":"oneof", "ordinal":"ordinal", "pad_left":"pad_left", "pad_right":"pad_right", "parse_string":"parse_string", "parsexml":"ParseXML", "popup":"Popup", "pow":"pow", "pre":"PRE", "prefixed_map":"prefixed_map", "previous_object":"previous_object", "previous_program":"previous_program", "proper":"proper", "query_colour":"query_colour", "query_editor":"query_editor", "query_ip_name":"query_ip_name", "query_ip_number":"query_ip_number", "random":"random", "replace_html":"replace_html", "replace_strings":"replace_strings", "replace_xml":"replace_xml", "restore_object":"restore_object", "reverse":"reverse", "reverse_lookup":"reverse_lookup", "reverse_mapping":"reverse_mapping", "rfc_1123_date":"rfc_1123_date", "save_object":"save_object", "set":"Set", "set_by_int":"set_by_int", "set_by_ob":"set_by_ob", "set_by_str":"set_by_str", "setvar":"SetVar", "short_time":"short_time", "sin":"sin", "sinh":"sinh", "sizeof":"sizeof", "slay":"Slay", "smalltime":"smalltime", "social":"Social", "spaces":"spaces", "spawn":"Spawn", "sqrt":"sqrt", "sscanf":"sscanf", "stat":"stat", "status":"status", "stop":"Stop", "str":"Str", "string_to_hex":"string_to_hex", "strip":"strip", "strip_left":"strip_left", "strip_right":"strip_right", "strlen":"strlen", "structure_propmap":"structure_propmap", "switch":"switch", "tabulate":"tabulate", "tag":"TAG", "tan":"tan", "tanh":"tanh", "this_object":"this_object", "time":"time", "to_hex":"to_hex", "typeof":"typeof", "unsam":"unsam", "upper_case":"upper_case", "ur_name":"ur_name", "url_absolute":"url_absolute", "url_decode":"url_decode", "url_encode":"url_encode", "while":"while" ])
      </Core:Property>
      <Core:Property property="related">
         ([ "acos":(\{ "asin", "atan" \}), "act":(\{ "Social" \}), "allocate":(\{ "sizeof" \}), "allocate_float":(\{ "allocate", "allocate_int", "sizeof" \}), "allocate_int":(\{ "allocate", "allocate_float", "sizeof" \}), "arr":(\{ "Str", "Int", "Flt", "Num", "Map" \}), "arr_to_set":(\{ "map_values", "map_indices", "reverse_mapping" \}), "ascii_to_mixed":(\{ "mixed_to_ascii", "dump_value" \}), "ascii_typeof":(\{ "typeof" \}), "asin":(\{ "acos", "atan" \}), "atan":(\{ "acos", "asin", "atan2" \}), "atan2":(\{ "atan" \}), "calculate_stamp":(\{ "time", "ctime", "short_time", "smalltime", "get_day", "get_month", "get_year", "get_hour", "get_minute", "get_second" \}), "call":(\{ "call_other", "call_out", "call_trace" \}), "call_trace":(\{ "previous_object" \}), "capitalize":(\{ "lower_case", "upper_case", "decapitalize", "proper" \}), "cardinal":(\{ "ordinal", "desc_ordinal", "desc_cardinal" \}), "catch":(\{ "error" \}), "ceil":(\{ "floor", "fmod" \}), "clear_by_int":(\{ "get_by_int", "set_by_int", "get_by_ob", "set_by_ob", "clear_by_ob", "get_by_str", "set_by_str", "clear_by_str" \}), "clear_by_ob":(\{ "get_by_int", "set_by_int", "clear_by_int", "get_by_ob", "set_by_ob", "clear_by_ob", "get_by_str", "set_by_str", "clear_by_str" \}), "clear_by_str":(\{ "get_by_int", "set_by_int", "clear_by_int", "get_by_ob", "set_by_ob", "clear_by_ob", "get_by_str", "set_by_str" \}), "contains":(\{ "sscanf" \}), "cos":(\{ "sin", "kfun" \}), "cosh":(\{ "sinh", "tanh" \}), "ctime":(\{ "time", "short_time", "rfc_1123_date" \}), "days":(\{ "ctime", "time", "short_time", "humanized_date", "rfc_1123_date", "smalltime" \}), "decapitalize":(\{ "lower_case", "upper_case", "capitalize", "proper" \}), "desc_cardinal":(\{ "desc_ordinal" \}), "desc_ordinal":(\{ "desc_cardinal" \}), "do":(\{ "for", "while" \}), "dump_value":(\{ "ascii_to_mixed", "mixed_to_ascii" \}), "duplicate":(\{ "Spawn", "Slay" \}), "emitin":(\{ "EmitTo" \}), "emitto":(\{ "EmitIn" \}), "error":(\{ "catch" \}), "every":(\{ "Stop" \}), "exp":(\{ "log", "log10", "pow" \}), "explode":(\{ "implode", "sscanf", "parse_string" \}), "find_object":(\{ "object_name" \}), "first_elements":(\{ "last_elements" \}), "floor":(\{ "ceil", "fmod" \}), "flt":(\{ "Int", "Str", "dump_value", "mixed_to_ascii", "ascii_to_mixed" \}), "fmod":(\{ "ceil", "floor" \}), "for":(\{ "while", "do" \}), "frexp":(\{ "ldexp", "modf" \}), "full_explode":(\{ "explode", "implode" \}), "get":(\{ "Set" \}), "get_by_int":(\{ "set_by_int", "clear_by_int", "get_by_ob", "set_by_ob", "clear_by_ob", "get_by_str", "set_by_str", "clear_by_str" \}), "get_by_ob":(\{ "get_by_int", "set_by_int", "clear_by_int", "set_by_ob", "clear_by_ob", "get_by_str", "set_by_str", "clear_by_str" \}), "get_by_str":(\{ "get_by_int", "set_by_int", "clear_by_int", "get_by_ob", "set_by_ob", "clear_by_ob", "set_by_str", "clear_by_str" \}), "get_day":(\{ "time", "ctime", "short_time", "smalltime", "get_month", "get_year", "get_hour", "get_minute", "get_second", "calculate_stamp" \}), "get_hour":(\{ "time", "ctime", "short_time", "smalltime", "get_day", "get_month", "get_year", "get_minute", "get_second", "calculate_stamp" \}), "get_minute":(\{ "time", "ctime", "short_time", "smalltime", "get_day", "get_month", "get_year", "get_hour", "get_second", "calculate_stamp" \}), "get_month":(\{ "time", "ctime", "short_time", "smalltime", "get_day", "get_year", "get_hour", "get_minute", "get_second", "calculate_stamp" \}), "get_second":(\{ "time", "ctime", "short_time", "smalltime", "get_day", "get_month", "get_year", "get_hour", "get_minute", "calculate_stamp" \}), "get_year":(\{ "time", "ctime", "short_time", "smalltime", "get_day", "get_month", "get_hour", "get_minute", "get_second", "calculate_stamp" \}), "getvar":(\{ "SetVar", "Set", "Get" \}), "hash_crc16":(\{ "hash_md5" \}), "hash_md5":(\{ "hash_crc16" \}), "hex_digit":(\{ "string_to_hex" \}), "humanized_date":(\{ "ctime", "time", "short_time", "rfc_1123_date", "days", "smalltime" \}), "if":(\{ "switch" \}), "implode":(\{ "explode", "sscanf", "parse_string" \}), "index":(\{ "member" \}), "int":(\{ "Flt", "Str", "dump_value", "mixed_to_ascii", "ascii_to_mixed" \}), "last_elements":(\{ "first_elements" \}), "ldexp":(\{ "frexp", "modf" \}), "log":(\{ "exp", "log10", "pow" \}), "log10":(\{ "exp", "log", "pow" \}), "lower_case":(\{ "upper_case", "capitalize", "decapitalize", "proper" \}), "make_url":(\{ "url_decode", "url_encode", "url_absolute" \}), "map_indices":(\{ "map_values" \}), "map_sizeof":(\{ "sizeof", "strlen" \}), "map_values":(\{ "map_indices" \}), "match":(\{ "MatchPlural" \}), "matchplural":(\{ "Match" \}), "millitime":(\{ "time", "ctime" \}), "mixed_to_ascii":(\{ "ascii_to_mixed", "dump_value" \}), "modf":(\{ "frexp", "ldexp" \}), "name":(\{ "ur_name" \}), "newnref":(\{ "NRefOb", "NRefDetail" \}), "nrefdetail":(\{ "NRefOb", "NewNRef" \}), "nrefob":(\{ "NRefDetail", "NewNRef" \}), "nrefsequal":(\{ "NRefOb", "NRefDetail", "NewNRef" \}), "num":(\{ "Str", "Int", "Flt", "Arr", "Map" \}), "object_name":(\{ "find_object" \}), "ordinal":(\{ "cardinal", "desc_ordinal", "desc_cardinal" \}), "pad_left":(\{ "strip_left", "strip_right", "strip", "pad_right" \}), "pad_right":(\{ "strip_left", "strip_right", "strip", "pad_left" \}), "parse_string":(\{ "sscanf", "explode", "implode" \}), "parsexml":(\{ "UnSAM" \}), "pow":(\{ "exp", "log", "log10" \}), "pre":(\{ "TAG" \}), "previous_object":(\{ "call_other", "this_object", "call_trace" \}), "previous_program":(\{ "previous_object", "call_trace" \}), "proper":(\{ "lower_case", "upper_case", "capitalize", "decapitalize" \}), "query_colour":(\{ "typeof", "ascii_typeof" \}), "query_ip_name":(\{ "query_ip_number", "send_datagram", "send_message", "this_user", "users" \}), "replace_xml":(\{ "ParseXML", "UnSAM" \}), "restore_object":(\{ "save_object" \}), "reverse":(\{ "reverse_mapping" \}), "reverse_lookup":(\{ "map_indices", "map_values" \}), "rfc_1123_date":(\{ "ctime", "time", "short_time", "humanized_date", "days", "smalltime" \}), "set":(\{ "Get" \}), "set_by_int":(\{ "get_by_int", "clear_by_int", "get_by_ob", "set_by_ob", "clear_by_ob", "get_by_str", "set_by_str", "clear_by_str" \}), "set_by_ob":(\{ "get_by_int", "set_by_int", "clear_by_int", "get_by_ob", "clear_by_ob", "get_by_str", "set_by_str", "clear_by_str" \}), "set_by_str":(\{ "get_by_int", "set_by_int", "clear_by_int", "get_by_ob", "set_by_ob", "clear_by_ob", "get_by_str", "set_by_str", "clear_by_str" \}), "setvar":(\{ "GetVar", "Set", "Get" \}), "short_time":(\{ "ctime", "time", "humanized_date", "rfc_1123_date", "days", "smalltime" \}), "sin":(\{ "cos", "tan" \}), "sinh":(\{ "cosh", "tanh" \}), "sizeof":(\{ "map_sizeof", "strlen" \}), "slay":(\{ "Spawn", "Duplicate" \}), "smalltime":(\{ "ctime", "time", "humanized_date", "rfc_1123_date", "days", "short_time" \}), "social":(\{ "Act", "EmitTo", "EmitIn" \}), "spaces":(\{ "pad_left", "pad_right" \}), "spawn":(\{ "Duplicate", "Slay" \}), "sscanf":(\{ "parse_string", "explode", "implode" \}), "stop":(\{ "Every" \}), "str":(\{ "Int", "Flt", "dump_value", "mixed_to_ascii", "ascii_to_mixed" \}), "string_to_hex":(\{ "hex_digit" \}), "strip":(\{ "strip_left", "strip_right", "pad_left", "pad_right" \}), "strip_left":(\{ "strip_right", "strip", "pad_left", "pad_right" \}), "strip_right":(\{ "strip_left", "strip", "pad_left", "pad_right" \}), "strlen":(\{ "map_sizeof", "sizeof" \}), "switch":(\{ "if", "break" \}), "tag":(\{ "PRE" \}), "tan":(\{ "cos", "sin" \}), "tanh":(\{ "cosh", "sinh" \}), "this_object":(\{ "previous_object" \}), "time":(\{ "ctime" \}), "unsam":(\{ "ParseXML" \}), "upper_case":(\{ "lower_case", "capitalize", "decapitalize", "proper" \}), "ur_name":(\{ "name" \}), "url_absolute":(\{ "url_decode", "url_encode", "make_url" \}), "url_decode":(\{ "url_encode", "make_url", "url_absolute" \}), "url_encode":(\{ "url_decode", "make_url", "url_absolute" \}), "while":(\{ "for", "do" \}) ])
      </Core:Property>
      <Core:Property property="retprops">
         ([ "acos":"float", "act":"void", "allocate":"mixed *", "allocate_float":"float *", "allocate_int":"int *", "arr":"mixed *", "arr_to_set":"mapping", "ascii_to_mixed":"mixed", "ascii_typeof":"string", "asin":"float", "atan":"float", "atan2":"float", "bilbo":"void", "break_paragraph":"string", "calculate_stamp":"int", "call":"mixed", "call_other":"varargs mixed", "call_out":"varargs int", "call_trace":"mixed **", "capitalize":"string", "cardinal":"int", "catch":"string", "ceil":"float", "clear_by_int":"void", "clear_by_ob":"void", "clear_by_str":"void", "comma":"string", "contains":"int", "copy":"mixed", "cos":"float", "cosh":"float", "crypt":"varargs string", "ctime":"string", "days":"string", "decapitalize":"string", "desc_cardinal":"string", "desc_ordinal":"string", "describe":"string", "dgd_version":"int", "dump_value":"string", "duplicate":"object", "emitin":"void", "emitto":"void", "error":"void", "every":"string", "exp":"float", "explode":"string *", "fabs":"float", "find_object":"object", "findmerry":"object", "first_elements":"mixed *", "flatten":"array", "floor":"float", "flt":"float", "fmod":"float", "format_float":"string", "frexp":"mixed *", "full_explode":"string *", "get":"mixed", "get_by_int":"mixed", "get_by_ob":"mixed", "get_by_str":"mixed", "get_day":"int", "get_hour":"int", "get_minute":"int", "get_month":"int", "get_second":"int", "get_year":"int", "getvar":"mixed", "hash_crc16":"int", "hash_md5":"string", "hex_digit":"int", "humanized_date":"string", "implode":"string", "index":"The index value in \<a\> for the first occurence of the value \<val\>.", "int":"int", "last_elements":"mixed *", "ldexp":"float", "log":"float", "log10":"float", "lower_case":"string", "make_url":"string", "map_indices":"mixed *", "map_sizeof":"int", "map_values":"mixed *", "match":"NRef *", "matchplural":"NRef *", "member":"int", "millitime":"mixed *", "mixed_to_ascii":"string", "modf":"float *", "name":"string", "newnref":"NRef", "nrefdetail":"string", "nrefob":"object", "nrefsequal":"int", "num":"mixed", "number_digit":"int", "obj":"object", "object_name":"string", "oneof":"string", "ordinal":"int", "pad_left":"string", "pad_right":"string", "parse_string":"mixed", "parsexml":"mixed", "popup":"void", "pow":"float", "pre":"string", "prefixed_map":"mapping", "previous_object":"varargs object", "previous_program":"string", "proper":"string", "query_colour":"int", "query_editor":"string", "query_ip_name":"string", "query_ip_number":"string", "random":"int", "replace_html":"string", "replace_strings":"string", "replace_xml":"string", "restore_object":"int", "reverse":"mixed *", "reverse_lookup":"mixed", "reverse_mapping":"mapping", "rfc_1123_date":"string", "save_object":"void", "set":"void", "set_by_int":"void", "set_by_ob":"void", "set_by_str":"void", "short_time":"string", "sin":"float", "sinh":"float", "sizeof":"int", "slay":"void", "smalltime":"string", "social":"void", "spaces":"string", "spawn":"object", "sqrt":"float", "sscanf":"int", "status":"varargs mixed *", "stop":"void", "str":"string", "string_to_hex":"string", "strip":"string", "strip_left":"string", "strip_right":"string", "strlen":"int", "tabulate":"string", "tag":"string", "tan":"float", "tanh":"float", "this_object":"object", "time":"int", "to_hex":"string", "typeof":"int", "unsam":"string", "upper_case":"string", "ur_name":"string", "url_absolute":"string", "url_decode":"string", "url_encode":"string" ])
      </Core:Property>
      <Core:Property property="returns">
         ([ "acos":"Return the arc cosine of the argument as a float.", "allocate":"Return an array with size number of elements, allocated and set to nil.", "allocate_float":"Return an array of allocated floats set to 0.0.", "allocate_int":"Return an array of allocated integers set to 0.", "arr":"Ensured array.", "arr_to_set":"Returns the content of a as a mapping, each value equal to 1.", "asin":"Return the arc sine of the argument.", "calculate_stamp":"UNIX timestamp of the supplied date.", "cardinal":"Integer value of the English cardinal in \<str\>.", "char_to_string":"string", "copy":"Return a copy of var.", "describe":"Return string description of o.", "dgd_version":"The version of the DGD server.", "findmerry":"Object pointer to object which contains the specified Merry script, or nil if none was found.", "first_elements":"The equivalent of arr[..(num\>sizeof(arr)-1?sizeof(arr)-1:num)].", "flatten":"Converts a two-dimensional array into a regular array.", "full_explode":"Array result of \<str\> chopped by \<del\>.", "get_day":"The month day of the date in timestamp \<n\>.", "get_hour":"Integer value of the current hour as specified in timestamp \<n\>.", "get_minute":"Integer value of the current minute of the hour, as specified in timestamp \<n\>.", "get_month":"The month of the date in timestamp \<n\>.", "get_second":"Integer value of the current seconds since last new minute, as specified in timestamp \<n\>.", "get_year":"Integer value of the year in timestamp \<n\>.", "getvar":"The value of args[n], or \$(n).", "index":"int", "last_elements":"The equivalent of arr[(num\>sizeof( arr )-1 ? 0 : sizeof( arr )-num)..].", "make_url":"URL to the HTML/SAM page \<base\>, passing the arguments \<args\>.", "map_indices":"Return an array containing the indices (keys) of mapping map.", "map_sizeof":"Return the size of the mapping as an integer.", "map_values":"Return an array containing the values of mapping map, sorted in the order of the corresponding indices (keys).", "match":"Array of NRefs (details) matching the name/adjectives given.", "matchplural":"Array of NRefs (details) matching the pname/adjectives given.", "member":"TRUE (1) if either value in \<a\> is equal to the value of \<m\>.", "name":"Object name (woename) of ob.", "newnref":"Return an NRef of detail in obj.", "nrefdetail":"Extract the detail name of n as a string.", "nrefob":"Extract object reference from n.", "nrefsequal":"TRUE if left is the same as right; FALSE if left is not the same as right.", "num":"Float or integer extracted from \<v\>.", "number_digit":"The number, if any, representing the character code of \<hexvalue\>, or 0 if none.", "obj":"Object reference for \<s\>, or nil if no object is found.", "ordinal":"Integer value of the ordinal \<str\>.", "pre":"Preformat style wrapped string.", "query_colour":"Integer representation.", "random":"int", "replace_xml":"Escaped string value.", "reverse":"Reversed version of the original, \<orig\>.", "reverse_lookup":"The indice pointing at the value \<val\>.", "sizeof":"Return the number of elements in array arr.", "strlen":"Returns the length of s as an integer value.", "tag":"Theme-color tagged string.", "this_object":"Internal object reference to 'this'.", "to_hex":"Hexadecimal value of \<bytes\>.", "ur_name":"Ur-name (not woename!) of ob.", "url_absolute":"The absolute path to the URL \<str\>, taking into consideration server and port information, etc.", "url_decode":"Decoded URL-encoded string.", "url_encode":"Proper string for usage in URL's." ])
      </Core:Property>
      <Core:Property property="revisions">
         (\{ 1054315905, "zwoc", "E", 1054315923, "zwoc", "E", 1054315943, "zwoc", "E", 1054315959, "zwoc", "E", 1054315972, "zwoc", "E", 1054315983, "zwoc", "E", 1054318010, "zwoc", "E", 1054318022, "zwoc", "E", 1054318123, "zwoc", "E", 1054318405, "zwoc", "E", 1054322135, "zwoc", "E", 1054325665, "zwoc", "E", 1054325687, "zwoc", "E", 1054325715, "zwoc", "E", 1054325787, "zwoc", "E", 1054325806, "zwoc", "E", 1054373174, "zwoc", "E", 1054373234, "zwoc", "E", 1054373299, "zwoc", "E", 1054373499, "zwoc", "E", 1054373700, "zwoc", "E", 1054375773, "zwoc", "E", 1054380924, "zwoc", "E", 1149305301, "nino", "P" \})
      </Core:Property>
      <Core:Property property="syntaxes">
         ([ "\$delay":"mixed wait, mixed return[, string id]", "acos":"float x", "act":"object ob, string action, special arguments", "allocate":"int size", "allocate_float":"int size", "allocate_int":"int size", "arr":"mixed v", "arr_to_set":"array a", "ascii_to_mixed":"string str", "ascii_typeof":"mixed value", "asin":"float x", "atan":"float x", "atan2":"float y, float x", "bilbo":"object ob, string signaltype, string signalname, special arguments", "break_paragraph":"string head, string str, int len", "calculate_stamp":"int year, int month, int day", "call":"object ob, string script, special arguments", "call_other":"mixed obj, string function, mixed args...", "call_out":"string function, int delay, mixed args...", "capitalize":"string str", "cardinal":"string str", "catch":"expression", "ceil":"float x", "char_to_string":"int ch", "clear_by_int":"mapping bigmap, int ix", "clear_by_ob":"mapping bigmap, object ob", "clear_by_str":"mapping bigmap, string str", "comma":"int num", "contains":"string str, string sub", "copy":"mixed var", "cos":"float x", "cosh":"float x", "crypt":"string passwd, string salt", "ctime":"int clock", "days":"int n", "decapitalize":"string str", "desc_cardinal":"int n", "desc_ordinal":"int n", "describe":"object o", "dump_value":"mixed value", "duplicate":"object ob", "emitin":"object o, string s, object exclude_one, object exclode_another, ...", "emitto":"object o, string s", "error":"string errormessage", "every":"string script, int frequency", "exp":"float x", "explode":"string str, string separator", "fabs":"float x", "find_object":"string obj", "findmerry":"object src, string type, string name", "first_elements":"mixed arr, int num", "flatten":"mixed **value", "floor":"float x", "flt":"mixed value", "fmod":"float x, float y", "for":"\<once\>; \<check\>; \<do\>", "format_float":"float f, int dec", "frexp":"float x", "full_explode":"string str, string del", "get":"object ob, string property", "get_by_int":"mapping bigmap, int ix", "get_by_ob":"mapping bigmap, object ob", "get_by_str":"mapping bigmap, string str", "get_day":"int n", "get_hour":"int n", "get_minute":"int n", "get_month":"int n", "get_second":"int n", "get_year":"int n", "getvar":"string n", "hash_crc16":"string str, string extra...", "hash_md5":"string str, string extra...", "hex_digit":"int nibble", "humanized_date":"int n", "if":"\<condition\>", "implode":"string *arr, string separator", "index":"mixed val, array a", "int":"mixed value", "last_elements":"mixed arr, int num", "ldexp":"float x, int n", "log":"float x", "log10":"float x", "lower_case":"string str", "make_url":"string base, mapping args, varargs int secure", "map_indices":"mapping map", "map_sizeof":"mapping map", "map_values":"mapping map", "match":"object ob, string name, varargs object looker, string adj...", "matchplural":"object ob, string pname, varargs object looker, string adj...", "member":"mixed m, array a", "mixed_to_ascii":"mixed value", "modf":"float x", "name":"object ob", "newnref":"object obj, string detail", "nrefdetail":"NRef n", "nrefob":"NRef n", "nrefsequal":"NRef left, NRef right", "num":"mixed v", "number_digit":"int hexvalue", "obj":"string s", "object_name":"object obj", "oneof":"string alt1, string alt2, ...", "ordinal":"string str", "pad_left":"string var, int size", "pad_right":"string var, int size", "parse_string":"string format, string str", "parsexml":"string XML", "popup":"object recipient, object source, string what", "pow":"float x, float y", "pre":"string str", "prefixed_map":"mapping map, string prefix", "previous_object":"int n", "previous_program":"varargs int n", "proper":"string str", "query_colour":"query_colour(mixed v)", "query_editor":"object obj", "query_ip_name":"object user", "query_ip_number":"object user", "random":"int mod", "replace_html":"string str", "replace_strings":"string str, string swaps...", "replace_xml":"string str", "restore_object":"string file", "reverse":"mixed *orig", "reverse_lookup":"mapping map, mixed val", "reverse_mapping":"mapping map", "rfc_1123_date":"int n", "save_object":"string file", "set":"object ob, string property, mixed value", "set_by_int":"mapping bigmap, int ix, mixed val", "set_by_ob":"mapping bigmap, object ob, mixed val", "set_by_str":"mapping bigmap, string str, mixed val", "setvar":"string n, mixed v", "short_time":"int stamp", "sin":"float x", "sinh":"float x", "sizeof":"mixed *arr", "slay":"object ob", "smalltime":"int stamp", "social":"object ob, string verb, string adverb, string evoke, string prep1, NRef *obs1, string prep2, NRef *obs2, ...", "spaces":"int num", "spawn":"object ob", "sqrt":"float x", "sscanf":"string str, string fmt, ...", "status":"object obj", "stop":"string identifier", "str":"mixed value", "string_to_hex":"string bytes", "strip":"string str", "strip_left":"string str", "strip_right":"string str", "strlen":"string s", "switch":"mixed value", "tabulate":"mixed *arrlist...", "tag":"string str, string tag", "tan":"float x", "tanh":"float x", "to_hex":"string bytes", "typeof":"mixed value", "unsam":"mixed SAM", "upper_case":"string str", "ur_name":"object ob", "url_absolute":"string url", "url_decode":"string str", "url_encode":"string str", "while":"\<condition\>" ])
      </Core:Property>
      <Core:Property property="type_properties">
         (\{ "string", "string", "string", "array_commas", "array_strings", "array_strings" \})
      </Core:Property>
    </Core:PCProperties>
    <Notes:Notes/>
  </Core:PropertyContainer>
</object>
